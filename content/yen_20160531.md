Title: 網際 2D 正齒輪協同繪圖規劃
Category: Courses
Tags: 2016 Spring, 協同產品設計實習
Author: kmol

利用 Python 物件導向架構執行網際 2D 正齒輪傳動協同繪圖時, 各組員可以將各種不同繪圖元件, 建置在個人的網頁空間中, 讓其他參與協同的組員連結應用. 唯一必須注意的是, 就網際繪圖模式而言, 儘管 Brython 繪圖最終仍轉為 JavaScript, 以 Canvas 或 WebGL 完成繪圖, 但是 Python 程式碼在各自的 script 標註中屬於各自的命名空間 (此點與 Prototype based 的 JavaScript 有很大的差別), 因此以下的範例, 必須將各自在引用的 script 標註中, 以 id 命名, 然後根據 id 名稱, 在其他命名空間中以 import 引用.

<!-- PELICAN_END_SUMMARY -->

以下為 17 齒, 29 齒與 15 齒輪組的囓合繪圖, 其中的漸開線正齒輪 2D 繪圖程式庫以類別建立, 並且存在 <a href="http://cadlab.mde.tw/post/by/spur.js">http://cadlab.mde.tw/post/by/spur.js</a>, 之所以採用 .js 命名, 主要在避開修改瀏覽器中的 MIME 對應, 可以直接在隨後的 Brython 程式中, 以 import 方式引用:

<script type="text/javascript" src="http://brython.info/src/brython_dist.js"></script>
<script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"></script>
<script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"></script>
<script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"></script>
  
<script>
window.onload=function(){
brython(1);
}
</script>

<div id="container"></div>
   
<script type="text/python" src="http://cadlab.mde.tw/post/by/spur.js" id="spurmain"></script>

<script type="text/python">
import spurmain
from browser import document, html
# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container <= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# 這裡的齒輪繪圖以所導入的 spurmain 模組中的 Spur 類別建立對應的 gear 變數, 且宣告畫布 id
gear = spurmain.Spur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.spur(cx, cy, m, n1, pa, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3+(180-180/n2)*n2/n3)
</script>

上述繪圖的程式碼:

<pre class="brush: python">
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;&lt;/script&gt;
  
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;div id="container"&gt;&lt;/div&gt;
   
&lt;script type="text/python" src="http://cadlab.mde.tw/post/by/spur.js" id="spurmain"&gt;&lt;/script&gt;

&lt;script type="text/python"&gt;
import spurmain
from browser import document, html
# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# 這裡的齒輪繪圖以所導入的 spurmain 模組中的 Spur 類別建立對應的 gear 變數, 且宣告畫布 id
gear = spurmain.Spur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.spur(cx, cy, m, n1, pa, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3+(180-180/n2)*n2/n3)
&lt;/script&gt;
</pre>

上面的 2D 齒輪繪圖, 雖然引用雲端上的繪圖程式庫, 可以統一控管各程式庫的版本, 但是若不同程式庫間的主機無法連結, 或者當程式庫更新後, 先前所採用的舊繪圖函式可能無法相容或無法完成繪圖, 因此在雲端建置電腦輔助機械設計架構時, 必須採用類似 Onshape 的作法, 雖然所有的程式庫統一更新, 但是各種零組件在建立時, 透過當時所使用的模型主體 (Context), 儲存了所使用的標準零件庫版本, 除非使用者刻意更新, 否則所有的雲端設計專案都將在各自原先的版本命名空間中獨立運作, 不會產生版本分歧或謬誤的問題.

以下則利用 Python 的物件導向, 另外建立一個畫布繪圖, 其中除了使用 Brython 程式方法, 即時建立 CANVAS 畫布外, 也同時採用物件繼承的方式, 引用遠端的 spur.js 繪圖程式庫, 並且加入鏈條與鏈輪的繪圖元件:

<div id="container1"></div>

<script type="text/python">
import spurmain
from browser import document, html

# 建立新的繪圖方法 sprocket 用
from browser import window
from javascript import JSConstructor
import math
   
cango = JSConstructor(window.Cango)
shapedefs = window.shapeDefs
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

class mySpur(spurmain.Spur):
    # 定義 sprocket
    # rs 為 roller rasius
    # pc 為 pitch
    def sprocket(self, cx, cy, rs, pc, n, theta):
        self.cx = cx
        self.cy = cy
        self.rs = rs
        self.pc = pc
        self.n = n
        self.pa = pa
        self.theta = theta
        rotangle = 360/self.n
        pr = self.pc/2/math.sin((rotangle/2)*math.pi/180)
        pt1x = pr-rs
        pt1y = 0
        pt2x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*rs/pc
        pt2y = (pr*math.sin(rotangle*math.pi/180))*rs/pc
        ptmx = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc
        ptmy = (pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc
        lenmto3 = math.sqrt(math.pow(pc-rs,2)-math.pow(pc*0.5, 2))
        lenztom = math.sqrt(math.pow(ptmx, 2)+math.pow(ptmy, 2))
        r3 = lenztom + lenmto3
        pt3x = r3*math.cos(0.5*rotangle*math.pi/180)
        pt3y = r3*math.sin(0.5*rotangle*math.pi/180)
        pt4x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(pc-rs)/pc
        pt4y = (pr*math.sin(rotangle*math.pi/180))*(pc-rs)/pc
        pt5x = (pr-rs)*math.cos(rotangle*math.pi/180)
        pt5y = (pr-rs)*math.sin(rotangle*math.pi/180)
        data = ['M', pt1x, pt1y, 'A', rs, rs, 0, 0, 0, pt2x, pt2y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt3x, pt3y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt4x, pt4y, \
        'A', rs, rs, 0, 0, 0, pt5x, pt5y]
        sprocketTooth = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })
        # theta 為 degree
        sprocketTooth.rotate(self.theta) 
        sprocket = sprocketTooth.dup()
        # 利用單齒輪廓旋轉, 產生整個齒盤外形
        for i in range(1, self.n):
            # 將 sprocketTooth 中的資料複製到 newTooth
            newTooth = sprocketTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/self.n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            sprocket.appendPath(newTooth, True) # trim move command = True
        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = cobj(shapedefs.circle(hr), "PATH")
        shaft.revWinding()
        sprocket.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
        sprocket.translate(self.cx, self.cy)
        # render 繪出靜態正齒輪輪廓
        self.cgo.render(sprocket)
        # 接著繪製齒盤的基準線
        deg = math.pi/180
        Line = cobj(['M', self.cx, self.cy, 'L', self.cx+pr*math.cos(self.theta*deg), self.cy+pr*math.sin(self.theta*deg)], "PATH", {
              'strokeColor':'blue', 'lineWidth': 1})
        self.cgo.render(Line)

# 將繪製鏈條輪廓的內容寫成 class 物件
class Chain():
    def __init__(self, canvas_id):
        self.canvas_id = canvas_id
        self.cgo = cango(self.canvas_id)

    def chain(self, x, y, rs, pc, theta, render=True):
        self.x = x
        self.y = y
        self.rs = rs
        self.pc = pc
        self.theta = theta
        self.render = render
        # rs 為 roller rasius
        # pc 為 pitch
        # 以水平作為起始角度, 左邊圓心位於原點, 左右圓半徑為 rs = 7, pc 為 20, 上下圓弧半徑為 20
        cx = 0
        cy = 0
        c2x = cx + self.pc
        c2y = cy
        # upper arc center coord
        ucx = self.pc/2
        ucy = math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # down side arc center coord
        dcx = ucx
        dcy = -math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # 上方左邊切點座標
        pt1x = cx+(ucx-cx)*(self.rs/(self.pc+self.rs))
        pt1y = cy+(ucy-cy)*(self.rs/(self.pc+self.rs)) 
        pt2x = cx+(dcx-cx)*(self.rs/(self.pc+self.rs))
        pt2y = cy+(dcy-cy)*(self.rs/(self.pc+self.rs))
        pt3x = c2x+self.rs*(dcx-c2x)/(self.pc+self.rs)
        pt3y = c2y+self.rs*(dcy-c2y)/(self.pc+self.rs)
        pt4x = c2x+self.rs*(ucx-c2x)/(self.pc+self.rs)
        pt4y = c2y+self.rs*(ucy-c2y)/(self.pc+self.rs)
        
        # 輪廓的外型設為成員變數
        data = ['M', pt1x, pt1y, \
                'A', self.rs, self.rs, 0, 1, 1, pt2x, pt2y, \
                'A', self.pc, self.pc, 0, 0, 0, pt3x, pt3y, \
                'A', self.rs, self.rs, 0, 1, 1, pt4x, pt4y, \
                'A', self.pc, self.pc, 0, 0, 0, pt1x, pt1y, 'z']
    
        chain = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })
        
        hole1 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole1.translate(cx, cy)
        hole1.revWinding()
        chain.appendPath(hole1)
        hole2 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole2.translate(c2x, c2y)
        hole2.revWinding()
        chain.appendPath(hole2)
       # theta is degree
        chain.rotate(self.theta)
        chain.translate(self.x, self.y)
        if self.render == True:
            self.cgo.render(chain)
        deg = math.pi/180
        x2 = cx + self.x+ self.pc*math.cos(self.theta*deg)
        y2 = cy + self.y+ self.pc*math.sin(self.theta*deg)
        return x2, y2

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container1']
# 3個齒輪的齒數
n1 = 18
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear1"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container <= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = mySpur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.sprocket(cx, cy, 7, 20, n1, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.sprocket(cx+pr1+pr2, cy, 7, 20, n2, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.sprocket(cx+pr1+pr2+pr2+pr3, cy, 7, 20, n3, 180-180/n3+(180-180/n2)*n2/n3)

rs = 7
pc = 20
degree = math.pi/180
radian = 180/math.pi
rotangle = 360/n1
r1 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r1*math.sin(rotangle*degree), r1-r1*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx + r1
y1 = cy
for i in range(n1-5):
    if i < 5:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2
    
rotangle = 360/n2
r2 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r2*math.sin(rotangle*degree), r2-r2*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx+pr1+pr2+r2
y1 = cy
for i in range(n2):
    if i > 7 and i < 20:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2
    if i == 7:
        x7, y7 = x2, y2
    if i == 19:
        x20, y20 = x2, y2
    
for i in range(12):
    if i == 11:
        offset = 12
    else:
        offset = 0
    x2, y2 = mychain.chain(x7, y7, rs, pc, inc*radian+rotangle*8-i*1.5+offset)
    x7, y7 = x2, y2
    
for i in range(11):
    if i == 10:
        offset = 2
    else:
        offset = 0
    x2, y2 = mychain.chain(x20, y20, rs, pc, -inc*radian+rotangle*20+20+offset)
    x20, y20 = x2, y2
</script>

上述繪圖的程式碼:

<pre class="brush: python">
&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python"&gt;
import spurmain
from browser import document, html

# 建立新的繪圖方法 sprocket 用
from browser import window
from javascript import JSConstructor
import math
   
cango = JSConstructor(window.Cango)
shapedefs = window.shapeDefs
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

class mySpur(spurmain.Spur):
    # 定義 sprocket
    # rs 為 roller rasius
    # pc 為 pitch
    def sprocket(self, cx, cy, rs, pc, n, theta):
        self.cx = cx
        self.cy = cy
        self.rs = rs
        self.pc = pc
        self.n = n
        self.pa = pa
        self.theta = theta
        rotangle = 360/self.n
        pr = self.pc/2/math.sin((rotangle/2)*math.pi/180)
        pt1x = pr-rs
        pt1y = 0
        pt2x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*rs/pc
        pt2y = (pr*math.sin(rotangle*math.pi/180))*rs/pc
        ptmx = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc
        ptmy = (pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc
        lenmto3 = math.sqrt(math.pow(pc-rs,2)-math.pow(pc*0.5, 2))
        lenztom = math.sqrt(math.pow(ptmx, 2)+math.pow(ptmy, 2))
        r3 = lenztom + lenmto3
        pt3x = r3*math.cos(0.5*rotangle*math.pi/180)
        pt3y = r3*math.sin(0.5*rotangle*math.pi/180)
        pt4x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(pc-rs)/pc
        pt4y = (pr*math.sin(rotangle*math.pi/180))*(pc-rs)/pc
        pt5x = (pr-rs)*math.cos(rotangle*math.pi/180)
        pt5y = (pr-rs)*math.sin(rotangle*math.pi/180)
        data = ['M', pt1x, pt1y, 'A', rs, rs, 0, 0, 0, pt2x, pt2y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt3x, pt3y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt4x, pt4y, \
        'A', rs, rs, 0, 0, 0, pt5x, pt5y]
        sprocketTooth = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })
        # theta 為 degree
        sprocketTooth.rotate(self.theta) 
        sprocket = sprocketTooth.dup()
        # 利用單齒輪廓旋轉, 產生整個齒盤外形
        for i in range(1, self.n):
            # 將 sprocketTooth 中的資料複製到 newTooth
            newTooth = sprocketTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/self.n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            sprocket.appendPath(newTooth, True) # trim move command = True
        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = cobj(shapedefs.circle(hr), "PATH")
        shaft.revWinding()
        sprocket.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
        sprocket.translate(self.cx, self.cy)
        # render 繪出靜態正齒輪輪廓
        self.cgo.render(sprocket)
        # 接著繪製齒盤的基準線
        deg = math.pi/180
        Line = cobj(['M', self.cx, self.cy, 'L', self.cx+pr*math.cos(self.theta*deg), self.cy+pr*math.sin(self.theta*deg)], "PATH", {
              'strokeColor':'blue', 'lineWidth': 1})
        self.cgo.render(Line)

# 將繪製鏈條輪廓的內容寫成 class 物件
class Chain():
    def __init__(self, canvas_id):
        self.canvas_id = canvas_id
        self.cgo = cango(self.canvas_id)

    def chain(self, x, y, rs, pc, theta, render=True):
        self.x = x
        self.y = y
        self.rs = rs
        self.pc = pc
        self.theta = theta
        self.render = render
        # rs 為 roller rasius
        # pc 為 pitch
        # 以水平作為起始角度, 左邊圓心位於原點, 左右圓半徑為 rs = 7, pc 為 20, 上下圓弧半徑為 20
        cx = 0
        cy = 0
        c2x = cx + self.pc
        c2y = cy
        # upper arc center coord
        ucx = self.pc/2
        ucy = math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # down side arc center coord
        dcx = ucx
        dcy = -math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # 上方左邊切點座標
        pt1x = cx+(ucx-cx)*(self.rs/(self.pc+self.rs))
        pt1y = cy+(ucy-cy)*(self.rs/(self.pc+self.rs)) 
        pt2x = cx+(dcx-cx)*(self.rs/(self.pc+self.rs))
        pt2y = cy+(dcy-cy)*(self.rs/(self.pc+self.rs))
        pt3x = c2x+self.rs*(dcx-c2x)/(self.pc+self.rs)
        pt3y = c2y+self.rs*(dcy-c2y)/(self.pc+self.rs)
        pt4x = c2x+self.rs*(ucx-c2x)/(self.pc+self.rs)
        pt4y = c2y+self.rs*(ucy-c2y)/(self.pc+self.rs)
        
        # 輪廓的外型設為成員變數
        data = ['M', pt1x, pt1y, \
                'A', self.rs, self.rs, 0, 1, 1, pt2x, pt2y, \
                'A', self.pc, self.pc, 0, 0, 0, pt3x, pt3y, \
                'A', self.rs, self.rs, 0, 1, 1, pt4x, pt4y, \
                'A', self.pc, self.pc, 0, 0, 0, pt1x, pt1y, 'z']
    
        chain = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })
        
        hole1 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole1.translate(cx, cy)
        hole1.revWinding()
        chain.appendPath(hole1)
        hole2 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole2.translate(c2x, c2y)
        hole2.revWinding()
        chain.appendPath(hole2)
       # theta is degree
        chain.rotate(self.theta)
        chain.translate(self.x, self.y)
        if self.render == True:
            self.cgo.render(chain)
        deg = math.pi/180
        x2 = cx + self.x+ self.pc*math.cos(self.theta*deg)
        y2 = cy + self.y+ self.pc*math.sin(self.theta*deg)
        return x2, y2

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container1']
# 3個齒輪的齒數
n1 = 18
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear1"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = mySpur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.sprocket(cx, cy, 7, 20, n1, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.sprocket(cx+pr1+pr2, cy, 7, 20, n2, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.sprocket(cx+pr1+pr2+pr2+pr3, cy, 7, 20, n3, 180-180/n3+(180-180/n2)*n2/n3)

rs = 7
pc = 20
degree = math.pi/180
radian = 180/math.pi
rotangle = 360/n1
r1 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r1*math.sin(rotangle*degree), r1-r1*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx + r1
y1 = cy
for i in range(n1-5):
    if i &lt; 5:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2
    
rotangle = 360/n2
r2 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r2*math.sin(rotangle*degree), r2-r2*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx+pr1+pr2+r2
y1 = cy
for i in range(n2):
    if i &gt; 7 and i &lt; 20:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2
    if i == 7:
        x7, y7 = x2, y2
    if i == 19:
        x20, y20 = x2, y2
    
for i in range(12):
    if i == 11:
        offset = 12
    else:
        offset = 0
    x2, y2 = mychain.chain(x7, y7, rs, pc, inc*radian+rotangle*8-i*1.5+offset)
    x7, y7 = x2, y2
    
for i in range(11):
    if i == 10:
        offset = 2
    else:
        offset = 0
    x2, y2 = mychain.chain(x20, y20, rs, pc, -inc*radian+rotangle*20+20+offset)
    x20, y20 = x2, y2
&lt;/script&gt;
</pre>

上述鏈輪繪圖中需要計算5個關鍵點, 如下圖所示:

<img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_drawing.png" width="800" />

而此5個座標點將分別決定四段圓弧的繪製, 如下圖所示:

<img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_drawing_2.png" width="800" />

至於將鏈條第1節 (位於每一個鏈輪的水平軸最右側的節圓弧上), 設計者必須根據鏈輪齒數, 決定鏈條的逆時鐘旋轉與水平軸之間的偏角 (因為這裡原始的鏈條採水平方向建置), 而此依偏角可以根據下列示意圖求取.

計算第1節鏈條偏角的參考圖:

<img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_wheel_chain_geometry.png" width="800" />

<img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_wheel_chain_geometry_2.png" width="800" />

<img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_wheel_chain_geometry_3.png" width="800" />

計算鏈條四個關鍵點的參考圖:

<img src="http://chiamingyen.github.io/kmolab_data/files/201605/chain_profile.png" width="800" />

以下則用來說明 3 個齒輪囓合時, 先兩兩依據基本的囓合對應完成囓合後, 再考慮中介齒輪的配合轉動, 就可以逐一完成各式減速齒輪組的 2D 繪圖, 一旦雲端零組件繪圖流程進入 Onshape 3D 零組件設計繪圖, 就可以援用相同的囓合原理, 完成 3D 減速機齒輪箱的組立與模擬:

<div id="container2"></div>

<script type="text/python">
import spurmain
from browser import document, html

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container2']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear2"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container <= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = spurmain.Spur(id)


gear.spur(cx, cy, m, n1, pa, 0)
gear.spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
</script>

<div id="container3"></div>

<script type="text/python">
import spurmain
from browser import document, html

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container3']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear3"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container <= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = spurmain.Spur(id)

gear.spur(cx+pr1+pr2, cy, m, n2, pa, 0)
gear.spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3)
</script>
