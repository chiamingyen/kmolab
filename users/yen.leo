<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20151212173315.1"><vh>@settings</vh>
<v t="leo.20151212173315.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20151212173315.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="amd.20160531150040.1" a="E"><vh>Sprocket 繪圖</vh>
<v t="amd.20160531183958.1"><vh>參考</vh></v>
</v>
<v t="amd.20160106095324.1" a="E"><vh>@path ./../</vh>
<v t="leo.20151213173811.1" a="E"><vh>假如要送到 gh-pages 分支, 使用下列按鈕</vh>
<v t="leo.20151212173658.1"><vh>@button gh-pages pelican</vh></v>
</v>
<v t="leo.20151213173830.1" a="E"><vh>假如要在近端檢視, 使用下列按鈕</vh>
<v t="leo.20151213085727.1"><vh>@button local pelican</vh></v>
</v>
<v t="amd.20160117010542.1"><vh>@button git rm -rf blog</vh></v>
<v t="amd.20151215180106.1"><vh>設定與開發</vh>
<v t="amd.20151216151325.1"><vh>@edit index.html</vh></v>
<v t="amd.20151216152209.1"><vh>@edit README.md</vh></v>
<v t="leo.20151213230723.1" a="E"><vh>Pelican 設定</vh>
<v t="leo.20151213230957.1"><vh>文章 Date 設定</vh></v>
<v t="leo.20151213230729.1"><vh>使用 summary plugin</vh></v>
</v>
<v t="amd.20151215170117.1"><vh>以下 pelicanconf.py 為近端與遠端的共同設定</vh></v>
<v t="leo.20151212173725.1"><vh>@edit pelicanconf.py</vh></v>
<v t="amd.20151215170142.1"><vh>以下 publishconf.py 為遠端所使用的設定</vh></v>
<v t="leo.20151212173803.1"><vh>@edit publishconf.py</vh></v>
<v t="amd.20151215170221.1"><vh>以下 local_publishconf.py 為近端所使用的設定</vh></v>
<v t="leo.20151213085752.1"><vh>@edit local_publishconf.py</vh></v>
<v t="amd.20151215121740.1" a="E"><vh>@path theme</vh>
<v t="amd.20151215121758.1" a="E"><vh>@path pelican-bootstrap3</vh>
<v t="amd.20151215121816.1" a="E"><vh>@path templates</vh>
<v t="amd.20151215121827.1"><vh>@edit base.html</vh></v>
<v t="amd.20151215121849.1"><vh>@edit search.html</vh></v>
<v t="amd.20151215152634.1"><vh>@edit tags.html</vh></v>
</v>
<v t="amd.20151216181314.1" a="E"><vh>@path static</vh>
<v t="amd.20151216181314.2" a="E"><vh>@path css</vh>
<v t="amd.20151216181314.3" a="E"><vh>@path pygments</vh>
<v t="amd.20151216181314.4"><vh>@edit fruity.css</vh></v>
</v>
</v>
</v>
</v>
<v t="amd.20151215154950.1" a="E"><vh>@path pelican-bootstrap3_local</vh>
<v t="amd.20151215154950.2" a="E"><vh>@path templates</vh>
<v t="amd.20151215154950.3"><vh>@edit base.html</vh></v>
<v t="amd.20151215154950.4"><vh>@edit search.html</vh></v>
<v t="amd.20151215162536.1" a="E"><vh>@path includes</vh>
<v t="amd.20151215162510.1"><vh>@edit sidebar.html</vh></v>
</v>
<v t="amd.20151215154950.5"><vh>@edit tags.html</vh></v>
</v>
<v t="amd.20151216173334.1" a="E"><vh>@path static</vh>
<v t="amd.20151216173344.1" a="E"><vh>@path css</vh>
<v t="amd.20151216173352.1" a="E"><vh>@path pygments</vh>
<v t="amd.20151216173409.1"><vh>@edit fruity.css</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="amd.20151215170326.1"><vh>以下在修改或查驗 plugin 目錄下的檔案</vh></v>
<v t="amd.20151215154225.1" a="E"><vh>@path plugin</vh>
<v t="amd.20151215154238.1" a="E"><vh>@path tipue_search</vh>
<v t="amd.20151215154248.1"><vh>@edit tipue_search.py</vh></v>
</v>
</v>
</v>
<v t="amd.20160303212723.1"><vh>2016spring課程</vh>
<v t="amd.20160303212735.1"><vh>2016springcd</vh></v>
<v t="amd.20160303212739.1"><vh>2016springwcm</vh></v>
<v t="amd.20160303213007.1"><vh>cptocadp</vh></v>
<v t="amd.20160303213301.1"><vh>projectmdetw</vh>
<v t="amd.20160303213308.1"><vh>www</vh></v>
<v t="amd.20160303213346.1"><vh>ethercalc</vh></v>
</v>
<v t="amd.20160315212100.1" a="E"><vh>C4F</vh>
<v t="amd.20160315230300.1" a="E"><vh>Arc 參數</vh>
<v t="amd.20160315231631.1"><vh>Elliptical Arcs with SVG</vh></v>
<v t="amd.20160316004643.1"><vh>4個輪廓比較</vh></v>
</v>
<v t="amd.20160315213312.1"><vh>Cango 設定</vh></v>
</v>
</v>
</v>
<v t="amd.20160410195429.1"><vh>blockdiag</vh>
<v t="amd.20160410195429.2"><vh>@button blockdiag</vh></v>
<v t="amd.20160410195429.3"><vh>blockdiag</vh></v>
<v t="amd.20160410195429.4"><vh>@button nwdiag</vh></v>
<v t="amd.20160410195429.5"><vh>nwdiag</vh></v>
</v>
<v t="amd.20160411214944.1"><vh>2016springcd</vh>
<v t="amd.20160411214953.1"><vh>task1</vh></v>
<v t="amd.20160413142752.1"><vh>task1 鏈條繪圖</vh></v>
</v>
<v t="amd.20151215170350.1"><vh>以下為 content 目錄中的 md 檔案</vh></v>
<v t="amd.20160106093610.1"><vh>協同網誌編寫規範</vh></v>
<v t="amd.20151216001126.1"><vh>md 檔案範例</vh></v>
<v t="amd.20151215170031.1" a="E"><vh>@path ./../content</vh>
<v t="amd.20160106093454.1" a="E"><vh>yen 網誌文章</vh>
<v t="amd.20160106093510.1"><vh>201601</vh>
<v t="amd.20160106093531.1" a="E"><vh>w1</vh>
<v t="amd.20160106093542.1"><vh>@edit yen_20160106.md</vh></v>
<v t="amd.20160106113310.1"><vh>@edit yen_20160106-1.md</vh></v>
<v t="amd.20160106113823.1"><vh>@edit yen_20160106-2.md</vh></v>
<v t="amd.20160106114051.1"><vh>@edit yen_20160106-3.md</vh></v>
<v t="amd.20160106114450.1"><vh>@edit yen_20160106-4.md</vh></v>
<v t="amd.20160106114934.1"><vh>@edit yen_20160106-5.md</vh></v>
<v t="amd.20160106115205.1"><vh>@edit yen_20160106-6.md</vh></v>
<v t="amd.20160106214349.1"><vh>@edit yen_20160101-7.md</vh></v>
<v t="amd.20160106233112.1"><vh>@edit yen_20160106-8.md</vh></v>
<v t="amd.20160107094404.1"><vh>@edit yen_20160107.md</vh></v>
<v t="amd.20160110112114.1"><vh>@edit yen_20160110.md</vh></v>
<v t="amd.20160110135811.1"><vh>@edit yen_20160110-1.md</vh></v>
<v t="amd.20160110135831.1"><vh>@edit yen_20150110-2.md</vh></v>
<v t="amd.20160110135845.1"><vh>@edit yen_20160110-3.md</vh></v>
<v t="amd.20160110173241.1"><vh>@edit yen_20160110-4.md</vh></v>
<v t="amd.20160111234254.1"><vh>yen_20160110-5.md (前面沒有 @edit 表示尚未寫完)</vh></v>
</v>
<v t="amd.20160117003659.1"><vh>w2</vh>
<v t="amd.20160117003704.1"><vh>@edit yen_20160117.md</vh></v>
<v t="amd.20160117172615.1"><vh>@edit yen_20160117-1.md</vh></v>
<v t="amd.20160118000852.1"><vh>@edit yen_20160118.md</vh></v>
<v t="amd.20160118121123.1"><vh>@edit yen_20160118-1.md</vh></v>
<v t="amd.20160118162431.1"><vh>@edit yen_20160118-2.md</vh></v>
</v>
<v t="amd.20160123100821.1"><vh>w3</vh>
<v t="amd.20160123100826.1"><vh>@edit yen_20160123.md</vh></v>
<v t="amd.20160125202110.1"><vh>@edit yen_20160125.md</vh></v>
</v>
</v>
<v t="amd.20160213095053.1"><vh>201602</vh>
<v t="amd.20160213095059.1"><vh>w2</vh>
<v t="amd.20160215225005.1"><vh>yen_20160215.md</vh></v>
<v t="amd.20160221123826.1"><vh>@edit yen_20160221.md</vh></v>
<v t="amd.20160221125630.1"><vh>@edit yen_20160221-1.md</vh></v>
<v t="amd.20160221204026.1"><vh>@edit yen_20160221-2.md</vh></v>
<v t="amd.20160223165441.1"><vh>@edit yen_20160223.md</vh></v>
<v t="amd.20160224093221.1"><vh>@edit yen_20160224.md</vh></v>
<v t="amd.20160224124815.1"><vh>@edit yen_20160224-1.md</vh></v>
</v>
</v>
<v t="amd.20160303201215.1"><vh>201603</vh>
<v t="amd.20160303201222.1"><vh>@edit yen_20160303.md</vh></v>
<v t="amd.20160308133314.1"><vh>@edit yen_20160309.md</vh></v>
<v t="amd.20160311160710.1"><vh>@edit yen_20160311.md</vh></v>
<v t="amd.20160312225435.1"><vh>@edit yen_20160312.md</vh></v>
<v t="amd.20160313114257.1"><vh>@edit yen_20160313.md</vh></v>
<v t="amd.20160315113132.1"><vh>@edit yen_20160315.md</vh></v>
<v t="amd.20160315170155.1"><vh>@edit yen_20160315-1.md</vh></v>
<v t="amd.20160316145308.1"><vh>@edit yen_20160316.md</vh></v>
<v t="amd.20160321215635.1"><vh>@edit yen_20160321.md</vh></v>
<v t="amd.20160323170832.1"><vh>@edit yen_20160323.md</vh></v>
<v t="amd.20160328153406.1"><vh>@edit yen_20160328.md</vh></v>
<v t="amd.20160330214447.1"><vh>@edit yen_20160330.md</vh></v>
</v>
<v t="amd.20160411205604.1"><vh>201604</vh>
<v t="amd.20160411205621.1"><vh>@edit yen_20160411.md</vh></v>
<v t="amd.20160413214912.1"><vh>@edit yen_20160413.md</vh></v>
<v t="amd.20160417212507.1"><vh>@edit yen_20160417.md</vh></v>
<v t="amd.20160422215112.1"><vh>@edit yen_20160422.md</vh></v>
<v t="amd.20160430144950.1"><vh>@edit yen_20160430.md</vh></v>
<v t="amd.20160430151915.1"><vh>@edit yen_20160430-1.md</vh></v>
<v t="amd.20160503123538.1"><vh>@edit yen_20160502.md</vh></v>
<v t="amd.20160503211630.1"><vh>@edit yen_20160502-1.md</vh></v>
</v>
<v t="amd.20160510095801.1" a="E"><vh>201605</vh>
<v t="amd.20160510095822.1" a="M"><vh>@edit yen_20160510.md</vh></v>
<v t="amd.20160523233557.1"><vh>@edit yen_20160523.md</vh></v>
<v t="amd.20160528152557.1"><vh>@edit yen_20160528.md</vh></v>
<v t="amd.20160529171317.1"><vh>@@edit yen_20160529.md</vh></v>
<v t="amd.20160531123308.1"><vh>@edit yen_20160531.md</vh></v>
</v>
</v>
</v>
<v t="amd.20160106094754.1"><vh>@path ./../content/pages</vh>
<v t="amd.20160106094829.1" a="E"><vh>yen pages 文章</vh>
<v t="amd.20160106094844.1"><vh>@edit yen_pages_1.md</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="amd.20151215121740.1"></t>
<t tx="amd.20151215121758.1"></t>
<t tx="amd.20151215121816.1"></t>
<t tx="amd.20151215154225.1"></t>
<t tx="amd.20151215154238.1"></t>
<t tx="amd.20151215154950.1"></t>
<t tx="amd.20151215154950.2"></t>
<t tx="amd.20151215162536.1"></t>
<t tx="amd.20151215170031.1"></t>
<t tx="amd.20151215170117.1"></t>
<t tx="amd.20151215170142.1"></t>
<t tx="amd.20151215170221.1"></t>
<t tx="amd.20151215170326.1"></t>
<t tx="amd.20151215170350.1"></t>
<t tx="amd.20151215180106.1"></t>
<t tx="amd.20151216001126.1">@language md
Title: 文章標題
Category: 類別
Tags: 標籤
Author: kmol

這裡放入文章摘要

&lt;!-- PELICAN_END_SUMMARY --&gt;

這裡為文章主要內容

程式碼

&lt;pre class="brush: python;"&gt;
print("hello")
&lt;/pre&gt;</t>
<t tx="amd.20151216173334.1"></t>
<t tx="amd.20151216173344.1"></t>
<t tx="amd.20151216173352.1"></t>
<t tx="amd.20151216181314.1"></t>
<t tx="amd.20151216181314.2"></t>
<t tx="amd.20151216181314.3"></t>
<t tx="amd.20160106093454.1"></t>
<t tx="amd.20160106093510.1"></t>
<t tx="amd.20160106093531.1"></t>
<t tx="amd.20160106093610.1">協同成員的 .leo 檔案

    每一位協同者, 各自可以在 users 目錄下擁有一個 .leo 檔案, 用來維護各自位於 content 目錄下的 .md 檔案,
    
    例如: user yen 的 .leo 檔案位於 users/yen.leo

協同成員的 .md 檔案命名

    由於各成員所編寫的 .md 檔案都位於 content 目錄下, 因此必須在各負責的 .md 檔案名稱冠上用戶名稱,
    
    例如: 由 yen 負責編寫的 .md 檔案, 特別命名為 yen_20160106.md, 若一天有兩篇以上文章, 則取 yen_20160106-1.md
    
    當使用者要利用 pelican 在近端轉換網誌時, 必須使用 local-pelican 按鈕, 若要送到 github pages 網站, 則必須透過 gh-pages-pelican 按鈕轉檔.

pages 文章

    寫在 content/pages 目錄中的 .md 檔案, 將會被轉為網誌 pages 內容

</t>
<t tx="amd.20160106094754.1"></t>
<t tx="amd.20160106094829.1"></t>
<t tx="amd.20160106095324.1"></t>
<t tx="amd.20160111234254.1">@language md
Title: 機械設計工程師的計算機程式
Category: Courses
Tags: 計算機程式
Author: kmol

機械設計工程師的計算機程式

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;https://adriann.github.io/programming_problems.html&gt;

&lt;https://projecteuler.net/&gt;

計算機程式練習題目:

1. 在命令列(或 Leo Editor 或瀏覽器中)利用程式列出特定文字或數字內容. (print() 或 g.es(), Leo Editor global 物件的 echo string 方法)
2. 在命令列(或 Leo Editor 或瀏覽器中)利用程式, 接受使用者的輸入, 然後進行資料處理或數值運算後, 列出相關結果. (數值累加, 單位換算等)
3. 只累加偶數或只累加奇數, 使用者輸入齒數、模數與壓力角, 利用程式在瀏覽器中畫出漸開線正齒輪輪廓. (利用小段直線或 Nurbs 繪圖)
4. 數列與字串資料的應用. (利用姓與名的字串檔案, 以亂數產生虛擬班級的學生學號與姓名名單)
5. 利用現有的虛擬班級名單, 利用亂數進行分組與排電腦教室的座位表, 並在瀏覽器中列出編排結果.

&lt;http://m.cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext&gt;

先列出需求, 想想可行方案, 畫出流程圖, 然後從中找出一條最棒的方法!!

新生剛剛入學, 經常會問, 我為什麼要學計算機程式?

解決問題有一定的時間與成本限制, 因此總想要用最快的方式解決問題

創造一個解題的好方法, 想要不斷套用

What Engineers Do? 工程師在做些什麼事?

Engineering is a profession.

工程是一項職業

Its members work closely with scientists and apply new and old scientific effects to produce products and services that people want. 

工程人員與科學家緊密合作, 應用新舊科學認知來產出人們想要的產品與服務

Engineers do creative work. 

工程師做的是創意的工作

They are skilled in the art of inventing new ways of using the forces of nature to do useful things. 

工程師擅長使用自然力量發明新方法來做有用的事

Scientists strive to understand nature while engineers aim to produce useful products subject to economic and societal constraints.

科學家致力於了解自然, 而工程師則專注在經濟與社會的約束下, 產出有用的產品

Engineers deal with reality and usually have a set of specific problems that must be solved to achieve a goal. 

工程師必須面對現實, 而且經常必須解決一系列的問題後, 才能完成目標.

If a particular problem is unusually difficult, it may have to be solved approximately within the time and cost limitations under which the engineer operates.

假如特定問題非常困難, 也必須要在一定的時間與成本限制下, 完成該盡的任務

Engineering problems usually have more than one solution. 

工程問題經常不只有一個答案

It is the aim of the engineer to obtain the best solution possible with the resources available. 

工程師的任務就式在有限資源下達到最佳方案

A criterion for measuring the degree of success of a solution is usually adopted and an attempt is made to optimize the solution relative to this criterion. 

The engineer rarely achieves the best solution the first time; a design may have to be iterated several times.

Engineers are professionally responsible for the safety and performance of their designs. 

The objective is to solve a given problem with the simplest, safest, most efficient design possible, at the lowest cost.

the major human activities represented as three poles labeled as follows:

Ideas 人類的想法, 用語言文字音樂記載想法, 或用文字來說明人生與宇宙間的道理 (宗教), 形成文學宗教音樂與藝術
  介於想法與自然界之間, 為抽像科學, 人類用自己的想法來解釋大自然的現象與事物, 例如數學
Nature 人所處的自然環境 - 用來說明自然界原本存在的科學 物理化學生物與植物學等
  介於自然與人與事之間, 人類為了解決日常生活的各種問題, 創造了應用科學, 例如工程科學, 醫學等
People and Things 人類與所造之物- 直接用來解決人與事所產生的問題, 交通通訊農業採礦建築製造軍事商業銷售
  介於想法與人與事之間, 人用自己的想法來解決人與事物互動所衍生的問題, 例如社會科學, 心理學, 法律, 經濟學與新聞學等
Ideas


人的想法
自然界
人與事

there are 4 main classes of computation that mechanical engineers are involved in. 

Computer Aided Design (CAD)
Finite Element Analysis
Data Acquisition
Numerical Analysis. 

資料擷取 (DAQ) 即透過電腦而測得物理或電子現象，如電壓、電流、溫度、壓力、聲音。DAQ 系統包含感測器、DAQ 量測硬體、電腦 (具備可程式化軟體)。與傳統量測系統相較，電腦架構的 DAQ 系統可整合工業級電腦的處理效能、產能、顯示、連結功能，提供更高彈性、高成本效益的量測解決方案。

感測器	現象
RTD、熱電偶、熱敏電阻	溫度
光感測器	光線
麥克風	聲音
應變規、壓電傳感器	應力/壓力
LVDT、位移計、光學編碼器	定位與移位
加速規	加速度
酸鹼計	pH

http://www.ni.com/white-paper/13654/zht/

http://www.southampton.ac.uk/~fangohr/training/python/index.html

http://www.southampton.ac.uk/~fangohr/training/python/pdfs/Python-for-Computational-Science-and-Engineering-slides.pdf

myopenlab

http://syzygy.st/Public/linkage/

https://github.com/pydy/pydy

100 題目

https://github.com/zhiwehu/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises.txt

http://www.davesquared.net/2008/03/99-problems-with-python-1-10.html

TSP 基因演算

http://blog.kmol.info/indexb0b7.html?cat=6

以基因演算法處理 TSP (Traveling Salesman Problem) 問題的 Permutation Crossover Operator, TSP 對應到機械工程相關範例為多孔加工的最短切削刀具路徑運算, 也可以用在其他自動控制最短路徑規劃應用, 零件組立流程或工廠配置 (屬於 Operational Research 範疇) 的最佳化設計

工程師天生要來解決問題的, 如何解決問題?先要有一點想像力 (人文本質), 了解一些些所處的環境 (現實與現況), 然後找方法, 一步步解決問題.

他想要打飛靶百發百中, 距離 100 公尺, 步槍射程 350 公尺, 但是目標卻以亂數出現在遠處, 他卻想要百發百中!!
不要忘記, 地球有引力, 空氣有阻力, 而你有牛頓運動定律以及一台連著網路線的電腦!! (而他假如只是一個飛靶場的百來位客戶之一)

你想要開連鎖餐廳, 因為競爭對手可以一分鐘內完成點餐, 而你想要 30 秒內就完成同樣的點餐流程!!

互相認識一下:

請問您是誰?您來自那個高中?住在那裏?

讓您先留個言!

算一下班上有幾位同學?

假如您是超商的收銀機!

紀錄一下每位同學的手機號碼

導師要給班上每位同學寫一封信

能夠為我排個功課表嗎?

派誰當工讀生?

能不能為我畫一張耶誕卡?

如何三不五時寫個家書?

想不想玩線上遊戲?

噪音小效能高的發電扇葉設計 Fan Design, Turbine Design

適合醫生使用操作的醫療器具

大樓空調管線配置設計

各種座椅設計 

設計專案管理

專利工程師

新產品開發過程中的系統模擬與分析

讓電腦程式處理原本必須採手工處理的煩雜流程, 加速工作效率

利用程式與程式設計流程圖進行協同產品設計團隊成員間的有效溝通

電腦能做什麼工作?
 
系統化與結構性的工作

資料搜尋與處理

專案與資料管理

資料輸出

基因演算法 (Genetic Algorithm) 是一種能夠利用電腦程式進行廣域最佳化 (Global Optimization) 參數組合搜尋的運算邏輯方法,主要原理在模仿地球上自然界物種演化 (Species Evolution) 的過程,透過原始物種族群的建立,特定環境因素對於這些物種族群所造成的影響,以優勝劣敗的淘汰機制,決定單一個體是否得以存活至延續下一代,並透過特定 機制將單一個體的基因,以交配重組或突變的模式,將適合環境生存的特定基因對(染色體)加以傳承.

由於基因演算法的理論根據在達爾文的”物 種起源”說,與地球上各物種在”物競天擇” (Ntaural Selection) 與”物種演化”的過程,已經由許多生物學及考古學的研究得到證實,但是目前用於基因演算法上的運算邏輯與自然界生物演化的複雜度,仍不可同日而語.


除 了基因演算法,就演化運算 (Evolutionary Computation) 的方法而言,近年來不斷受到各領域研究者的重視,目前已經發展出”超啟發演算法”(Metaheuristics)的新研究學門,人類在運算學上,憑藉高 速運算能力的不斷提升,以自然為師的最佳化參數組合搜尋,未來在各領域的最佳化設計運算過程中,將會取得更重要的地位.

基因演算法的流程:

1. 決定參數編碼方法

2. 列出評量(適應)方程式

3. 建立初始族群 (決定族群大小,建立初始族群序列)

4. 個體評量過程 (以參數編碼方法,將每一個體,以評量方程式,排出優劣次序)

5. 進行交配 (決定交配個體(父母)選擇方法,基因交配方法,交配時突變方法與機率)

6. 產生下一代物種族群

7. 重複第 4 步驟,直到最佳化參數組合出現,或者達到所設定的最大演化世代數.

基因演算法關鍵:

1. 如何針對設計變數進行編碼,編碼與參數可能範圍值之間的搭配

2. 如何產生電腦程式中”合理”的亂數

3. 交配父代與母代的選擇 (交配方法與交配率的選擇)

4. 交配時基因交換機制,突變率與突變方法的選擇

5. 最大演化運算代數的選擇

6. 適應函數與程式最小誤差值的取捨

基因演算法常用術語:

gene 基因

genome 基因組

genetic 基因的,遺傳的

allele 等位基因

chromosomes 染色體

mutation 突變

mate 交配

crossover 交配

reproduction 生殖,繁殖

recombination 重組

replication 複製

encode 編碼

decode 解碼

evolution 演化

random 隨機

selection 選擇

Roulette 輪盤

adenine 腺嘌呤

cytosine 胞嘧啶

thymine 胸腺嘧啶

guanine 鳥嘌呤

amino acid 氨基酸

deoxyribonucleotide 去氧核糖核酸

deoxyribonucleic acid DNA 去氧核糖核酸

nucleic acid 核酸

proteins 蛋白質

autosome 常染色體

double helix 雙螺旋

enzyme 酶

exogenous 外源性

exons 外顯子

introns 內含子

nucleotides 核苷酸

haploid 單倍體

heterozygosity 雜合度

homologies 同源性

hybridization 雜交

karyotype 核型

polymorphism 多態性

purine 嘌呤

ribonucleic acid RNA 核糖核酸

telomere 端粒

transformation 轉型


</t>
<t tx="amd.20160117003659.1"></t>
<t tx="amd.20160117010542.1">@language python
import os
os.system("git rm -rf blog")
g.es("git rm -rf blog 執行完畢")</t>
<t tx="amd.20160123100821.1"></t>
<t tx="amd.20160213095053.1"></t>
<t tx="amd.20160213095059.1"></t>
<t tx="amd.20160215225005.1">課程中文名稱: 協同產品設計實習

工具介紹

PTC Creo Parametric and Onshape

kmol2016

    Python 3.4
    
    Pelican
    
    Leo Editor 建立產品開發專案
    
    Jupyter
    
    Git
    
    ungit
    
    Cherrypy and Flask
    
    SQLite
    
Bicycle 折疊機構設計

Bicycle 電動系統設計 (Ebike)

Solar Car Design

參考: https://docs.google.com/document/d/1YhsK03sDFf_hAN0Tcm9zwXZ3Rr__PrVaTkEfVLwLiH4/edit?pref=2&amp;pli=1

https://www.launchpadcentral.com/education

https://canvanizer.com/new/business-model-canvas

https://en.wikipedia.org/wiki/Collaborative_product_development

二十一世紀的同步工程:

https://my.pcloud.com/publink/show?code=XZ7dz4ZskySAzc0vUVAUasEKT77pyrGr1Ty

Course Objectives
The course objectives for CSE498 include (but are not limited to) the following.
a. Learning to architect, develop, and deliver a complete software application to a client.
b. Learning to work effectively in a team environment.
c. Developing your written and oral communication skills.
d. Becoming proficient with software development tools and environments.
e. Learning about system building and system administration.
f. Integrating everything you have learned in your other computer science courses.

Course Goals:
Students who take this course will be able to:
• Understand and articulate the key principles of co-design
• Demonstrate knowledge of the history, actors, trends, and critiques of co-design methods
• Apply theoretical and practical tools of co-design in a real-world partnership with a community-based organization
• Effectively use free/libre and open source project management tools to facilitate collaborative work in diverse teams
• Make concrete contributions to the development of a real-world civic media project that is grounded in the needs of a community partner


課程英文名稱: Collaborative Product Design Principles and Practices

課程主要介紹協同產品設計原理與協同產品設計流程的實踐

協同產品設計原理:

1. 產品設計流程中, 牽涉多名相關的成員時, 該如何執行各項設計工作?
2. 以完成產品開發作為共同目標
3. 透過產品生命週期管理機制
4. 成員分別或共同完成產品專案中的分項任務

協同產品設計流程的實踐:

產品開發流程確認
成員角色確認
協同工作模式
產品生命週期管理系統

協同的背景

全球化帶來的密集與瞬息萬變的競爭, 即便是全球各領域目前領先的國際大公司都必須要靠快速併購, 才能具備克敵致勝的專業能力, 因此對於規模較小, 專業能力較不全面的公司與團隊, 為求生存, 必得積極尋求各方協同的機會.

以機械設計流程的角度言, 協同產品設計過程中主要的項目在資訊與知識層次上的協同.

協同的目的在追求速度, 效能, 多元, 互動與彈性

速度 - 推出新產品的速度, 修正既有錯誤的速度

效能 - 強調效率與功能, 持續降低成本

多元 - 多方嘗試, 多方檢視, 多方調控, 多方出擊

互動 - 有推有拉, 有來有往, 密切藕合

彈性 - 及時調整適應, 配合需求能夠加以變化

協同(Collaboration)與合作(Cooperation)有何差異?

協同源自各方公認的共同目標, 而合作則通常指源自個別認知下的不同標的.

協同互動性高於合作
協同的積極與動態性, 高於合作
協同成員間的專業重疊性, 高於合作
協同的價值通常高於合作
就時代發展的潮流而言, 以 Collaboration 模式進行協同合作的公司, 所有成員不僅秉持相同目標, 積極主動, 彼此可互相替代職務, 在永續經營理念下, 不斷創造價值的公司, 將具有相對於採 Cooperation 模式公司較高的國際競爭力.

Collaboration 公司 (若公司文化無法支撐以下條件, 則必須透過系統機制達成):

所有成員在所規劃安排的時間, 盡心盡力完成自我期許的任務, 沒有摸魚與怠忽職守的問題.
所有成員在解決各種問題的流程中, 能不斷自我學習並惕勵自己, 讓公司價值不斷向上攀升.
所有成員都是老闆, 公司的價值得以即時公平落實到所有成員身上.
所有成員在任何時間地點都能上班, 也都能到世界各地去上班, 沒有打卡約束與適應的問題.
公司成員間, 有許多職務都可隨時替代安排, 因此沒有“非我不可”, 加班與爆肝的問題.
協同範例

http://en.flossmanuals.net/_booki/openstreetmap/openstreetmap.pdf
http://www.openstreetmap.org/
協同原理

http://en.wikipedia.org/wiki/General_theory_of_collaboration
http://www.designingcollaboration.com/
控制工廠間的協同
協同的基本元素:

協同的動機 - 為何要協同? 環境使然, 趨勢使然, 或者只是為協同而協同.
協同的分享 - 協同過程中, 如何分享?(功勞記在誰頭上?) 分享甚麼?(要全盤托出嗎?) 何時分享? 跟誰分享?
協同的溝通 - 該與誰溝通? 如何溝通? 溝通甚麼? 何時進行溝通?(隨選或即時或定時溝通)
協同的廣度 - 協同的範圍取捨, 哪些領域與專長的人該進來協同?
協同的效度 - 協同解決了甚麼問題? 解決誰的問題? 解決何時的問題? 問題真的解決了嗎?
協同的支援 - 因協同而得的特殊支援項目, 當天就要塌下來了, 誰該負責?

知識創建

知識分為隱性與顯性, 一般的 know-how 屬於技術性的隱性知識, 另一種隱性知識則稱為認知型隱性知識
認知型的隱性知識則包括團隊間的認知文化, 經驗與潛規則
而顯性知識則泛指書本, 導引手冊, 指南等以文字, 影像, 語音, 圖表及多媒體型式, 清楚表達的資訊內容
通常在新產品開發過程中, 透過團隊間付出與能力上的競爭, 會激化出隱性知識的創建
隱性知識通常透過成員在組織間, 以較長時間浸濡方可傳承, 必須設法轉為顯性知識, 以加快並擴大知識所能產生的效益
協同產品設計公司的挑戰之一則是如何將新產品開發過程中的隱性知識轉化為顯性知識
http://l.kryptoniitti.com/lassial/files/summaries/100120-Nonaka_and_Takeuchi_1995_summary.pdf 
or &lt;http://chiamingyen.github.io/kmolab_data/files/The-Knowledge-Creating-Company-Nonaka.pdf&gt;  (Knowledge creation company)
or &lt;http://chiamingyen.github.io/kmolab_data/files/Nonaka_and_Takeuchi_1995_summary.pdf&gt; (Summary of knowledge creation company)
https://ai.wu.ac.at/~kaiser/birgit/Nonaka-Papers/From-information-processing-to-knowledge-creation-1996.pdf 
or &lt;http://chiamingyen.github.io/kmolab_data/files/From-information-processing-to-knowledge-creation-1996.pdf&gt; (From information processing to knowledge creation)
https://wiki.hi.is/images/0505Nonaka_u_Toyama.pdf 
or &lt;http://chiamingyen.github.io/kmolab_data/files/0505Nonaka_u_Toyama.pdf&gt;  (Knowledge creation revisited)
http://www.markd.nl/content/references/1990Hammer.pdf 
or &lt;http://chiamingyen.github.io/kmolab_data/files/1990Hammer.pdf&gt; (reengineering work)
Volvo 全球協同下的知識管理: &lt;http://chiamingyen.github.io/kmolab_data/files/km_global_team.pdf&gt;
顯性就是已經清楚表達出來的, 隱性就是存在但沒有清楚表達的

書本, 導引手冊是顯性知識, 隱性知識又分兩種, 一種是團隊間大家都知道「一定」要這樣做才可以解決問題的知識, 又稱 know-how

而另外一種隱性知識則是大家「一直」都這樣做的認知, 又稱文化, 習慣或潛規則</t>
<t tx="amd.20160303201215.1"></t>
<t tx="amd.20160303212723.1"></t>
<t tx="amd.20160303212735.1">github: https://github.com/2015fallhw/2016springcd

openshift: 2015fallhw At Gmail</t>
<t tx="amd.20160303212739.1">github: https://github.com/2015fallhw/2016springwcm

openshift: 2015fallhw At Gmail.com</t>
<t tx="amd.20160303213007.1">github: https://github.com/2015fallhw/cptocadp

openshift: 

2015fallhw At gmail

http://cptocadp-2015fallhw.rhcloud.com/</t>
<t tx="amd.20160303213301.1">利用 projectmdetw At Gmail 登記</t>
<t tx="amd.20160303213308.1">http://www-projectmdetw.rhcloud.com/</t>
<t tx="amd.20160303213346.1">http://nodejs-projectmdetw.rhcloud.com/</t>
<t tx="amd.20160315212100.1">@language html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Circle Testing&lt;/title&gt;
    &lt;link rel="stylesheet" href="../css/style.css"&gt;
    &lt;!-- IE 9: display inline SVG --&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=9"&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")


# 設定 SVG 繪圖的格點範圍, 原點位於 (0%, 100%), 也就是原點位於畫布的左上角落點, 而且長與寬的尺寸比例都是 100%
'''
cgo.setGridboxSVG(0, cgo.heightPW, 100, cgo.heightPW);
which sets the grid origin at the UPPER LEFT corner of the canvas and the gridbox width and height equal to the full canvas width and height.
Calling 'cgo.setGridboxSVG()' with no parameters is equivalent to calling
cgo.setGridboxSVG(originX, originY, width_scale, height_scale)
cgo.setGridboxSVG(0, 100, cgo.widthPW, cgo.heightPW)
which sets the grid origin at the UPPER LEFT corner of the canvas and the gridbox width and height equal to the full canvas width and height.
另一 Y 向上為正的設定 cgo.setGridboxRHC()
'''
#cgo.setGridboxSVG(0, 100, 100, 100)
# 當使用者沒有設定 cgo.setGridboxSVG() 或 cgo.setGridboxRHC(), 系統採用內定的 cgo.setGridboxRHC()
# 因為經由 cgo.setGridboxSVG(0, 100, 100, 100) 已經將格點範圍的原點設於畫布的左上角落點
# 以下的絕對座標設定, 即是將此原點標定為繪圖座標的(-200, -200), 而且畫布的有效座標範圍, 寬為 400, 高也是 400
cgo.setWorldCoords(-200, -200, 400, 400) 

# 決定要不要畫座標軸線
'''
cgo.drawAxes(0, 200, 0, 100, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 10,
    "xLabelInterval": 20,
    "yTickInterval": 10,
    "yLabelInterval": 10})
'''
        
#cgo.drawText("使用 Cango 繪圖程式庫!", 0, 0, {"fontSize":60, "fontWeight": 1200, "lorg":5 })

deg = math.pi/180
# 還必須考慮各字元的旋轉中心!!
def Four(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    longchamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -28.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -28.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgolongChamber = window.svgToCgoSVG(longchamber)
    longcmbr = cobj(cgolongChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
            
    mediumchamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -23.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -23.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgomediumChamber = window.svgToCgoSVG(mediumchamber)
    mediumcmbr = cobj(cgomediumChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
            
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    
    basic2 = mediumcmbr.dup()
    basic2.rotate(-90)

    basic3 = longcmbr.dup()
    basic3.rotate(165)
    basic3.translate(-25, 0)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)

def C(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 120 度
    basic1.rotate(120)
    basic2 = cmbr.dup()
    basic2.rotate(60)
    basic2.translate(0, -20)
    
    basic3 = cmbr.dup()
    basic3.rotate(60)
    basic3.translate(20*math.cos(30*deg), 20*math.sin(30*deg))
    
    basic4 = cmbr.dup()
    basic4.rotate(120)
    basic4.translate(20*math.cos(30*deg), -20*math.sin(30*deg)-20)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)
    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def O(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 120 度
    basic1.rotate(120)
    basic2 = cmbr.dup()
    basic2.rotate(60)
    basic2.translate(0, -20)
    
    basic3 = cmbr.dup()
    basic3.rotate(60)
    basic3.translate(20*math.cos(30*deg), 20*math.sin(30*deg))
    
    basic4 = cmbr.dup()
    basic4.rotate(120)
    basic4.translate(20*math.cos(30*deg), -20*math.sin(30*deg)-20)
    
    basic5 = cmbr.dup()
    basic5.translate(2*20*math.cos(30*deg), 0)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)
    cmbr.appendPath(basic5)
    
    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def D(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    basic2 = cmbr.dup()
    
    basic3 = cmbr.dup()
    basic3.rotate(98)
    basic3.translate(0, -20)
    
    basic4 = cmbr.dup()
    basic4.rotate(82)
    basic4.translate(0, 20)
    
    basic5 = cmbr.dup()
    basic5.rotate(-30)
    basic5.translate(20*math.cos(8*deg)+20*math.cos(60*deg), 0)
    
    basic6 = cmbr.dup()
    basic6.rotate(210)
    basic6.translate(20*math.cos(8*deg)+20*math.cos(60*deg), 0)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)
    cmbr.appendPath(basic5)
    cmbr.appendPath(basic6)

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def E(x, y, rx, ry, rot, color, border, linewidth):
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    
    basic2 = cmbr.dup()
    basic2.rotate(90)
    
    basic3 = cmbr.dup()
    basic3.rotate(90)
    basic3.translate(0, -20)
    
    basic4 = cmbr.dup()
    basic4.rotate(90)
    basic4.translate(0, 20)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def F(x, y, rx, ry, rot, color, border, linewidth):
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    
    basic2 = cmbr.dup()
    basic2.rotate(90)
    
    basic3 = cmbr.dup()
    basic3.rotate(90)
    basic3.translate(0, 20)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def T(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    basic2 = cmbr.dup()
    
    basic3 = cmbr.dup()
    # 82 度為 D 的角度, 再加轉 8 度
    basic3.rotate(82-8)
    basic3.translate(0, 20)
    
    basic4 = cmbr.dup()
    # 278 度為 D 的對稱角度, 再加轉 8 度
    basic4.rotate(278+8)
    basic4.translate(0, 20)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)
    
    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def R(x, y, rx, ry, rot, color, border, linewidth):
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
            
    longchamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -28.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -28.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgolongChamber = window.svgToCgoSVG(longchamber)
    longcmbr = cobj(cgolongChamber, "SHAPE", {
            "fillColor": color,
            "border": True,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    
    basic2 = cmbr.dup()
    basic2.rotate(90)
    
    basic3 = cmbr.dup()
    basic3.rotate(90)
    basic3.translate(0, 20)
    
    basic4 = cmbr.dup()
    basic4.rotate(180)
    basic4.translate(20, 0)
    
    basic5 = longcmbr.dup()
    basic5.rotate(45)
    #basic5.translate(20, 0)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)
    cmbr.appendPath(basic5)
        
    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)
    
def U(x, y, rx, ry, rot, color, border, linewidth):
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
            
    longchamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -28.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -28.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgolongChamber = window.svgToCgoSVG(longchamber)
    longcmbr = cobj(cgolongChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
            
    mediumchamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -23.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -23.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgomediumChamber = window.svgToCgoSVG(mediumchamber)
    mediumcmbr = cobj(cgomediumChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })
    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 180 度
    basic1.rotate(180)
    
    basic2 = mediumcmbr.dup()
    basic2.rotate(90)
    basic2.translate(0, -20)

    basic3 = cmbr.dup()
    basic3.translate(25, 0)
    
    basic4 = cmbr.dup()
    basic4.rotate(180)
    basic4.translate(25, 0)
    
    cmbr.appendPath(basic1)
    cmbr.appendPath(basic2)
    cmbr.appendPath(basic3)
    cmbr.appendPath(basic4)
        
    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)
    cgo.render(cmbr, x, y, 1, rot)

# google colors
green = "#3cba54"
yellow = "#f4c20d"
red = "#db3236"
blue = "#4885ed"

'''
C(-170, 0, 0, 0, 0, red, False, 1)
O(-120, 0, 0, 0, 0, yellow, False, 1)
D(-70, -10, 0, 0, 0, green, False, 1)
E(-25, -10, 0, 0, 0, blue, False, 1)
Four(36, -10, 0, 0, 0, red, False, 1)

F(-170, -80, 0, 0, 0, blue, False, 1)
U(-139, -80, 0, 0, 0, red, False, 1)
U(-67, -80, 0, 0, 0, yellow, False, 1)
T(-88, -80, 0, 0, 0, green, False, 1)
R(-21, -80, 0, 0, 0, red, False, 1)
E(16, -80, 0, 0, 0, blue, False, 1)
'''
'''
C(-170, 0, 0, 0, 0, red, True, 1)
O(-120, 0, 0, 0, 0, yellow, True, 1)
D(-70, -10, 0, 0, 0, green, True, 1)
E(-25, -10, 0, 0, 0, blue, True, 1)
Four(36, -10, 0, 0, 0, red, True, 1)

F(-170, -80, 0, 0, 0, blue, True, 1)
U(-139, -80, 0, 0, 0, red, True, 1)
U(-67, -80, 0, 0, 0, yellow, True, 1)
T(-88, -80, 0, 0, 0, green, True, 1)
R(-21, -80, 0, 0, 0, red, True, 1)
E(16, -80, 0, 0, 0, blue, True, 1)
'''
'''
black = "#000000"

C(-170, 0, 0, 0, 0, black, False, 1)
O(-120, 0, 0, 0, 0, black, False, 1)
D(-70, -10, 0, 0, 0, black, False, 1)
E(-25, -10, 0, 0, 0, black, False, 1)
Four(36, -10, 0, 0, 0, black, False, 1)

F(-170, -80, 0, 0, 0, black, False, 1)
U(-139, -80, 0, 0, 0, black, False, 1)
U(-63, -80, 0, 0, 0, black, False, 1)
T(-88, -80, 0, 0, 0, black, False, 1)
R(-21, -80, 0, 0, 0, black, False, 1)
E(16, -80, 0, 0, 0, black, False, 1)
'''
'''
# blue
C(-170, 0, 0, 0, 0, blue, False, 1)
O(-120, 0, 0, 0, 0, blue, False, 1)
D(-70, -10, 0, 0, 0, blue, False, 1)
E(-25, -10, 0, 0, 0, blue, False, 1)
Four(36, -10, 0, 0, 0, blue, False, 1)

F(-170, -80, 0, 0, 0, blue, False, 1)
U(-139, -80, 0, 0, 0, blue, False, 1)
U(-63, -80, 0, 0, 0, blue, False, 1)
T(-88, -80, 0, 0, 0, blue, False, 1)
R(-21, -80, 0, 0, 0, blue, False, 1)
E(16, -80, 0, 0, 0, blue, False, 1)
'''
'''
#red
C(-170, 0, 0, 0, 0, red, False, 1)
O(-120, 0, 0, 0, 0, red, False, 1)
D(-70, -10, 0, 0, 0, red, False, 1)
E(-25, -10, 0, 0, 0, red, False, 1)
Four(36, -10, 0, 0, 0, red, False, 1)

F(-170, -80, 0, 0, 0, red, False, 1)
U(-139, -80, 0, 0, 0, red, False, 1)
U(-63, -80, 0, 0, 0, red, False, 1)
T(-88, -80, 0, 0, 0, red, False, 1)
R(-21, -80, 0, 0, 0, red, False, 1)
E(16, -80, 0, 0, 0, red, False, 1)
'''
'''
#green
C(-170, 0, 0, 0, 0, green, False, 1)
O(-120, 0, 0, 0, 0, green, False, 1)
D(-70, -10, 0, 0, 0, green, False, 1)
E(-25, -10, 0, 0, 0, green, False, 1)
Four(36, -10, 0, 0, 0, green, False, 1)

F(-170, -80, 0, 0, 0, green, False, 1)
U(-139, -80, 0, 0, 0, green, False, 1)
U(-63, -80, 0, 0, 0, green, False, 1)
T(-88, -80, 0, 0, 0, green, False, 1)
R(-21, -80, 0, 0, 0, green, False, 1)
E(16, -80, 0, 0, 0, green, False, 1)
'''
'''
#yellow
C(-170, 0, 0, 0, 0, yellow, False, 1)
O(-120, 0, 0, 0, 0, yellow, False, 1)
D(-70, -10, 0, 0, 0, yellow, False, 1)
E(-25, -10, 0, 0, 0, yellow, False, 1)
Four(36, -10, 0, 0, 0, yellow, False, 1)

F(-170, -80, 0, 0, 0, yellow, False, 1)
U(-139, -80, 0, 0, 0, yellow, False, 1)
U(-63, -80, 0, 0, 0, yellow, False, 1)
T(-88, -80, 0, 0, 0, yellow, False, 1)
R(-21, -80, 0, 0, 0, yellow, False, 1)
E(16, -80, 0, 0, 0, yellow, False, 1)
'''
black = "#000000"
C(-170, 0, 0, 0, 0, black, False, 1)
O(-120, 0, 0, 0, 0, black, False, 1)
D(-70, -10, 0, 0, 0, black, False, 1)
E(-25, -10, 0, 0, 0, black, False, 1)
Four(36, -10, 0, 0, 0, black, False, 1)

F(-170, -80, 0, 0, 0, black, False, 1)
U(-139, -80, 0, 0, 0, black, False, 1)
U(-63, -80, 0, 0, 0, black, False, 1)
T(-88, -80, 0, 0, 0, black, False, 1)
R(-21, -80, 0, 0, 0, black, False, 1)
E(16, -80, 0, 0, 0, black, False, 1)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="amd.20160315213312.1">Calling 'cgo.setGridboxRHC()' with no parameters is equivalent to calling

cgo.setGridboxRHC(0, 0, 100, cgo.heightPW);

which sets the grid origin at the LOWER LEFT corner of the canvas and the gridbox width and height equal to the full canvas width (100) and height (cgo.heightPW).

Calling 'cgo.setGridboxSVG()' with no parameters is equivalent to calling

cgo.setGridboxSVG(0, cgo.heightPW, 100, cgo.heightPW);

which sets the grid origin at the UPPER LEFT corner of the canvas and the gridbox width and height equal to the full canvas width and height.</t>
<t tx="amd.20160315230300.1">chamber = "M(Move to) -6.8397, -1.4894 \
                 A(Arc) 7, 7, 0(x軸轉角為0), 1(取長弧), 0(從起點以右手拇指向下畫弧, 畫向終點), 6.8397, -1.4894
                 A 40, 40, 0(x軸轉角為0), 0(取短弧), 1(從起點以右手拇指向上畫弧, 畫向終點), 6.8397, -18.511 \
                 A 7, 7, 0(x軸轉角為0), 1(取長弧), 0(從起點以右手拇指向下畫弧, 畫向終點), -6.8397, -18.511 \
                 A 40, 40, 0(x軸轉角為0), 0(取短弧), 1(從起點以右手拇指向上畫弧, 畫向終點), -6.8397, -1.4894 z(end)"
                 
https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths

https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/ArcTo.html

SVG

x axis rotation, 0 表示採用逆時鐘旋轉畫弧, 1 表示採順時鐘角度畫弧
large arc flag 0 表示小於 180 的弧, 若為 1, 表示為大於 180 度的弧
sweep flag  0 表示採右手則, 拇指向下畫弧, 若為 1 表示以右手拇指向上畫弧
                 
A

rx, ry,
x-rotation,
large-arc-flag,
sweep-flag,
x, y

從目前所在的點, 畫橢圓到 x, y 點, 其中的 x 方向圓半徑為 rx, y 方向圓半徑為 ry, 

直角座標下:

x-rotation=1 表圓弧以逆時鐘方向延伸, large-arc-flag, sweep-flag=1 也是向逆時鐘方向掃略

SVG 座標下:

x-rotation=1 表圓弧以順時鐘方向延伸, large-arc-flag, sweep-flag=1 也是向順時鐘方向掃略

elliptical arc: 

Draws and arc starting from the current point and ending at (x, y). The ellipse has the two radii (rx, ry). The x-axis of the ellipse is rotated by 'x-axis-rotation' relative to the x-axis of the world coordinate system. 

The 'large-arc-flag' and the 'sweep-flag' together define which way the arc joins to start and end point.

For Cartesian coordinate systems the 'x-axis-rotation' is measured anti-clockwise and 'sweep-flag = 1' may be interpreted as the arc sweeping in an anti-clockwise direction.

For SVG coordinate systems the 'x-axis-rotation' is measured clockwise and 'sweep-flag = 1' flag may be interpreted as the arc sweeping in a clockwise direction.
</t>
<t tx="amd.20160315231631.1">Elliptical Arcs with SVG

http://www.svgbasics.com/arcs.html

An elliptical arc draws an arc from the current point to a specified point. 

The arc command begins with the x and y radius and ends with the ending point of the arc. 

Between these are three other values: 

x axis rotation, 0 表示採用順時鐘旋轉畫弧, 1 表示採逆時鐘角度畫弧
sweep flag  0 表示採負的切線角度畫弧, 若為 1 表示以正的切線角度畫弧
large arc flag 0 表示小於 180 的弧, 若為 1, 表示為大於 180 度的弧


The x axis rotation is used to rotate the ellipse that the arc is created from. 

This rotation maintains the start and end points, whereas a rotation with the transform attribute (outside the path description) would cause the entire path, including the start and end points, to be rotated. 

The large arc flag and sweep flag control which part of the ellipse is used to cut the arc. These are needed because there's more than one way to place an ellipse so that it includes the start and end points.</t>
<t tx="amd.20160316004643.1">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Circle Testing&lt;/title&gt;
    &lt;link rel="stylesheet" href="../css/style.css"&gt;
    &lt;!-- IE 9: display inline SVG --&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=9"&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")


# 設定 SVG 繪圖的格點範圍, 原點位於 (0%, 100%), 也就是原點位於畫布的左上角落點, 而且長與寬的尺寸比例都是 100%
'''
cgo.setGridboxSVG(0, cgo.heightPW, 100, cgo.heightPW);
which sets the grid origin at the UPPER LEFT corner of the canvas and the gridbox width and height equal to the full canvas width and height.
Calling 'cgo.setGridboxSVG()' with no parameters is equivalent to calling
cgo.setGridboxSVG(originX, originY, width_scale, height_scale)
cgo.setGridboxSVG(0, 100, cgo.widthPW, cgo.heightPW)
which sets the grid origin at the UPPER LEFT corner of the canvas and the gridbox width and height equal to the full canvas width and height.
另一 Y 向上為正的設定 cgo.setGridboxRHC()
'''
#cgo.setGridboxSVG(0, 100, 100, 100)
# 當使用者沒有設定 cgo.setGridboxSVG() 或 cgo.setGridboxRHC(), 系統採用內定的 cgo.setGridboxRHC()
# 因為經由 cgo.setGridboxSVG(0, 100, 100, 100) 已經將格點範圍的原點設於畫布的左上角落點
# 以下的絕對座標設定, 即是將此原點標定為繪圖座標的(-200, -200), 而且畫布的有效座標範圍, 寬為 400, 高也是 400
cgo.setWorldCoords(-200, -200, 400, 400) 

# 決定要不要畫座標軸線

cgo.drawAxes(0, 200, 0, 100, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 10,
    "xLabelInterval": 20,
    "yTickInterval": 10,
    "yLabelInterval": 10})

        
#cgo.drawText("使用 Cango 繪圖程式庫!", 0, 0, {"fontSize":60, "fontWeight": 1200, "lorg":5 })

deg = math.pi/180
def chain1(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("1-長向內", x, y-10, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

# 第一個 Arc, 選擇短軸
def chain2(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 0, 0, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("2-短向內", x, y-10, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

def chain3(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 1, 1, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("3-長向外", x, y-30, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

def chain4(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
                     A 7, 7, 0, 0, 1, 6.8397, -1.4894 \
                     A 40, 40, 0, 0, 1, 6.8397, -18.511 \
                     A 7, 7, 0, 1, 0, -6.8397, -18.511 \
                     A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("4-短向外", x, y-30, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

yellow = "#f4c20d"
white = "#ffffff"
chain1(0, 0, 0, 0, 0, white, True, 4)
chain2(35, 0, 0, 0, 0, white, True, 4)
chain3(70, 0, 0, 0, 0, white, True, 4)
chain4(105, 0, 0, 0, 0, white, True, 4)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="amd.20160410195429.1"></t>
<t tx="amd.20160410195429.2">@language python
import os
# 節點的 body 內容設為 content
content = p.b
with open('test.diag', 'w') as f:
    f.write(content)
f.closed
# 存為 svg
#os.system("blockdiag -Tsvg test.diag" )
# 存為 png, 使用 fireflysung.ttf
#os.system("blockdiag -f fireflysung.ttf test.diag" )
os.system("blockdiag test.diag" )
g.es("已經存 test.png 檔案")</t>
<t tx="amd.20160410195429.3">
blockdiag {
    default_shape = roundedbox;
    // 內定寬度為 128
    node_width = 140;
    // 內定高度為 40
    node_height = 50;
    default_fontsize = 15;
    default_node_color = "lightyellow";
    edge_layout = flowchart;
    // 表達方式
    表達 [label = "六種表達方式"];
    1 [label = "口語表達(聲音)"];
    2 [label = "文字表達", color="#99ff33"];
    3 [label = "2D表達(靜態影像)"];
    4 [label = "3D表達(動態影像)"];
    5 [label = "理論表達(定量分析)"];
    6 [label = "實體表達", color="#99ff33"];
    表達 -&gt; 1;
    表達 -&gt; 2;
    表達 -&gt; 3;
    表達 -&gt; 4;
    表達 -&gt; 5;
    表達 -&gt; 6;
    // 學門
    學門 [label = "四種技術領域"];
    學門1 [label = "熱流力學"];
    學門2 [label = "固體力學"];
    學門3 [label = "電機電子"];
    學門4 [label = "資訊通信", color="#99ff33"];
    學門 -&gt; 學門1;
    學門 -&gt; 學門2;
    學門 -&gt; 學門3;
    學門 -&gt; 學門4;
    // 流程
    流程 [label = "四個層面"];
    流程1 [label = "設計", color="#99ff33"];
    流程2 [label = "製造"];
    流程3 [label = "控制"];
    流程4 [label = "管理", color="#99ff33"];
    流程 -&gt; 流程1;
    流程 -&gt; 流程2;
    流程 -&gt; 流程3;
    流程 -&gt; 流程4;
    //專題
    //專題 [label = "機械設計專題", stacked];
    專題 [label = "隨身卡片電腦選購", stacked, color="#ff5050"];
    專題 -&gt; 表達;
    專題 -&gt; 流程;
    專題 -&gt; 學門;
}
</t>
<t tx="amd.20160410195429.4">@language python
import os
# 節點的 body 內容設為 content
content = p.b
with open('test.diag', 'w') as f:
    f.write(content)
f.closed
# 存為 svg
#os.system("nwdiag -Tsvg test.diag" )
# 存為 png, 使用 fireflysung.ttf
#os.system("nwdiag -f fireflysung.ttf test.diag" )
os.system("nwdiag test.diag" )
g.es("已經存 test.png 檔案")</t>
<t tx="amd.20160410195429.5">/*
nwdiag {
  network dmz {
      address = "210.x.x.x/24"

      web01 [address = "210.x.x.1"];
      web02 [address = "210.x.x.2"];
  }
  network internal {
      address = "172.x.x.x/24";

      web01 [address = "172.x.x.1"];
      web02 [address = "172.x.x.2"];
      db01;
      db02;
  }
}
*/

nwdiag {
    default_fontsize = 15;
    校主幹 [shape = cloud];
    校主幹 -- 系路由器;
    
    network 系主幹{
        address = "140.130.17.0/24";
        系路由器 [address="140.130.17.254"];
        雲端點名網路;
        八樓集線器 [address="140.130.17.82"];
        七樓集線器;
        六樓集線器;
        系伺服器群;
    }
    
    network 八樓主幹{
        address="17.10-82"
        八樓集線器 [address="140.130.17.82"];
        老師1伺服器群 [address="140.130.17.10-15"];
        老師2伺服器群 [address="140.130.17.16-25"];
        老師3伺服器群 [address="140.130.17.26-60"];
    }
    
    network CAD_CAE{
        address="17.83";
        八樓集線器 [address="140.130.17.82"];
        CAD_NAT [address="140.130.17.82"];
        CAE_NAT [address="140.130.17.83"];
    }
    
    network 電腦輔助設計室{
        address="192.168.1.0/24";
        CAD_NAT [address="192.168.1.1"];
        CAD1 [address=".2"];
        CAD2;
        CAD64 [address=".100"];
    }
    
    network 電腦輔助繪圖室{
        address="192.168.1.0/24";
        CAE_NAT [address="192.168.1.1"];
        CAE1 [address=".2"];
        CAE2;
        CAE64 [address=".100"];
    }
    
    network 七樓主幹{
        address="140.130.17.83-90"
        七樓集線器;
        老師4伺服器群 [address="140.130.17.61-63"];
        老師5伺服器群 [address="140.130.17.64-70"];
        老師6伺服器群 [address="140.130.17.71-75"];
    }
    
    network 六樓主幹{
        address="140.130.17.91-100"
        六樓集線器;
        老師7伺服器群 [address="140.130.17.76-78"];
        老師8伺服器群 [address="140.130.17.79-80"];
        老師9伺服器群 [address="140.130.17.81-95"];
    }
}</t>
<t tx="amd.20160411205604.1"></t>
<t tx="amd.20160411214944.1"></t>
<t tx="amd.20160411214953.1">from sympy import *
# center ot radius 40
x1 = Symbol('x1')
y1 = Symbol('y1')
# upper tangent point
x2 = Symbol('x2')
y2 = Symbol('y2')
# lower tangent point
x3 = Symbol('x3')
y3 = Symbol('y3')
answer = solve([(x2-0)**2 + (y2-0)**2 - 7*7, (x1-x2)**2+(y1-y2)**2 -40**2, (x1-x3)**2+(y1-y3)**2 -40**2, (x1)**2+(y1)**2 -47**2, \
       (x1)**2+(y1+20)**2 -47**2, x2 -x3], [x1, y1, x2, y2, x3, y3])
group = 1
for i in answer:
    try:
        g.es("group", group, ":")
    except:
        print("group", group, ":")
    for j in i:
        try:
            g.es(j.evalf(5))
        except:
            print(j.evalf(5))
    group += 1</t>
<t tx="amd.20160413142752.1">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;網際 2D 繪圖&lt;/title&gt;
    &lt;!-- IE 9: display inline SVG --&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=9"&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;
 
&lt;/head&gt;
&lt;body&gt;
 
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;
 
&lt;canvas id="plotarea2" width="800" height="800"&gt;&lt;/canvas&gt;
 
&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math
 
cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")
 
cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})
    
deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    
    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })
     
        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        
        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)
     
        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)
        
    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })
     
        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)
        
        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)
     
        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)
        
        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot(0, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1, color="red")

# 畫 B
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, 0, 0, color="red")

# 畫 C
# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0, color="red")


# 畫 D
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+65*3, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -40 度
x6, y6 = mychain.basic_rot(x5, y5, -40)
x7, y7 = mychain.basic_rot(x6, y6, -70)
# 右中垂直向下單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
# -110 度
x9, y9 = mychain.basic_rot(x8, y8, -100)
# -150
x10, y10 = mychain.basic_rot(x9, y9, -150)
# 水平接回原點
mychain.basic(x10, y10, 0+65*3, 0, color="red")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</t>
<t tx="amd.20160510095801.1"></t>
<t tx="amd.20160529171317.1">@language md
Title: 正齒輪零件 FeatureScript 程式碼
Category: Courses
Tags: 2016 Spring, 協同產品設計實習
Author: kmol

&lt;a href="http://chiamingyen.github.io/kmolab_data/files/201605/Appx_involute_Curve_for_CAD.pdf"&gt;Approximation of Involute Curves for CAD-System Processing&lt;/a&gt; 論文中, 討論了如何利用 Bezier curves 來近似繪製齒輪的漸開線.

&lt;!-- PELICAN_END_SUMMARY --&gt;

Context (模型主體)

模型主體是一種內建資料型別, 用於儲存模擬資料, 其中包含物體 (實體, 面, 線與點), 相關組成元件(表面, 邊線與頂點), 變數, 特徵錯誤狀態等

所有的特徵, 操作, 與評量函式都需要在模型主體中操作

每一個 Onshape 零件工房都使用各自的模型主體.

不同的模型主體彼此並無互動, 但是資料可以藉由 opMergeContexts 操作, 從某一模型主體轉換到另一個模型主體.

每一個模型主體會使用建構時的 Onshape 標準程式庫版本, 當某一特徵重建時, 模型主體會回報所用的程式庫版本, 讓各自的特徵與操作回朔該舊版本時該有的運作模式.

Bodies (物體)

模型主體中的幾何形狀是由獨立的物體所組合而成

物體包含零個或多個頂點, 面, 邊界, 用來表示 3D(實體), 2D(片狀體), 1D(線條)或 0D(點) 區域. 例如: 圓柱, 就是一個由 0 個頂點, 兩個邊界線與3個面所組成的實體. 而建構平面則是具有一個面的特殊平面體. 物體的內容始終互相連接, 例如, 兩個沒有交集的空間或曲面無法組成一個單一物體.

物體, 頂點, 邊界線與面集合起來稱為造型元素, 每一個面, 邊界與頂點都屬於物體, 典型的零件工房重建結果, 就是在其模型主體中建立物體.

Queries (查詢)

查詢用來指定模型主體中的拓樸元素 (頂點, 邊界, 面與物體), 可以將查詢看作是一個幾何形狀的訂單, 說明必須符合查詢條件的特定幾何標準 (用法類似 SQL 查詢). 例如, qCreatedBy 就是指定必須在特定操作條件下建構的幾何條件. qContainsPoint 則指定該幾何條件必須與某一點交接. 這些查詢可以包含其他特定的查詢或巢狀查詢, 組成一個更大的查詢.

查詢並不直接參照到幾何元素, 而只解讀所要取得的幾何元素標準. 只有當這些查詢送入諸如評量或操作等相關函數, 並與模型主體互相搭配後, 這些函式就能判定那些元素符合查詢條件 (用法也是類似 SQL 查詢).

通常, 使用的函式可以直接透過評量過程, 取得符合查詢條件的元素. 但是有時則需先取得可能符合查詢條件的元素個數, 然後再逐一透過迴圈進行查詢條件的查找. 這個情況下可以採用 evaluateQuery, 先傳回暫定的元素陣列, 然後在模型主體中的評量階段, 再透過查詢條件查找符合的項目.

Evaluations (評量)

評量函式在模型主體中, 用來量測幾何與拓樸內容. 評量函式以 ev 開頭, 並且需要兩個輸入參數: 模型主體與宣告量測內容的映射資料. 例如, evBox3d 與 evVolume 分別用來取得一組元素的涵蓋範圍與體積, 而 evVertexPoint 則會傳回某一頂點的 3D 位置向量

Operations (操作)

操作是一組用來建立或修改模型主體中幾何形狀的標準程式庫. 操作函式以 op 開頭, 並且需要3個輸入參數: 模型主體, 操作編號, 以及一個定義映射資料. 某項特徵可能也無需任何操作 (例如, assignVariable), 只需要一項操作 (例如, 倒角操作函式稱為 opFillet), 或者需要多項操作 (例如, 擠出 (opExtrude), 拔模 (opDraft), 布林 (opBoolean) 等)

操作將會修改輸入的模型主體, 也就是創建, 刪除或更動其幾何元素. 這些修改在 Onshape 中會分別用獨特的 id 編號加以追蹤.

&lt;a href="http://www.me-bac.com/gear.php?lang=en"&gt;http://www.me-bac.com/gear.php?lang=en&lt;/a&gt;

&lt;pre class="brush: jscript"&gt;
/*    
    Spur Gear
    
    This custom feature creates mathematically correct 
    spur gears with optional center bore hole and keyway.

    Version 1 - May 22, 2016 - Neil Cooke, Onshape Inc.
*/    

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Spur Gear", "Feature Name Template" : "Spur Gear (#teeth teeth)", "Filter Selector" : "fs", "Editing Logic Function" : "editGearLogic" }
export const SpurGear = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // this hidden field is used to name the feature in the "Feature Name Template" 
        // the value for "teeth" is calculated and set in the "Editing Logic Function"
        annotation { "Name" : "teeth", "UIHint" : "ALWAYS_HIDDEN" }
        definition.teeth is string; //used to name the feature only
        // 齒輪齒數
        annotation { "Name" : "Number of teeth" }
        isInteger(definition.numTeeth, TEETH_BOUNDS);
        // 齒輪輸入類別
        annotation { "Name" : "Input type" }
        definition.GearInputType is GearInputType;

        if (definition.GearInputType == GearInputType.module)
        {
            // 齒輪模數
            annotation { "Name" : "Module" }
            isLength(definition.module, MODULE_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.diametralPitch)
        {
            // 徑節
            annotation { "Name" : "Diametral pitch" }
            isReal(definition.diametralPitch, POSITIVE_REAL_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.circularPitch)
        {
            // 周節
            annotation { "Name" : "Circular pitch" }
            isLength(definition.circularPitch, LENGTH_BOUNDS);
        }
        // 節圓直徑
        annotation { "Name" : "Pitch circle diameter" }
        isLength(definition.pitchCircleDiameter, LENGTH_BOUNDS);
        // 壓力角
        annotation { "Name" : "Pressure angle" }
        isAngle(definition.pressureAngle, PRESSURE_ANGLE_BOUNDS);
        // 是否建立中心軸孔
        annotation { "Name" : "Center hole" }
        definition.centerHole is boolean;

        // 若建立中心軸孔變數為 true
        if (definition.centerHole)
        {
            annotation { "Name" : "Hole diameter" }
            isLength(definition.centerHoleDia, CENTERHOLE_BOUNDS);
            // 是否建立鍵槽
            annotation { "Name" : "Keyway" }
            definition.key is boolean;

            if (definition.key)
            {
                annotation { "Name" : "Key width" }
                isLength(definition.keyWidth, KEY_BOUNDS);

                annotation { "Name" : "Key height" }
                isLength(definition.keyHeight, KEY_BOUNDS);
            }
        }
        // 是否指定齒輪圓心
        annotation { "Name" : "Select origin position" }
        definition.centerPoint is boolean;

        // 若要指定圓心位置, 則透過訂詢 (Query) 由使用者指定圓心位置
        if (definition.centerPoint)
        {
            annotation { "Name" : "Sketch vertex for center", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES, "MaxNumberOfPicks" : 1 }
            definition.center is Query;
        }
        // 齒面寬
        annotation { "Name" : "Extrude depth" }
        isLength(definition.gearDepth, BLEND_BOUNDS);
        // 是否反向
        annotation { "Name" : "Extrude direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.flipGear is boolean;
        // 是否偏移
        annotation { "Name" : "Offset" }
        definition.offset is boolean;

        if (definition.offset)
        {
            annotation { "Name" : "Root diameter" }
            isLength(definition.offsetClearance, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Outside diameter" }
            isLength(definition.offsetDiameter, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Tooth angle" }
            isAngle(definition.offsetAngle, ANGLE_360_ZERO_DEFAULT_BOUNDS);
        }
    }
    
    {
        // diameters in gear definition
        var offsetDiameter = 0 * meter;
        var offsetClearance = 0 * meter;
        var offsetAngle = 0 * degree;

        if (definition.offset)
        {
            offsetDiameter = definition.offsetDiameter;
            offsetClearance = definition.offsetClearance;
            offsetAngle = definition.offsetAngle;
        }

        if (definition.centerHole &amp;&amp; definition.centerHoleDia &gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter must be less than the root diameter", ["centerHoleDia"]);
        }
        
        if (definition.key &amp;&amp; definition.keyHeight / 2 + definition.centerHoleDia &gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter plus Key height must be less than the root diameter", ["keyHeight"]);
        }

        const addendum = definition.module + offsetDiameter;
        const dedendum = 1.25 * definition.module + offsetClearance;
        const base = definition.pitchCircleDiameter * cos(definition.pressureAngle);

        // angle between root of teeth
        const alpha = sqrt(definition.pitchCircleDiameter ^ 2 - base ^ 2) / base * radian - definition.pressureAngle;
        const beta = 360 / (4 * definition.numTeeth) * degree - alpha;

        // if no center vertex selected build gear on the front plane at the origin
        var location = vector(0, 0, 0) * meter;
        var sketchPlane = plane(location, vector(0, -1, 0), vector(1, 0, 0));
        var center3D = location;

        // else find location of selected vertex and its sketch plane and create a new sketch for the gear profile
        if (definition.centerPoint)
        {
            location = evaluateQuery(context, definition.center)[0];
            sketchPlane = evOwnerSketchPlane(context, { "entity" : location });
            center3D = evVertexPoint(context, { "vertex" : location });
        }

        const gearSketch = newSketchOnPlane(context, id + "gearSketch", { "sketchPlane" : sketchPlane });
        const center2D = worldToPlane(sketchPlane, center3D);

        // create the outer diameter circle
        // skCircle (sketch is Sketch, circleId is string, value is map) returns map
        skCircle(gearSketch, "addendum", {
                    "center" : center2D,
                    "radius" : definition.pitchCircleDiameter / 2 + addendum
                });

        var nameId = 1;
        var filletEdges = [];
        var regionPoint;

        // build involute splines for each tooth
        // featurescript 迴圈用法與 C 相同
        for (var teeth = 0; teeth &lt; definition.numTeeth; teeth += 1)
        {
            var involute1 = [];
            var involute2 = [];
            var arcDone = false;

            for (var t = 0; t &lt;= 2; t += (1 / 20)) // (1/20) is the involute spline tolerance
            {
                // involute definition math
                var angle = t * radian;
                var offset = ((360 / definition.numTeeth) * PI * teeth) / 180 * radian + beta + offsetAngle;
                var ca = cos(angle + offset);
                var sa = sin(angle + offset);
                var cab = cos(offset - beta * 2 - angle);
                var sab = sin(offset - beta * 2 - angle);
                var point1;
                var point2;
                // 考量齒數大於或等於 52 齒時, 基圓半徑將大於齒根圓, 因此輪廓必須畫到基圓而非齒根圓
                if (base &gt;= definition.pitchCircleDiameter - 2 * dedendum &amp;&amp; t == 0) // special case when base cylinder diameter is greater than dedendum
                {
                    // calculate involute spline point
                    point1 = vector((definition.pitchCircleDiameter / 2 - dedendum) * ca, (definition.pitchCircleDiameter / 2 - dedendum) * sa);
                    point2 = vector((definition.pitchCircleDiameter / 2 - dedendum) * cab, (definition.pitchCircleDiameter / 2 - dedendum) * sab);
                }
                else
                {
                    point1 = vector(base * 0.5 * (ca + t * sa), base * 0.5 * (sa - t * ca));
                    point2 = vector(base * 0.5 * (cab - t * sab), base * 0.5 * (sab + t * cab));
                }

                // and add to array
                involute1 = append(involute1, point1 + center2D);
                involute2 = append(involute2, point2 + center2D);

                if (!arcDone) // create base arc between involutes once per tooth
                {
                    var mid = getArcMidPoint(center2D, point2 + center2D, point1 + center2D); // sketch arc is arc 3 points so need addtional point on arc

                    if (mid != undefined) // if no base cylinder present (due to pressure angle), don't draw it
                    {
                        // skArc (sketch is Sketch, arcId is string, value is map) returns map
                        skArc(gearSketch, "arc" ~ nameId, {
                                    "start" : point2 + center2D,
                                    "mid" : mid,
                                    "end" : point1 + center2D
                                });
                    }

                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point2 + center2D, definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point1 + center2D, definition.gearDepth, definition.flipGear));

                    // find area to extrude
                    regionPoint = vector(point1[0] * 0.95 + center2D[0], point1[1] * 0.95 + center2D[1], 0 * meter);
                    arcDone = true;
                }

                // if involute points go outside the outer diameter of the gear then stop
                if (sqrt(point1[0] ^ 2 + point1[1] ^ 2) &gt;= (definition.pitchCircleDiameter / 2 + addendum))
                    break;
            }

            // create involute sketch splines
            skFitSpline(gearSketch, "spline-a" ~ nameId, {
                        "points" : involute1
                    });
            skFitSpline(gearSketch, "spline-b" ~ nameId, {
                        "points" : involute2
                    });

            // increment name ID to ensure unique IDs for each sketch entity
            nameId += 1;
        }

        if (definition.centerHole)
        {
            if (definition.key)
            {
                var keyVector = vector(0, 1);
                var perpKeyVector = vector(-1, 0);
                var keyHeight = (definition.keyHeight + definition.centerHoleDia) / 2;

                var points = [
                    center2D - (definition.keyWidth / 2) * perpKeyVector,
                    center2D - (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector];

                for (var i = 0; i &lt; size(points); i += 1)
                {
                    skLineSegment(gearSketch, "line" ~ nameId,
                            { "start" : points[i],
                                "end" : points[(i + 1) % size(points)]
                            });
                    nameId += 1;
                }
            }

            // center hole circle sketch
            skCircle(gearSketch, "Center", {
                        "center" : center2D,
                        "radius" : definition.centerHoleDia / 2
                    });
        }
        skSolve(gearSketch);

        extrude(context, id + "extrude1", {
                    "entities" : qContainsPoint(qCreatedBy(id + "gearSketch", EntityType.FACE), toWorld(planeToCSys(sketchPlane), regionPoint)),
                    "endBound" : BoundingType.BLIND,
                    "depth" : definition.gearDepth,
                    "oppositeDirection" : definition.flipGear
                });

        var filletEdges3D = [];

        for (var i = 0; i &lt; size(filletEdges); i += 1)
        {
            // Find the edges that intersect the points previously collected
            filletEdges3D = append(filletEdges3D, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.EDGE), filletEdges[i]));
        }

        const filletRadius = norm(filletEdges[1] - filletEdges[0]) / 3; // arbitrary fillet size = one third the distance between the edges

        if (filletRadius &gt;= 0.2 * millimeter) // arbitrary small size assuming tooling cannot hold a fillet radius smaller than this
        {
            try(opFillet(context, id + "fillet1", {
                            "entities" : qUnion(filletEdges3D),
                            "radius" : filletRadius
                        }));
        }

        // Remove sketch entities - no longer required
        opDeleteBodies(context, id + "delete", { "entities" : qCreatedBy(id + "gearSketch") });

        // created PCD sketch
        const PCDSketch = newSketchOnPlane(context, id + "PCDsketch", { "sketchPlane" : sketchPlane });
        skCircle(PCDSketch, "PCD", {
                    "center" : center2D,
                    "radius" : definition.pitchCircleDiameter / 2,
                    "construction" : true
                });
        skSolve(PCDSketch);

    }, {});

function getArcMidPoint(center is Vector, start is Vector, end is Vector)
{
    // need to convert 2D vectors back to 3D for vector angle calculation
    const center3D = vector(center[0], center[1], 0 * meter);
    const start3D = vector(start[0], start[1], 0 * meter);
    const end3D = vector(end[0], end[1], 0 * meter);

    const angle = vectorAngle(center3D - start3D, center3D - end3D) / 2;
    // if angle is less than zero then arc was flipped
    if (angle &lt;= 0 * radian)
        return;
    start = center - start;

    var ca = cos(angle); // in radians
    var sa = sin(angle);
    return center - vector(ca * start[0] - sa * start[1], sa * start[0] + ca * start[1]);
}

function vectorAngle(vector1 is Vector, vector2 is Vector)
{
    // function assumes vectors are on a 2D plane so Z is always zero and the normal vector is always [0, 0, 1]
    return atan2(dot(vector(0, 0, 1), cross(vector1, vector2)), dot(vector1, vector2));
}

function toWorldVector(csys is CoordSystem, point is Vector, depth is map, direction is boolean) returns Vector
{
    var dir = direction ? -1 : 1;
    var vector3D = vector(point[0], point[1], dir * depth / 2);
    return toWorld(csys, vector3D);
}

export function editGearLogic(context is Context, id is Id, oldDefinition is map, definition is map, isCreating is boolean, specifiedParameters is map, hiddenBodies is Query) returns map
{
    // isCreating is required in the function definition for edit logic to work when editing an existing feature
    if (oldDefinition.numTeeth != definition.numTeeth)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = definition.module * PI;
        definition.diametralPitch = 1 * inch / definition.module;
        definition.teeth = toString(definition.numTeeth); //to name the feature
        return definition;
    }
    
    if (oldDefinition.circularPitch != definition.circularPitch)
    {
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }
    
    if (oldDefinition.pitchCircleDiameter != definition.pitchCircleDiameter)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = (PI * definition.pitchCircleDiameter) / definition.numTeeth;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }
    
    if (oldDefinition.module != definition.module)
    {
        definition.circularPitch = definition.module * PI;
        definition.pitchCircleDiameter = definition.numTeeth * definition.module;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }
    
    if (oldDefinition.diametralPitch != definition.diametralPitch)
    {
        definition.circularPitch = PI / (definition.diametralPitch / inch);
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        return definition;
    }

    return definition;
}

const TEETH_BOUNDS =
{
            "min" : 4,
            "max" : 250,
            (unitless) : [4, 25, 250]
        } as IntegerBoundSpec;

const PRESSURE_ANGLE_BOUNDS =
{
            "min" : 12 * degree,
            "max" : 35 * degree,
            (degree) : [12, 20, 35]
        } as AngleBoundSpec;

const MODULE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CENTERHOLE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.01, 500],
            (centimeter) : 1.0,
            (millimeter) : 10.0,
            (inch) : 0.375
        } as LengthBoundSpec;

const KEY_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.125
        } as LengthBoundSpec;

export enum GearInputType
{
    annotation { "Name" : "Module" }
    module,
    annotation { "Name" : "Diametral pitch" }
    diametralPitch,
    annotation { "Name" : "Circular pitch" }
    circularPitch
}
&lt;/pre&gt;

利用 FreeCAD 建立 spur gear: &lt;a href="https://bitbucket.org/douardda/fcgear"&gt;https://bitbucket.org/douardda/fcgear&lt;/a&gt;

&lt;pre class="brush: python"&gt;
# (c) 2014 David Douard &lt;david.douard@gmail.com&gt;
# Based on https://github.com/attoparsec/inkscape-extensions.git
# Based on gearUtils-03.js by Dr A.R.Collins
#          http://www.arc.id.au/gearDrawing.html
#
# Calculation of Bezier coefficients for
# Higuchi et al. approximation to an involute.
# ref: YNU Digital Eng Lab Memorandum 05-1
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU Lesser General Public License (LGPL)
#   as published by the Free Software Foundation; either version 2 of
#   the License, or (at your option) any later version.
#   for detail see the LICENCE text file.
#
#   FCGear is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Library General Public License for more details.
#
#   You should have received a copy of the GNU Library General Public
#   License along with FCGear; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307

from math import cos, sin, pi, acos, asin, atan, sqrt

def CreateExternalGear(w, m, Z, phi, split=True):
    """
    Create an external gear

    w is wirebuilder object (in which the gear will be constructed)

    if split is True, each profile of a teeth will consist in 2 Bezier
    curves of degree 3, otherwise it will be made of one Bezier curve
    of degree 4
    """
    # ****** external gear specifications
    addendum = m              # distance from pitch circle to tip circle
    dedendum = 1.25 * m         # pitch circle to root, sets clearance
    clearance = dedendum - addendum

    # Calculate radii
    Rpitch = Z * m / 2            # pitch circle radius
    Rb = Rpitch*cos(phi * pi / 180)  # base circle radius
    Ra = Rpitch + addendum    # tip (addendum) circle radius
    Rroot = Rpitch - dedendum # root circle radius
    fRad = 1.5 * clearance # fillet radius, max 1.5*clearance
    Rf = sqrt((Rroot + fRad)**2 - fRad**2) # radius at top of fillet
    if (Rb &lt; Rf):
        Rf = Rroot + clearance

    # ****** calculate angles (all in radians)
    pitchAngle = 2 * pi / Z  # angle subtended by whole tooth (rads)
    baseToPitchAngle = genInvolutePolar(Rb, Rpitch)
    pitchToFilletAngle = baseToPitchAngle  # profile starts at base circle
    if (Rf &gt; Rb):         # start profile at top of fillet (if its greater)
        pitchToFilletAngle -= genInvolutePolar(Rb, Rf)

    filletAngle = atan(fRad / (fRad + Rroot))  # radians

    # ****** generate Higuchi involute approximation
    fe = 1       # fraction of profile length at end of approx
    fs = 0.01    # fraction of length offset from base to avoid singularity
    if (Rf &gt; Rb):
        fs = (Rf**2 - Rb**2) / (Ra**2 - Rb**2)  # offset start to top of fillet

    if split:
        # approximate in 2 sections, split 25% along the involute
        fm = fs + (fe - fs) / 4   # fraction of length at junction (25% along profile)
        dedInv = BezCoeffs(m, Z, phi, 3, fs, fm)
        addInv = BezCoeffs(m, Z, phi, 3, fm, fe)

        # join the 2 sets of coeffs (skip duplicate mid point)
        inv = dedInv + addInv[1:]
    else:
        inv = BezCoeffs(m, Z, phi, 4, fs, fe)

    # create the back profile of tooth (mirror image)
    invR = []
    for i, pt in enumerate(inv):
        # rotate all points to put pitch point at y = 0
        ptx, pty = inv[i] = rotate(pt, -baseToPitchAngle - pitchAngle / 4)
        # generate the back of tooth profile nodes, mirror coords in X axis
        invR.append((ptx, -pty))

    # ****** calculate section junction points R=back of tooth, Next=front of next tooth)
    fillet = toCartesian(Rf, -pitchAngle / 4 - pitchToFilletAngle) # top of fillet
    filletR = [fillet[0], -fillet[1]]   # flip to make same point on back of tooth
    rootR = toCartesian(Rroot, pitchAngle / 4 + pitchToFilletAngle + filletAngle)
    rootNext = toCartesian(Rroot, 3 * pitchAngle / 4 - pitchToFilletAngle - filletAngle)
    filletNext = rotate(fillet, pitchAngle)  # top of fillet, front of next tooth

    # Build the shapes using FreeCAD.Part
    t_inc = 2.0 * pi / float(Z)
    thetas = [(x * t_inc) for x in range(Z)]

    w.move(fillet) # start at top of fillet

    for theta in thetas:
        w.theta = theta
        if (Rf &lt; Rb):
            w.line(inv[0]) # line from fillet up to base circle

        if split:
            w.curve(inv[1], inv[2], inv[3])
            w.curve(inv[4], inv[5], inv[6])
            w.arc(invR[6], Ra, 1) # arc across addendum circle
            w.curve(invR[5], invR[4], invR[3])
            w.curve(invR[2], invR[1], invR[0])
        else:
            w.curve(*inv[1:])
            w.arc(invR[-1], Ra, 1) # arc across addendum circle
            w.curve(*invR[-2::-1])

        if (Rf &lt; Rb):
            w.line(filletR) # line down to topof fillet

        if (rootNext[1] &gt; rootR[1]):    # is there a section of root circle between fillets?
            w.arc(rootR, fRad, 0) # back fillet
            w.arc(rootNext, Rroot, 1) # root circle arc

        w.arc(filletNext, fRad, 0)

    w.close()
    return w



def genInvolutePolar(Rb, R):
    """returns the involute angle as function of radius R.
    Rb = base circle radius
    """
    return (sqrt(R*R - Rb*Rb) / Rb) - acos(Rb / R)


def rotate(pt, rads):
    "rotate pt by rads radians about origin"
    sinA = sin(rads)
    cosA = cos(rads)
    return (pt[0] * cosA - pt[1] * sinA,
            pt[0] * sinA + pt[1] * cosA)



def toCartesian(radius, angle):
    "convert polar coords to cartesian"
    return [radius * cos(angle), radius * sin(angle)]


def chebyExpnCoeffs(j, func):
    N = 50      # a suitably large number  N&gt;&gt;p
    c = 0
    for k in xrange(1, N + 1):
        c += func(cos(pi * (k - 0.5) / N)) * cos(pi * j * (k - 0.5) / N)
    return 2 *c / N


def chebyPolyCoeffs(p, func):
    coeffs = [0]*(p+1)
    fnCoeff = []
    T = [coeffs[:] for i in range(p+1)]
    T[0][0] = 1
    T[1][1] = 1
    # now generate the Chebyshev polynomial coefficient using
    # formula T(k+1) = 2xT(k) - T(k-1) which yields
    # T = [ [ 1,  0,  0,  0,  0,  0],    # T0(x) =  +1
    #       [ 0,  1,  0,  0,  0,  0],    # T1(x) =   0  +x
    #       [-1,  0,  2,  0,  0,  0],    # T2(x) =  -1  0  +2xx
    #       [ 0, -3,  0,  4,  0,  0],    # T3(x) =   0 -3x    0   +4xxx
    #       [ 1,  0, -8,  0,  8,  0],    # T4(x) =  +1  0  -8xx       0  +8xxxx
    #       [ 0,  5,  0,-20,  0, 16],    # T5(x) =   0  5x    0  -20xxx       0  +16xxxxx
    #     ...                     ]

    for k in xrange(1, p):
        for j in xrange(len(T[k]) - 1):
            T[k + 1][j + 1] = 2 * T[k][j]
        for j in xrange(len(T[k - 1])):
            T[k + 1][j] -= T[k - 1][j]

    # convert the chebyshev function series into a simple polynomial
    # and collect like terms, out T polynomial coefficients
    for k in xrange(p + 1):
        fnCoeff.append(chebyExpnCoeffs(k, func))

    for k in xrange(p + 1):
        for pwr in xrange(p + 1):
            coeffs[pwr] += fnCoeff[k] * T[k][pwr]

    coeffs[0] -= fnCoeff[0] / 2  # fix the 0th coeff
    return coeffs


def binom(n, k):
    coeff = 1
    for i in xrange(n - k + 1, n + 1):
        coeff *= i

    for i in xrange(1, k + 1):
        coeff /= i

    return coeff


def bezCoeff(i, p, polyCoeffs):
    '''generate the polynomial coeffs in one go'''
    return sum(binom(i, j) * polyCoeffs[j] / binom(p, j) for j in range(i+1))


    # Parameters:
    # module - sets the size of teeth (see gear design texts)
    # numTeeth - number of teeth on the gear
    # pressure angle - angle in degrees, usually 14.5 or 20
    # order - the order of the Bezier curve to be fitted [3, 4, 5, ..]
    # fstart - fraction of distance along tooth profile to start
    # fstop - fraction of distance along profile to stop
def BezCoeffs(module, numTeeth, pressureAngle, order, fstart, fstop):
    Rpitch = module * numTeeth / 2       # pitch circle radius
    phi = pressureAngle        # pressure angle
    Rb = Rpitch * cos(phi * pi / 180) # base circle radius
    Ra = Rpitch + module               # addendum radius (outer radius)
    ta = sqrt(Ra * Ra - Rb * Rb) / Rb   # involute angle at addendum
    te = sqrt(fstop) * ta          # involute angle, theta, at end of approx
    ts = sqrt(fstart) * ta         # involute angle, theta, at start of approx
    p = order                     # order of Bezier approximation

    def involuteXbez(t):
        "Equation of involute using the Bezier parameter t as variable"
        # map t (0 &lt;= t &lt;= 1) onto x (where -1 &lt;= x &lt;= 1)
        x = t * 2 - 1
        # map theta (where ts &lt;= theta &lt;= te) from x (-1 &lt;=x &lt;= 1)
        theta = x * (te - ts) / 2 + (ts + te) / 2
        return Rb * (cos(theta) + theta * sin(theta))

    def involuteYbez(t):
        "Equation of involute using the Bezier parameter t as variable"
        # map t (0 &lt;= t &lt;= 1) onto x (where -1 &lt;= x &lt;= 1)
        x = t * 2 - 1
        # map theta (where ts &lt;= theta &lt;= te) from x (-1 &lt;=x &lt;= 1)
        theta = x * (te - ts) / 2 + (ts + te) / 2
        return Rb * (sin(theta) - theta * cos(theta))

    # calc Bezier coeffs
    bzCoeffs = []
    polyCoeffsX = chebyPolyCoeffs(p, involuteXbez)
    polyCoeffsY = chebyPolyCoeffs(p, involuteYbez)
    for i in xrange(p + 1):
        bx = bezCoeff(i, p, polyCoeffsX)
        by = bezCoeff(i, p, polyCoeffsY)
        bzCoeffs.append((bx, by))
    return bzCoeffs
&lt;/pre&gt;

&lt;pre class="brush: python"&gt;
# (c) 2014 David Douard &lt;david.douard@gmail.com&gt;
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU Lesser General Public License (LGPL)
#   as published by the Free Software Foundation; either version 2 of
#   the License, or (at your option) any later version.
#   for detail see the LICENCE text file.
#
#   FCGear is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Library General Public License for more details.
#
#   You should have received a copy of the GNU Library General Public
#   License along with FCGear; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307

import itertools
from math import cos, sin
from involute import CreateExternalGear, rotate

def makeGear(m, Z, angle):
    w = SVGWireBuilder()
    CreateExternalGear(w, m, Z, angle)
    return '\n'.join(w.svg)

class SVGWireBuilder(object):
    def __init__(self):
        self.theta = 0.0
        self.pos = None
        self.svg = []

    def move(self, p):
        p = rotate(p, self.theta)
        self.svg.append('M %s,%s' % (p[0], p[1]))
        self.pos = p

    def line(self, p):
        p = rotate(p, self.theta)
        self.svg.append('L %s,%s' % (p[0], p[1]))
        self.pos = p

    def arc(self, p, r, sweep):
        p = rotate(p, self.theta)
        self.svg.append('A %s,%s 0,0,%s %s,%s' % (r, r, str(sweep), p[0], p[1]))
        self.pos = p

    def curve(self, *points):
        """Add a Bezier curve from self.pos to points[-1]
        every other points are the control points of the Bezier curve (which
        will thus be of degree len(points) )
        """
        assert len(points) == 3
        points = [rotate(p, self.theta) for p in points]
        self.svg.append('C %s,%s %s,%s %s,%s' % tuple(itertools.chain(*points)))
        self.pos = points[-1]

    def close(self):
        self.svg.append('Z')

if __name__ == '__main__':
    from optparse import OptionParser
    p = OptionParser()
    p.add_option('-a', '--angle', help='pressure angle',
                 dest='angle', default=20)
    opts, args = p.parse_args()
    if len(args) != 2:
        p.error()
    m, Z = [float(v) for v in args]
    print makeGear(m, int(Z), float(opts.angle))
&lt;/pre&gt;

FreeCAD spur gear:

&lt;pre class="brush: python"&gt;
# (c) 2014 David Douard &lt;david.douard@gmail.com&gt;
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU Lesser General Public License (LGPL)
#   as published by the Free Software Foundation; either version 2 of
#   the License, or (at your option) any later version.
#   for detail see the LICENCE text file.
#
#   FCGear is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Library General Public License for more details.
#
#   You should have received a copy of the GNU Library General Public
#   License along with FCGear; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307

from math import cos, sin, pi, acos, asin, atan, sqrt

import FreeCAD, FreeCADGui, Part
from FreeCAD import Base, Console
import involute
reload(involute)
rotate = involute.rotate


def makeGear(m, Z, angle, split=True):
    if FreeCAD.ActiveDocument is None:
        FreeCAD.newDocument("Gear")
    doc = FreeCAD.ActiveDocument
    w = FCWireBuilder()
    involute.CreateExternalGear(w, m, Z, angle, split)
    gearw = Part.Wire([o.toShape() for o in w.wire])
    gear = doc.addObject("Part::Feature", "Gear")
    gear.Shape = gearw
    return gear


class FCWireBuilder(object):
    """A helper class to prepare a Part.Wire object"""
    def __init__(self):
        self.pos = None
        self.theta = 0.0
        self.wire = []

    def move(self, p):
        """set current position"""
        self.pos = Base.Vector(*p)

    def line(self, p):
        """Add a segment between self.pos and p"""
        p = rotate(p, self.theta)
        end = Base.Vector(*p)
        self.wire.append(Part.Line(self.pos, end))
        self.pos = end

    def arc(self, p, r, sweep):
        """"Add an arc from self.pos to p which radius is r
        sweep (0 or 1) determine the orientation of the arc
        """
        p = rotate(p, self.theta)
        end = Base.Vector(*p)
        mid = Base.Vector(*(midpoints(p, self.pos, r)[sweep]))
        self.wire.append(Part.Arc(self.pos, mid, end))
        self.pos = end

    def curve(self, *points):
        """Add a Bezier curve from self.pos to points[-1]
        every other points are the control points of the Bezier curve (which
        will thus be of degree len(points) )
        """
        points = [Base.Vector(*rotate(p, self.theta)) for p in points]
        bz = Part.BezierCurve()
        bz.setPoles([self.pos] + points)
        self.wire.append(bz)
        self.pos = points[-1]

    def close(self):
        pass

def midpoints(p1, p2, r):
    """A very ugly function that returns the midpoint of a p1 and p2
    on the circle which radius is r and which pass throught p1 and
    p2

    Return the 2 possible solutions
    """
    vx, vy = p2[0]-p1[0], p2[1]-p1[1]
    b = (vx**2 + vy**2)**.5
    v = (vx/b, vy/b)
    cosA = b**2 / (2*b*r)
    A = acos(cosA)

    vx, vy = rotate(v, A)
    c1 = (p1[0]+r*vx, p1[1]+r*vy)
    m1x, m1y = ((p1[0]+p2[0])/2 - c1[0], (p1[1]+p2[1])/2 - c1[1])
    dm1 = (m1x**2+m1y**2)**.5
    m1x, m1y = (c1[0] + r*m1x/dm1, c1[1] + r*m1y/dm1)
    m1 = (m1x, m1y)

    vx, vy = rotate(v, -A)
    c2 = (p1[0]+r*vx, p1[1]+r*vy)
    m2x, m2y = ((p1[0]+p2[0])/2 - c2[0], (p1[1]+p2[1])/2 - c2[1])
    dm2 = (m2x**2+m2y**2)**.5
    m2x, m2y = (c2[0] + r*m2x/dm2, c2[1] + r*m2y/dm2)
    m2 = (m2x, m2y)

    return m1, m2
&lt;/pre&gt;</t>
<t tx="amd.20160531150040.1">roller radius = 7 mm

rs = 7

pitch of chain 

pc = 20 mm

chamber = "M -6.8397, -1.4894 \
        A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
        A 40, 40, 0, 0, 1, 6.8397, -18.511 \
        A 7, 7, 0, 1, 0, -6.8397, -18.511 \
        A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
        
sprocket 的單齒輪廓使用4個圓弧近似繪圖:

sprocket 半徑設為 pr
sprocket 齒數為 n
angle for each tooth = 360/n
degree = math.pi/180

rs = 7
pc = 20
pr = pc/2/math.sin(360*degree/n/2)

假設 sprocket 圓心座標為 xc, yc

假設小圓 (roller) 圓心位於心位於 (xc+pr, yc)

則另外一個 roller 圓心 (xc+pc*math.cos(360*degree/n), yc+pc*math.sin(360*degree/n))

</t>
<t tx="amd.20160531183958.1">    # 必須求出5點個圓弧的關鍵座標, 然後畫出4個圓弧作為一齒, 旋轉複製後, 即可得到 sprocket 零件外形
    # roller1 圓心點座標 (pr, 0), roller2 圓心點座標 ((pr*math.cos(rotangle*math.pi/180), pr*math.sin(rotangle*math.pi/180))
    # 第1點: (pr-rs, 0), 第五點則以 pr-rs 為半徑旋轉 rotangle 
    (((pr-rs)*math.cos(rotangle*math.pi/180), (pr-rs)*math.sin(rotangle*math.pi/180))
    # 第2與第4點則介於兩 roller 圓心點的連線上, 且分別位於 roller 半徑 rs 比例與 pc-rs 比例上
    第2點: (pr-(pr-pr*math.cos(rotangle*math.pi/180))*rs/pc, (pr*math.sin(rotangle*math.pi/180))*rs/pc)
    中線點座標 ((pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc, (pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc)
    中線點到第 3 點距離 math.sqrt(math.pow(pc-rs,2)-math.pow(pc*0.5, 2))
    原點到第3點的距離: math.sqrt(math.pow((pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc, 2)+math.pow((pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc, 2))
    r3 = math.sqrt(math.pow((pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc, 2)+math.pow((pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc, 2))
    第3點的座標就是 r3 旋轉 0.5*rotangle 角度
    第4點:(pr-(pr-pr*math.cos(rotangle*math.pi/180))*(pc-rs)/pc, (pr*math.sin(rotangle*math.pi/180))*(pc-rs)/pc)
    第5點: (((pr-rs)*math.cos(rotangle*math.pi/180), (pr-rs)*math.sin(rotangle*math.pi/180))
    
    
    
            # circle 作圖,必須給 diameter
        roller1 = cobj(shapedefs.circle(self.rs*2), "PATH")
        roller1.translate(pr, 0)
        roller2 = cobj(shapedefs.circle(self.rs*2), "PATH")
        roller2.translate(pr*math.cos(rotangle*math.pi/180), pr*math.sin(rotangle*math.pi/180))
        circle1 = cobj(shapedefs.circle((self.pc-self.rs)*2), "PATH")
        circle1.translate(pr*math.cos(rotangle*math.pi/180), pr*math.sin(rotangle*math.pi/180))
        circle2 = cobj(shapedefs.circle((self.pc-self.rs)*2), "PATH")
        circle2.translate(pr, 0)
        tooth = roller1.dup()
        tooth.appendPath(roller2)
        tooth.appendPath(circle1)
        tooth.appendPath(circle2)</t>
<t tx="leo.20151212173315.1"></t>
<t tx="leo.20151212173315.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20151212173315.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20151212173658.1">@language python
import os
#os.system("pelican content -o ./ -s publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s publishconf.py")
g.es("admin pelican 執行完畢")

</t>
<t tx="leo.20151213085727.1">@language python
import os
#os.system("pelican content -o output -s local_publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="leo.20151213173811.1"></t>
<t tx="leo.20151213173830.1"></t>
<t tx="leo.20151213230723.1"></t>
<t tx="leo.20151213230729.1">利用

&lt;!-- PELICAN_END_SUMMARY --&gt;

來界定 Summary 摘要內容

前提, 必須設定 

PLUGIN_PATHS = ['plugin']

與

PLUGINS = ['liquid_tags.notebook', 'summary']

並且從 https://github.com/getpelican/pelican-plugins

取得 summary plugin</t>
<t tx="leo.20151213230957.1"># 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定

DEFAULT_DATE = 'fs'</t>
</tnodes>
</leo_file>
