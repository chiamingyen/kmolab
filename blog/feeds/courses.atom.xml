<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Kmolab (虎尾科大MDE)</title><link href="./" rel="alternate"></link><link href="./feeds/courses.atom.xml" rel="self"></link><id>./</id><updated>2016-06-01T17:16:15+08:00</updated><entry><title>網際 3D 正齒輪傳動模擬 (一)</title><link href="./wang-ji-3d-zheng-chi-lun-chuan-dong-mo-ni-yi.html" rel="alternate"></link><updated>2016-06-01T17:16:15+08:00</updated><author><name>kmol</name></author><id>tag:,2016-06-01:./wang-ji-3d-zheng-chi-lun-chuan-dong-mo-ni-yi.html</id><summary type="html">&lt;p&gt;Onshape 的正齒輪設計繪圖與組立, 其基本原理與先前的 2D 網際繪圖類似, 只不過在以下的 3D 正齒輪傳動組立過程, 只有 Spur Gear 功能採用 Featurescript 編寫, 雖然在 Onshape Part Studio 中, 所有的零件可以透過統一的設計變數進行控管, 但若一旦設計流程的變化超出原先 Featurescript 的表單設定範圍 (例如: SG Featurescript 中的 Offset angle 只允許 0-360 的正值角度輸入), 設計者就必須介入調整不符合表單設計的 error.&lt;/p&gt;


&lt;p&gt;因此, 以正齒輪減速機的協同設計為例, 可以了解全面透過程式流程掌握機械設計流程的重要性, 目前在無法利用 Onshape API 進行較完整的協同產品設計架構下, 只能利用部份的網際 2D 繪圖模組進行配置, 並將 3D 零組件的定製與組裝模擬, 透過客製化的網際程式 (Python+Brython+Javascript+Jupyter) 轉為 Onshape 的 Featurescript 程式.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/574b8f57e4b04aa3f56f9441/w/d4cf9fa83a3269b42c39edd5/e/7cea03a6cc37cca3cc64e5de"&gt;https://cad.onshape.com/documents/574b8f57e4b04aa3f56f9441/w/d4cf9fa83a3269b42c39edd5/e/7cea03a6cc37cca3cc64e5de&lt;/a&gt; 是一個利用 SG 正齒輪繪圖模組建立的 4 個齒輪傳動組立檔.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;範例中的所有零件都在同一個 Part Studio 中, 以共用設計變數的方式建立.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;例如, 其中的齒輪一齒數以 #n1 變數設定.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;各齒輪的 Offset 轉角, 也配合組立時的座標軸與齒輪起始標定線 (在 Featurescript 中設為 x 軸, 且對準齒根中線), 採用設計變數設定.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;各齒輪組立時 x 軸的指向, 決定後續 Offset 角度設定與囓合配置的運算, 其囓合原理與 2D 齒輪繪圖相同.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下為其他各齒輪組立時 x 軸的定位方向 (紅色軸).&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_5.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_6.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201606/onshape_four_spur_gears_7.png" width="800" /&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>網際 2D 正齒輪協同繪圖規劃</title><link href="./wang-ji-2d-zheng-chi-lun-xie-tong-hui-tu-gui-hua.html" rel="alternate"></link><updated>2016-06-01T10:32:55+08:00</updated><author><name>kmol</name></author><id>tag:,2016-06-01:./wang-ji-2d-zheng-chi-lun-xie-tong-hui-tu-gui-hua.html</id><summary type="html">&lt;p&gt;利用 Python 物件導向架構執行網際 2D 正齒輪傳動協同繪圖時, 各組員可以將各種不同繪圖元件, 建置在個人的網頁空間中, 讓其他參與協同的組員連結應用. 唯一必須注意的是, 就網際繪圖模式而言, 儘管 Brython 繪圖最終仍轉為 JavaScript, 以 Canvas 或 WebGL 完成繪圖, 但是 Python 程式碼在各自的 script 標註中屬於各自的命名空間 (此點與 Prototype based 的 JavaScript 有很大的差別), 因此以下的範例, 必須將各自在引用的 script 標註中, 以 id 命名, 然後根據 id 名稱, 在其他命名空間中以 import 引用.&lt;/p&gt;


&lt;p&gt;以下為 17 齒, 29 齒與 15 齒輪組的囓合繪圖, 其中的漸開線正齒輪 2D 繪圖程式庫以類別建立, 並且存在 &lt;a href="http://cadlab.mde.tw/post/by/spur.js"&gt;http://cadlab.mde.tw/post/by/spur.js&lt;/a&gt;, 之所以採用 .js 命名, 主要在避開修改瀏覽器中的 MIME 對應, 可以直接在隨後的 Brython 程式中, 以 import 方式引用:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;div id="container"&gt;&lt;/div&gt;

&lt;script type="text/python" src="http://cadlab.mde.tw/post/by/spur.js" id="spurmain"&gt;&lt;/script&gt;

&lt;script type="text/python"&gt;
import spurmain
from browser import document, html
# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# 這裡的齒輪繪圖以所導入的 spurmain 模組中的 Spur 類別建立對應的 gear 變數, 且宣告畫布 id
gear = spurmain.Spur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.spur(cx, cy, m, n1, pa, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3+(180-180/n2)*n2/n3)
&lt;/script&gt;

&lt;p&gt;上述繪圖的程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;div id="container"&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;script type="text/python" src="http://cadlab.mde.tw/post/by/spur.js" id="spurmain"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
import spurmain
from browser import document, html
# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &amp;lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# 這裡的齒輪繪圖以所導入的 spurmain 模組中的 Spur 類別建立對應的 gear 變數, 且宣告畫布 id
gear = spurmain.Spur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.spur(cx, cy, m, n1, pa, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3+(180-180/n2)*n2/n3)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;上面的 2D 齒輪繪圖, 雖然引用雲端上的繪圖程式庫, 可以統一控管各程式庫的版本, 但是若不同程式庫間的主機無法連結, 或者當程式庫更新後, 先前所採用的舊繪圖函式可能無法相容或無法完成繪圖, 因此在雲端建置電腦輔助機械設計架構時, 必須採用類似 Onshape 的作法, 雖然所有的程式庫統一更新, 但是各種零組件在建立時, 透過當時所使用的模型主體 (Context), 儲存了所使用的標準零件庫版本, 除非使用者刻意更新, 否則所有的雲端設計專案都將在各自原先的版本命名空間中獨立運作, 不會產生版本分歧或謬誤的問題.&lt;/p&gt;
&lt;p&gt;以下則利用 Python 的物件導向, 另外建立一個畫布繪圖, 其中除了使用 Brython 程式方法, 即時建立 CANVAS 畫布外, 也同時採用物件繼承的方式, 引用遠端的 spur.js 繪圖程式庫, 並且加入鏈條與鏈輪的繪圖元件:&lt;/p&gt;
&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python"&gt;
import spurmain
from browser import document, html

# 建立新的繪圖方法 sprocket 用
from browser import window
from javascript import JSConstructor
import math

cango = JSConstructor(window.Cango)
shapedefs = window.shapeDefs
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

class mySpur(spurmain.Spur):
    # 定義 sprocket
    # rs 為 roller rasius
    # pc 為 pitch
    def sprocket(self, cx, cy, rs, pc, n, theta):
        self.cx = cx
        self.cy = cy
        self.rs = rs
        self.pc = pc
        self.n = n
        self.pa = pa
        self.theta = theta
        rotangle = 360/self.n
        pr = self.pc/2/math.sin((rotangle/2)*math.pi/180)
        pt1x = pr-rs
        pt1y = 0
        pt2x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*rs/pc
        pt2y = (pr*math.sin(rotangle*math.pi/180))*rs/pc
        ptmx = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc
        ptmy = (pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc
        lenmto3 = math.sqrt(math.pow(pc-rs,2)-math.pow(pc*0.5, 2))
        lenztom = math.sqrt(math.pow(ptmx, 2)+math.pow(ptmy, 2))
        r3 = lenztom + lenmto3
        pt3x = r3*math.cos(0.5*rotangle*math.pi/180)
        pt3y = r3*math.sin(0.5*rotangle*math.pi/180)
        pt4x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(pc-rs)/pc
        pt4y = (pr*math.sin(rotangle*math.pi/180))*(pc-rs)/pc
        pt5x = (pr-rs)*math.cos(rotangle*math.pi/180)
        pt5y = (pr-rs)*math.sin(rotangle*math.pi/180)
        data = ['M', pt1x, pt1y, 'A', rs, rs, 0, 0, 0, pt2x, pt2y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt3x, pt3y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt4x, pt4y, \
        'A', rs, rs, 0, 0, 0, pt5x, pt5y]
        sprocketTooth = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })
        # theta 為 degree
        sprocketTooth.rotate(self.theta) 
        sprocket = sprocketTooth.dup()
        # 利用單齒輪廓旋轉, 產生整個齒盤外形
        for i in range(1, self.n):
            # 將 sprocketTooth 中的資料複製到 newTooth
            newTooth = sprocketTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/self.n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            sprocket.appendPath(newTooth, True) # trim move command = True
        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = cobj(shapedefs.circle(hr), "PATH")
        shaft.revWinding()
        sprocket.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
        sprocket.translate(self.cx, self.cy)
        # render 繪出靜態正齒輪輪廓
        self.cgo.render(sprocket)
        # 接著繪製齒盤的基準線
        deg = math.pi/180
        Line = cobj(['M', self.cx, self.cy, 'L', self.cx+pr*math.cos(self.theta*deg), self.cy+pr*math.sin(self.theta*deg)], "PATH", {
              'strokeColor':'blue', 'lineWidth': 1})
        self.cgo.render(Line)

# 將繪製鏈條輪廓的內容寫成 class 物件
class Chain():
    def __init__(self, canvas_id):
        self.canvas_id = canvas_id
        self.cgo = cango(self.canvas_id)

    def chain(self, x, y, rs, pc, theta, render=True):
        self.x = x
        self.y = y
        self.rs = rs
        self.pc = pc
        self.theta = theta
        self.render = render
        # rs 為 roller rasius
        # pc 為 pitch
        # 以水平作為起始角度, 左邊圓心位於原點, 左右圓半徑為 rs = 7, pc 為 20, 上下圓弧半徑為 20
        cx = 0
        cy = 0
        c2x = cx + self.pc
        c2y = cy
        # upper arc center coord
        ucx = self.pc/2
        ucy = math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # down side arc center coord
        dcx = ucx
        dcy = -math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # 上方左邊切點座標
        pt1x = cx+(ucx-cx)*(self.rs/(self.pc+self.rs))
        pt1y = cy+(ucy-cy)*(self.rs/(self.pc+self.rs)) 
        pt2x = cx+(dcx-cx)*(self.rs/(self.pc+self.rs))
        pt2y = cy+(dcy-cy)*(self.rs/(self.pc+self.rs))
        pt3x = c2x+self.rs*(dcx-c2x)/(self.pc+self.rs)
        pt3y = c2y+self.rs*(dcy-c2y)/(self.pc+self.rs)
        pt4x = c2x+self.rs*(ucx-c2x)/(self.pc+self.rs)
        pt4y = c2y+self.rs*(ucy-c2y)/(self.pc+self.rs)

        # 輪廓的外型設為成員變數
        data = ['M', pt1x, pt1y, \
                'A', self.rs, self.rs, 0, 1, 1, pt2x, pt2y, \
                'A', self.pc, self.pc, 0, 0, 0, pt3x, pt3y, \
                'A', self.rs, self.rs, 0, 1, 1, pt4x, pt4y, \
                'A', self.pc, self.pc, 0, 0, 0, pt1x, pt1y, 'z']

        chain = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })

        hole1 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole1.translate(cx, cy)
        hole1.revWinding()
        chain.appendPath(hole1)
        hole2 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole2.translate(c2x, c2y)
        hole2.revWinding()
        chain.appendPath(hole2)
       # theta is degree
        chain.rotate(self.theta)
        chain.translate(self.x, self.y)
        if self.render == True:
            self.cgo.render(chain)
        deg = math.pi/180
        x2 = cx + self.x+ self.pc*math.cos(self.theta*deg)
        y2 = cy + self.y+ self.pc*math.sin(self.theta*deg)
        return x2, y2

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container1']
# 3個齒輪的齒數
n1 = 18
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear1"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = mySpur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.sprocket(cx, cy, 7, 20, n1, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.sprocket(cx+pr1+pr2, cy, 7, 20, n2, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.sprocket(cx+pr1+pr2+pr2+pr3, cy, 7, 20, n3, 180-180/n3+(180-180/n2)*n2/n3)

rs = 7
pc = 20
degree = math.pi/180
radian = 180/math.pi
rotangle = 360/n1
r1 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r1*math.sin(rotangle*degree), r1-r1*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx + r1
y1 = cy
for i in range(n1-5):
    if i &lt; 5:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2

rotangle = 360/n2
r2 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r2*math.sin(rotangle*degree), r2-r2*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx+pr1+pr2+r2
y1 = cy
for i in range(n2):
    if i &gt; 7 and i &lt; 20:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2
    if i == 7:
        x7, y7 = x2, y2
    if i == 19:
        x20, y20 = x2, y2

for i in range(12):
    if i == 11:
        offset = 12
    else:
        offset = 0
    x2, y2 = mychain.chain(x7, y7, rs, pc, inc*radian+rotangle*8-i*1.5+offset)
    x7, y7 = x2, y2

for i in range(11):
    if i == 10:
        offset = 2
    else:
        offset = 0
    x2, y2 = mychain.chain(x20, y20, rs, pc, -inc*radian+rotangle*20+20+offset)
    x20, y20 = x2, y2
&lt;/script&gt;

&lt;p&gt;上述繪圖的程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;div id="container1"&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
import spurmain
from browser import document, html

# 建立新的繪圖方法 sprocket 用
from browser import window
from javascript import JSConstructor
import math

cango = JSConstructor(window.Cango)
shapedefs = window.shapeDefs
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

class mySpur(spurmain.Spur):
    # 定義 sprocket
    # rs 為 roller rasius
    # pc 為 pitch
    def sprocket(self, cx, cy, rs, pc, n, theta):
        self.cx = cx
        self.cy = cy
        self.rs = rs
        self.pc = pc
        self.n = n
        self.pa = pa
        self.theta = theta
        rotangle = 360/self.n
        pr = self.pc/2/math.sin((rotangle/2)*math.pi/180)
        pt1x = pr-rs
        pt1y = 0
        pt2x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*rs/pc
        pt2y = (pr*math.sin(rotangle*math.pi/180))*rs/pc
        ptmx = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(0.5*pc)/pc
        ptmy = (pr*math.sin(rotangle*math.pi/180))*(0.5*pc)/pc
        lenmto3 = math.sqrt(math.pow(pc-rs,2)-math.pow(pc*0.5, 2))
        lenztom = math.sqrt(math.pow(ptmx, 2)+math.pow(ptmy, 2))
        r3 = lenztom + lenmto3
        pt3x = r3*math.cos(0.5*rotangle*math.pi/180)
        pt3y = r3*math.sin(0.5*rotangle*math.pi/180)
        pt4x = pr-(pr-pr*math.cos(rotangle*math.pi/180))*(pc-rs)/pc
        pt4y = (pr*math.sin(rotangle*math.pi/180))*(pc-rs)/pc
        pt5x = (pr-rs)*math.cos(rotangle*math.pi/180)
        pt5y = (pr-rs)*math.sin(rotangle*math.pi/180)
        data = ['M', pt1x, pt1y, 'A', rs, rs, 0, 0, 0, pt2x, pt2y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt3x, pt3y, \
        'A', pc-rs, pc-rs, 0, 0, 1, pt4x, pt4y, \
        'A', rs, rs, 0, 0, 0, pt5x, pt5y]
        sprocketTooth = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })
        # theta 為 degree
        sprocketTooth.rotate(self.theta) 
        sprocket = sprocketTooth.dup()
        # 利用單齒輪廓旋轉, 產生整個齒盤外形
        for i in range(1, self.n):
            # 將 sprocketTooth 中的資料複製到 newTooth
            newTooth = sprocketTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/self.n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            sprocket.appendPath(newTooth, True) # trim move command = True
        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = cobj(shapedefs.circle(hr), "PATH")
        shaft.revWinding()
        sprocket.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
        sprocket.translate(self.cx, self.cy)
        # render 繪出靜態正齒輪輪廓
        self.cgo.render(sprocket)
        # 接著繪製齒盤的基準線
        deg = math.pi/180
        Line = cobj(['M', self.cx, self.cy, 'L', self.cx+pr*math.cos(self.theta*deg), self.cy+pr*math.sin(self.theta*deg)], "PATH", {
              'strokeColor':'blue', 'lineWidth': 1})
        self.cgo.render(Line)

# 將繪製鏈條輪廓的內容寫成 class 物件
class Chain():
    def __init__(self, canvas_id):
        self.canvas_id = canvas_id
        self.cgo = cango(self.canvas_id)

    def chain(self, x, y, rs, pc, theta, render=True):
        self.x = x
        self.y = y
        self.rs = rs
        self.pc = pc
        self.theta = theta
        self.render = render
        # rs 為 roller rasius
        # pc 為 pitch
        # 以水平作為起始角度, 左邊圓心位於原點, 左右圓半徑為 rs = 7, pc 為 20, 上下圓弧半徑為 20
        cx = 0
        cy = 0
        c2x = cx + self.pc
        c2y = cy
        # upper arc center coord
        ucx = self.pc/2
        ucy = math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # down side arc center coord
        dcx = ucx
        dcy = -math.sqrt(math.pow(self.rs+self.pc, 2)-math.pow(0.5*self.pc, 2))
        # 上方左邊切點座標
        pt1x = cx+(ucx-cx)*(self.rs/(self.pc+self.rs))
        pt1y = cy+(ucy-cy)*(self.rs/(self.pc+self.rs)) 
        pt2x = cx+(dcx-cx)*(self.rs/(self.pc+self.rs))
        pt2y = cy+(dcy-cy)*(self.rs/(self.pc+self.rs))
        pt3x = c2x+self.rs*(dcx-c2x)/(self.pc+self.rs)
        pt3y = c2y+self.rs*(dcy-c2y)/(self.pc+self.rs)
        pt4x = c2x+self.rs*(ucx-c2x)/(self.pc+self.rs)
        pt4y = c2y+self.rs*(ucy-c2y)/(self.pc+self.rs)

        # 輪廓的外型設為成員變數
        data = ['M', pt1x, pt1y, \
                'A', self.rs, self.rs, 0, 1, 1, pt2x, pt2y, \
                'A', self.pc, self.pc, 0, 0, 0, pt3x, pt3y, \
                'A', self.rs, self.rs, 0, 1, 1, pt4x, pt4y, \
                'A', self.pc, self.pc, 0, 0, 0, pt1x, pt1y, 'z']

        chain = cobj(data, "SHAPE", {
                "fillColor":"#ddd0dd",
                "border": True,
                "strokeColor": "#606060" })

        hole1 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole1.translate(cx, cy)
        hole1.revWinding()
        chain.appendPath(hole1)
        hole2 = cobj(shapedefs.circle(self.rs/1.5), "PATH")
        hole2.translate(c2x, c2y)
        hole2.revWinding()
        chain.appendPath(hole2)
       # theta is degree
        chain.rotate(self.theta)
        chain.translate(self.x, self.y)
        if self.render == True:
            self.cgo.render(chain)
        deg = math.pi/180
        x2 = cx + self.x+ self.pc*math.cos(self.theta*deg)
        y2 = cy + self.y+ self.pc*math.sin(self.theta*deg)
        return x2, y2

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container1']
# 3個齒輪的齒數
n1 = 18
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear1"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &amp;lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = mySpur(id)

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
gear.sprocket(cx, cy, 7, 20, n1, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
gear.sprocket(cx+pr1+pr2, cy, 7, 20, n2, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
gear.sprocket(cx+pr1+pr2+pr2+pr3, cy, 7, 20, n3, 180-180/n3+(180-180/n2)*n2/n3)

rs = 7
pc = 20
degree = math.pi/180
radian = 180/math.pi
rotangle = 360/n1
r1 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r1*math.sin(rotangle*degree), r1-r1*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx + r1
y1 = cy
for i in range(n1-5):
    if i &amp;lt; 5:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2

rotangle = 360/n2
r2 = pc/2/math.sin((rotangle/2)*math.pi/180)
inc = math.pi - math.atan2(r2*math.sin(rotangle*degree), r2-r2*math.cos(rotangle*degree))
mychain = Chain(id)
x1 = cx+pr1+pr2+r2
y1 = cy
for i in range(n2):
    if i &amp;gt; 7 and i &amp;lt; 20:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i, False)
    else:
        x2, y2 = mychain.chain(x1, y1, rs, pc, inc*radian+rotangle*i)
    x1, y1 = x2, y2
    if i == 7:
        x7, y7 = x2, y2
    if i == 19:
        x20, y20 = x2, y2

for i in range(12):
    if i == 11:
        offset = 12
    else:
        offset = 0
    x2, y2 = mychain.chain(x7, y7, rs, pc, inc*radian+rotangle*8-i*1.5+offset)
    x7, y7 = x2, y2

for i in range(11):
    if i == 10:
        offset = 2
    else:
        offset = 0
    x2, y2 = mychain.chain(x20, y20, rs, pc, -inc*radian+rotangle*20+20+offset)
    x20, y20 = x2, y2
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;上述鏈輪繪圖中需要計算5個關鍵點, 如下圖所示:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_drawing.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;而此5個座標點將分別決定四段圓弧的繪製, 如下圖所示:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_drawing_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;至於將鏈條第1節 (位於每一個鏈輪的水平軸最右側的節圓弧上), 設計者必須根據鏈輪齒數, 決定鏈條的逆時鐘旋轉與水平軸之間的偏角 (因為這裡原始的鏈條採水平方向建置), 而此依偏角可以根據下列示意圖求取.&lt;/p&gt;
&lt;p&gt;計算第1節鏈條偏角的參考圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_wheel_chain_geometry.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_wheel_chain_geometry_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201605/sprocket_wheel_chain_geometry_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;計算鏈條四個關鍵點的參考圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/201605/chain_profile.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下則用來說明 3 個齒輪囓合時, 先兩兩依據基本的囓合對應完成囓合後, 再考慮中介齒輪的配合轉動, 就可以逐一完成各式減速齒輪組的 2D 繪圖, 一旦雲端零組件繪圖流程進入 Onshape 3D 零組件設計繪圖, 就可以援用相同的囓合原理, 完成 3D 減速機齒輪箱的組立與模擬:&lt;/p&gt;
&lt;div id="container2"&gt;&lt;/div&gt;

&lt;script type="text/python"&gt;
import spurmain
from browser import document, html

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container2']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear2"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = spurmain.Spur(id)


gear.spur(cx, cy, m, n1, pa, 0)
gear.spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
&lt;/script&gt;

&lt;div id="container3"&gt;&lt;/div&gt;

&lt;script type="text/python"&gt;
import spurmain
from browser import document, html

# 利用 Brython 的 document 建立一個 id 為 container 的 div 區域, 然後在其中放入對應的 html 標註
container = document['container3']
# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15
# 根據繪圖的 3 個齒輪大小計算所需的畫布高度
height = 1.2*800*0.8/(int(n1)+int(n2)+int(n3))*max([int(n1), int(n2), int(n3)])
# 決定畫布的 id 字串
id = "gear3"
# 利用 Brython 的 html 方法建立 CANVAS
canvas = html.CANVAS(id=id, width=800, height=height)

# 將所建立的 canvas 畫布標註放入 container
container &lt;= canvas

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# mySpur 已經新建一個 sprocket 繪圖方法
gear = spurmain.Spur(id)

gear.spur(cx+pr1+pr2, cy, m, n2, pa, 0)
gear.spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3)
&lt;/script&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>網際 3D 正齒輪傳動模擬</title><link href="./wang-ji-3d-zheng-chi-lun-chuan-dong-mo-ni.html" rel="alternate"></link><updated>2016-05-28T16:04:34+08:00</updated><author><name>kmol</name></author><id>tag:,2016-05-28:./wang-ji-3d-zheng-chi-lun-chuan-dong-mo-ni.html</id><summary type="html">&lt;p&gt;Onshape 終於正式公開 &lt;a href="https://www.onshape.com/featurescript"&gt;FeatureScript&lt;/a&gt; 以及所有內建特徵功能的&lt;a href="https://cad.onshape.com/documents/5749364ce4b0f60f1b7940fe/w/925a5467b6e725168eb9c993/e/ff3b765aacc32576f893ed23"&gt;原始碼&lt;/a&gt;, 並且同時追加了許多新的功能, 包括機構的動態模擬.&lt;/p&gt;


&lt;p&gt;其中, 正好與協同產品設計實習課程進度結合的為&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/8b09d1743dcc794c5c38e7ab"&gt;正齒輪組&lt;/a&gt;的網際 3D 零組件設計繪圖與傳動模擬.&lt;/p&gt;
&lt;p&gt;以下為上述正齒輪組的零件組立圖:&lt;/p&gt;
&lt;p&gt;&lt;image src="http://chiamingyen.github.io/kmolab_data/files/201605/onshape_spur_gear_demo.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;使用者可以直接在電腦瀏覽器或平版手機上的 Onshape App, 開啟漸開線&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2923cd50930798d8999b2ef0"&gt;正齒輪零件的 Featurescript 繪圖程式碼&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;image src="http://chiamingyen.github.io/kmolab_data/files/201605/onshape_spur_gear_featurescript.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;此外, 使用者也可以開啟&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/8b09d1743dcc794c5c38e7ab"&gt;正齒輪組立&lt;/a&gt;連結後, 自行以滑鼠右鍵選擇主動旋轉的齒輪軸, 並按下 Animate, 就可以進行齒輪組的傳動模擬.&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>網際 2D 正齒輪傳動囓合繪圖</title><link href="./wang-ji-2d-zheng-chi-lun-chuan-dong-nie-he-hui-tu.html" rel="alternate"></link><updated>2016-05-24T09:31:29+08:00</updated><author><name>kmol</name></author><id>tag:,2016-05-24:./wang-ji-2d-zheng-chi-lun-chuan-dong-nie-he-hui-tu.html</id><summary type="html">&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/wang-ji-ji-jie-she-ji-2d-hui-tu.html"&gt;Brython 與 Cango Javascript 繪圖程式庫&lt;/a&gt;的結合, 可以讓參與協同的成員直接在網際環境中, 利用 Python3 語法進行產品開發流程中的設計運算與繪圖.&lt;/p&gt;


&lt;p&gt;以下為 17 齒, 29 齒與 15 齒輪組的囓合繪圖:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id='gear1' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
def spur(cx, cy, m, n, pa, theta):
    # n 為齒數
    #n = 17
    # pa 為壓力角
    #pa = 25
    # m 為模數, 根據畫布的寬度, 計算適合的模數大小
    # Module = mm of pitch diameter per tooth
    #m = 0.8*canvas.width/n
    # pr 為節圓半徑
    pr = n*m/2 # gear Pitch radius
    # generate gear
    data = creategeartooth(m, n, pa)
    # Brython 程式中的 print 會將資料印在 Browser 的 console 區
    #print(data)

    gearTooth = cobj(data, "SHAPE", {
            "fillColor":"#ddd0dd",
            "border": True,
            "strokeColor": "#606060" })
    #gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh, 請注意 rotate 角度為 degree
    # theta 為角度
    gearTooth.rotate(theta) 
    # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
    gear = gearTooth.dup()
    # gear 為單一齒的輪廓資料
    #cgo.render(gearTooth)

    # 利用單齒輪廓旋轉, 產生整個正齒輪外形
    for i in range(1, n):
        # 將 gearTooth 中的資料複製到 newTooth
        newTooth = gearTooth.dup()
        # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
        newTooth.rotate(360*i/n)
        # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
        gear.appendPath(newTooth, True) # trim move command = True

    # 建立軸孔
    # add axle hole, hr 為 hole radius
    hr = 0.6*pr # diameter of gear shaft
    shaft = cobj(shapedefs.circle(hr), "PATH")
    shaft.revWinding()
    gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
    gear.translate(cx, cy)
    # render 繪出靜態正齒輪輪廓
    cgo.render(gear)
    # 接著繪製齒輪的基準線
    deg = math.pi/180
    Line = cobj(['M', cx, cy, 'L', cx+pr*math.cos(theta*deg), cy+pr*math.sin(theta*deg)], "PATH", {
          'strokeColor':'blue', 'lineWidth': 1})
    cgo.render(Line)

# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
spur(cx, cy, m, n1, pa, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3+(180-180/n2)*n2/n3)
&lt;/script&gt;

&lt;p&gt;Brython 正齒輪傳動囓合繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id='gear1' width='800' height='750'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
def spur(cx, cy, m, n, pa, theta):
    # n 為齒數
    #n = 17
    # pa 為壓力角
    #pa = 25
    # m 為模數, 根據畫布的寬度, 計算適合的模數大小
    # Module = mm of pitch diameter per tooth
    #m = 0.8*canvas.width/n
    # pr 為節圓半徑
    pr = n*m/2 # gear Pitch radius
    # generate gear
    data = creategeartooth(m, n, pa)
    # Brython 程式中的 print 會將資料印在 Browser 的 console 區
    #print(data)

    gearTooth = cobj(data, "SHAPE", {
            "fillColor":"#ddd0dd",
            "border": True,
            "strokeColor": "#606060" })
    #gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh, 請注意 rotate 角度為 degree
    # theta 為角度
    gearTooth.rotate(theta) 
    # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
    gear = gearTooth.dup()
    # gear 為單一齒的輪廓資料
    #cgo.render(gearTooth)

    # 利用單齒輪廓旋轉, 產生整個正齒輪外形
    for i in range(1, n):
        # 將 gearTooth 中的資料複製到 newTooth
        newTooth = gearTooth.dup()
        # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
        newTooth.rotate(360*i/n)
        # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
        gear.appendPath(newTooth, True) # trim move command = True

    # 建立軸孔
    # add axle hole, hr 為 hole radius
    hr = 0.6*pr # diameter of gear shaft
    shaft = cobj(shapedefs.circle(hr), "PATH")
    shaft.revWinding()
    gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
    gear.translate(cx, cy)
    # render 繪出靜態正齒輪輪廓
    cgo.render(gear)
    # 接著繪製齒輪的基準線
    deg = math.pi/180
    Line = cobj(['M', cx, cy, 'L', cx+pr*math.cos(theta*deg), cy+pr*math.sin(theta*deg)], "PATH", {
          'strokeColor':'blue', 'lineWidth': 1})
    cgo.render(Line)

# 3個齒輪的齒數
n1 = 17
n2 = 29
n3 = 15

# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
# 利用 80% 的畫布寬度進行繪圖
# 計算模數的對應尺寸
m = canvas.width*0.8/(n1+n2+n3)

# 根據齒數與模組計算各齒輪的節圓半徑
pr1 = n1*m/2
pr2 = n2*m/2
pr3 = n3*m/2

# 畫布左右兩側都保留畫布寬度的 10%
# 依此計算對應的最左邊齒輪的軸心座標
cx = canvas.width*0.1+pr1
cy = canvas.height/2

# pa 為壓力角
pa = 25

# 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy)
spur(cx, cy, m, n1, pa, 0)
# 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊
# 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合
# 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n
spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2)
# 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置
# 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合
# 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度
# 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3
spur(cx+pr1+pr2+pr2+pr3, cy, m, n3, pa, 180-180/n3+(180-180/n2)*n2/n3)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;接下來學員將被要求以協同方式, 將繪圖模組放入 &lt;a href="http://flask.pocoo.org/"&gt;Flask 網際程式&lt;/a&gt;中, 根據下列參考資料, 完成 &lt;a href="https://github.com/2015fallhw/cdw11"&gt;CDW11 期末專案&lt;/a&gt;, 其中, 由&lt;a href="http://cdw11-ag100.rhcloud.com/static/blog/tags.html"&gt;學員靜態網誌&lt;/a&gt;呈現各協同人員的各週任務執行結果外, 也希望從&lt;a href="http://cdw11-ag100.rhcloud.com/"&gt;http://cdw11-ag100.rhcloud.com/&lt;/a&gt; 雲端網站中呈現各組專案成果(例如: a 班第1組的協同產品設計內容將位於 http://cdw11-ag100.rhcloud.com/ag1 連結, 各組依此類推):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/gearbox_1.gif" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/gearbox_2.gif" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/gears_tooth_engagement.gif" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/gear_train.gif" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/sprocket.gif" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/chain_sprocket_drawing.jpg" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Onshape Sprocket 零件繪製導引: &lt;a href="https://www.onshape.com/cad-blog/tech-tip-lets-build-a-sprocket"&gt;https://www.onshape.com/cad-blog/tech-tip-lets-build-a-sprocket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2D 鏈條傳動繪圖: &lt;a href="http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html"&gt;http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Chain Guide: &lt;a href="http://cad-lab.github.io/cadlab_data/files/Complete_guide_to_chain.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/Complete_guide_to_chain.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sprocket Engineering Data: &lt;a href="http://cad-lab.github.io/cadlab_data/files/sprocket-engineering-data.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/sprocket-engineering-data.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sprocket Design: &lt;a href="http://cad-lab.github.io/cadlab_data/files/design_draw_sprocket.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/design_draw_sprocket.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roller Chain Catalogue: &lt;a href="http://cad-lab.github.io/cadlab_data/files/Renold_Roller_Chain_catalogue.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/Renold_Roller_Chain_catalogue.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sprocket Guide: &lt;a href="http://cad-lab.github.io/cadlab_data/files/sprocket_maintenance-guide.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/sprocket_maintenance-guide.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gear Introduction: &lt;a href="http://cad-lab.github.io/cadlab_data/files/Introduction-to-Gears.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/Introduction-to-Gears.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gear Theory: Gear Manual: &lt;a href="http://cad-lab.github.io/cadlab_data/files/gear_theory.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/gear_theory.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gear Manual: &lt;a href="http://cad-lab.github.io/cadlab_data/files/gear_manual.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/gear_manual.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gearbox: &lt;a href="http://cad-lab.github.io/cadlab_data/files/Gearboxes.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/Gearboxes.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gearbox Design: &lt;a href="http://cad-lab.github.io/cadlab_data/files/design_basic_gear_boxes.pdf"&gt;http://cad-lab.github.io/cadlab_data/files/design_basic_gear_boxes.pdf&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>自行車傳動 2D 鏈條繪圖 (二)</title><link href="./zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html" rel="alternate"></link><updated>2016-05-10T12:17:38+08:00</updated><author><name>kmol</name></author><id>tag:,2016-05-10:./zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html</id><summary type="html">&lt;p&gt;免費不是重點, 自由與永續才是!&lt;/p&gt;
&lt;p&gt;設計結果不是重點, 能否協同與持續改進才是!&lt;/p&gt;
&lt;p&gt;-- 協同產品設計實習課程&lt;/p&gt;
&lt;p&gt;本課程因為使用 Jupyter, 而不必使用 Mathematica 或 Matlab.&lt;/p&gt;
&lt;p&gt;本課程因為使用 Ubuntu, 而不必使用 Windows 10.&lt;/p&gt;
&lt;p&gt;本課程因為使用 Leo Editor, Python3 與 Flask, 而不必使用 Visual Studio 或 C#.&lt;/p&gt;
&lt;p&gt;本課程因為使用 Onshape, 而不必使用 Solidworks 或其他單機 MCAD 套件.&lt;/p&gt;
&lt;p&gt;本課程因為使用 Github, Openshift 與 Bitbucket, 因此各參與協同者除了有本地端版本, 而且有協同的雲端版本.&lt;/p&gt;
&lt;p&gt;更重要的是, 本課程所採用的所有工具, 不僅自由, 而且免費.&lt;/p&gt;


&lt;p&gt;利用 &lt;a href="http://jupyter.org/"&gt;Jupyter&lt;/a&gt; 與 &lt;a href="http://www.sympy.org/"&gt;Sympy&lt;/a&gt; 計算與鏈條傳動對應的兩個節圓, 所產生的 8 個相切點座標, 假設兩個圓均位於 X 軸上, 且右側圓之圓心位於原點, 左側小齒盤 18 齒, 而右側大齒盤 30 齒, 以下符號式運算將產生符合約束條件的兩條外切線與兩條內切線所對應的 8 個切點座標與左側圓之圓心座標:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from sympy import *
import math
# center of left circle
x1 = Symbol('x1')
y1 = Symbol('y1')
# center of right circle
x2 = Symbol('x2')
y2 = Symbol('y2')
# left tangent points
x3 = Symbol('x3')
y3 = Symbol('y3')
# right tangent points
x4 = Symbol('x4')
y4 = Symbol('y4')

chainlength = 20
leftdegree = 20
rightdegree = 12
leftr = chainlength/2/math.sin(leftdegree*math.pi/180/2)
rightr = chainlength/2/math.sin(rightdegree*math.pi/180/2)
#print(leftr,"\n",rightr)
# tangent line is 10 sets of chain
len34 = 10*chainlength
# (x3-x4)**2+(y3-y4)**2-len34**2 表示 (x3, y3) 與 (x4, y4)距離 len34
# (x1-x3)**2+(y1-y3)**2-(leftr)**2 表示 (x1, y1) 與 (x3, y3) 距離為左圓半徑
# (x2-x4)**2+(y2-y4)**2-(rightr)**2 表示 (x2, y2) 與 (x4, y4) 距離為右圓半徑
# (x1-x4)**2+(y1-y4)**2-len34**2-(leftr)**2 表示左圓心與兩個相切點所圍成直角三角形邊長關係
# (x2-x3)**2+(y2-y3)**2-len34**2-(rightr)**2 表示右圓心與兩個相切點所圍成直角三角形邊長關係

answer = solve([(x3-x4)**2+(y3-y4)**2-len34**2, \
(x1-x3)**2+(y1-y3)**2-(leftr)**2, \
(x2-x4)**2+(y2-y4)**2-(rightr)**2, \
(x1-x4)**2+(y1-y4)**2-len34**2-(leftr)**2, \
(x2-x3)**2+(y2-y3)**2-len34**2-(rightr)**2, y1, x2, y2], \
[x1, y1, x2, y2, x3, y3, x4, y4])

for i in range(len(answer)):
    try:
        g.es(answer[i])
    except:
        print(answer[i])
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/2016springcdw12_chain_sympy.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;上述符號式運算流程得到的結果:&lt;/p&gt;
&lt;p&gt;(-251.966715968566, 0.0, 0.0, 0.0, -216.939755087825, -45.7105650721111, -58.1886285898711, 75.9367934509185)
(-251.966715968566, 0.0, 0.0, 0.0, -216.939755087825, 45.7105650721111, -58.1886285898711, -75.9367934509185)
(-203.592946177111, 0.0, 0.0, 0.0, -214.364148466539, -56.5714145924675, -17.8936874260919, -93.9794075692901)
(-203.592946177111, 0.0, 0.0, 0.0, -214.364148466539, 56.5714145924675, -17.8936874260919, 93.9794075692901)
(203.592946177111, 0.0, 0.0, 0.0, 214.364148466539, -56.5714145924675, 17.8936874260919, -93.9794075692901)
(203.592946177111, 0.0, 0.0, 0.0, 214.364148466539, 56.5714145924675, 17.8936874260919, 93.9794075692901)
(251.966715968566, 0.0, 0.0, 0.0, 216.939755087825, -45.7105650721111, 58.1886285898711, 75.9367934509185)
(251.966715968566, 0.0, 0.0, 0.0, 216.939755087825, 45.7105650721111, 58.1886285898711, -75.9367934509185)&lt;/p&gt;
&lt;p&gt;其中, 可以得到兩條外切線 (external tangents) 對應的關鍵座標點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左圓圓心: (-203.592946177111, 0.0)&lt;/li&gt;
&lt;li&gt;左側上切點座標: (-214.3641, 56.5714)&lt;/li&gt;
&lt;li&gt;右側上切點座標: (-17.8936, 93.9794)&lt;/li&gt;
&lt;li&gt;左側下切點座標: (-214.3641, -56.5714)&lt;/li&gt;
&lt;li&gt;右側下切點座標: (-17.8936, -93.9794)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以及與左側上方切點相連的節圓周上鏈條與水平線對應角度為 20.78 度, 上切線與水平線對應角度為 10.78 度, 而右側節圓周上與切點相連的鏈條, 與水平線的角度則為 4.78 度. &lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/2016springcdw12_ss_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;同時, 以下利用 Solvespace 以綠色線條, 標示出符合兩圓相切線的所謂內切線 (internal tangents), 與對應左側圓心位置, 而此等內切線可應用在皮帶傳動的設計配置.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/2016springcdw12_ss_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;根據上述的切點座標與相關角度條件, 就可以利用 &lt;a href="http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu.html"&gt;自行車傳動 2D 鏈條繪圖&lt;/a&gt; 中的鏈條繪圖元件進行下列繪圖:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為 class variable
    chamber = "M -6.8397, -1.4894             A 7, 7, 0, 1, 0, 6.8397, -1.4894             A 40, 40, 0, 0, 1, 6.8397, -18.511             A 7, 7, 0, 1, 0, -6.8397, -18.511             A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    #chamber = "M 0, 0 L 0, -20 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    def __init__(self, fillcolor="green", border=True, strokecolor= "tan", linewidth=2, scale=1):
        self.fillcolor = fillcolor
        self.border = border
        self.strokecolor = strokecolor
        self.linewidth = linewidth
        self.scale = scale

    # 利用鏈條起點與終點定義繪圖
    def basic(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, self.scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, v=False):
        # 若 v 為 True 則為虛擬 chain, 不 render
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.v = v
        # 注意, cgoChamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole0 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)*self.scale
        y2 = y1 + 20*math.sin(rot*deg)*self.scale

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        if v == False:
            cgo.render(basic1, x1, y1, self.scale, 0)

        return x2, y2

mychain = chain()

x1, y1 = mychain.basic_rot(-133.06,49.48, 20.78)

x2, y2=mychain.basic_rot(x1, y1,0.7800000000000011, True) 
x3, y3=mychain.basic_rot(x2, y2,-19.22, True) 
x4, y4=mychain.basic_rot(x3, y3,-39.22, True) 
x5, y5=mychain.basic_rot(x4, y4,-59.22, True) 
x6, y6=mychain.basic_rot(x5, y5,-79.22, True) 
x7, y7=mychain.basic_rot(x6, y6,-99.22, True) 
x8, y8=mychain.basic_rot(x7, y7,-119.22, True) 
x9, y9=mychain.basic_rot(x8, y8,-139.22, True) 
x10, y10=mychain.basic_rot(x9, y9,-159.22, True) 
x11, y11=mychain.basic_rot(x10, y10,-179.22, True) 
x12, y12=mychain.basic_rot(x11, y11,-199.22) 
x13, y13=mychain.basic_rot(x12, y12,-219.22) 
x14, y14=mychain.basic_rot(x13, y13,-239.22) 
x15, y15=mychain.basic_rot(x14, y14,-259.22) 
x16, y16=mychain.basic_rot(x15, y15,-279.22) 
x17, y17=mychain.basic_rot(x16, y16,-299.22) 
x18, y18=mychain.basic_rot(x17, y17,-319.22) 

#mychain = chain()

p1, k1 = mychain.basic_rot(82.11,93.98, 4.78)
p2, k2=mychain.basic_rot(p1, k1,-7.219999999999999) 
p3, k3=mychain.basic_rot(p2, k2,-19.22) 
p4, k4=mychain.basic_rot(p3, k3,-31.22) 
p5, k5=mychain.basic_rot(p4, k4,-43.22) 
p6, k6=mychain.basic_rot(p5, k5,-55.22) 
p7, k7=mychain.basic_rot(p6, k6,-67.22) 
p8, k8=mychain.basic_rot(p7, k7,-79.22) 
p9, k9=mychain.basic_rot(p8, k8,-91.22) 
p10, k10=mychain.basic_rot(p9, k9,-103.22) 
p11, k11=mychain.basic_rot(p10, k10,-115.22) 
p12, k12=mychain.basic_rot(p11, k11,-127.22) 
p13, k13=mychain.basic_rot(p12, k12,-139.22) 
p14, k14=mychain.basic_rot(p13, k13,-151.22) 
p15, k15=mychain.basic_rot(p14, k14,-163.22) 
p16, k16=mychain.basic_rot(p15, k15,-175.22) 
p17, k17=mychain.basic_rot(p16, k16,-187.22) 
p18, k18=mychain.basic_rot(p17, k17,-199.22, True) 
p19, k19=mychain.basic_rot(p18, k18,-211.22, True) 
p20, k20=mychain.basic_rot(p19, k19,-223.22, True) 
p21, k21=mychain.basic_rot(p20, k20,-235.22, True) 
p22, k22=mychain.basic_rot(p21, k21,-247.22, True) 
p23, k23=mychain.basic_rot(p22, k22,-259.22, True) 
p24, k24=mychain.basic_rot(p23, k23,-271.22, True) 
p25, k25=mychain.basic_rot(p24, k24,-283.22, True) 
p26, k26=mychain.basic_rot(p25, k25,-295.22, True) 
p27, k27=mychain.basic_rot(p26, k26,-307.22, True) 
p28, k28=mychain.basic_rot(p27, k27,-319.22, True) 
p29, k29=mychain.basic_rot(p28, k28,-331.22, True) 
p30, k30=mychain.basic_rot(p29, k29,-343.22, True) 

m1, n1 = mychain.basic_rot(x1, y1, 10.78)
m2, n2=mychain.basic_rot(m1, n1, 10.78)
m3, n3=mychain.basic_rot(m2, n2, 10.78)
m4, n4=mychain.basic_rot(m3, n3, 10.78)
m5, n5=mychain.basic_rot(m4, n4, 10.78)
m6, n6=mychain.basic_rot(m5, n5, 10.78)
m7, n7=mychain.basic_rot(m6, n6, 10.78)
m8, n8=mychain.basic_rot(m7, n7, 10.78)
m9, n9=mychain.basic_rot(m8, n8, 10.78)
m10, n10=mychain.basic_rot(m9, n9, 10.78)

r1, s1 = mychain.basic_rot(x11, y11, -10.78)
r2, s2=mychain.basic_rot(r1, s1, -10.78)
r3, s3=mychain.basic_rot(r2, s2, -10.78)
r4, s4=mychain.basic_rot(r3, s3, -10.78)
r5, s5=mychain.basic_rot(r4, s4, -10.78)
r6, s6=mychain.basic_rot(r5, s5, -10.78)
r7, s7=mychain.basic_rot(r6, s6, -10.78)
r8, s8=mychain.basic_rot(r7, s7, -10.78)
r9, s9=mychain.basic_rot(r8, s8, -10.78)
r10, s10=mychain.basic_rot(r9, s9, -10.78)
&lt;/script&gt;

&lt;p&gt;上述 2D 鏈條傳動的 Brython 繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為 class variable
    chamber = "M -6.8397, -1.4894             A 7, 7, 0, 1, 0, 6.8397, -1.4894             A 40, 40, 0, 0, 1, 6.8397, -18.511             A 7, 7, 0, 1, 0, -6.8397, -18.511             A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    #chamber = "M 0, 0 L 0, -20 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    def __init__(self, fillcolor="green", border=True, strokecolor= "tan", linewidth=2, scale=1):
        self.fillcolor = fillcolor
        self.border = border
        self.strokecolor = strokecolor
        self.linewidth = linewidth
        self.scale = scale

    # 利用鏈條起點與終點定義繪圖
    def basic(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, self.scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, v=False):
        # 若 v 為 True 則為虛擬 chain, 不 render
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.v = v
        # 注意, cgoChamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole0 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)*self.scale
        y2 = y1 + 20*math.sin(rot*deg)*self.scale

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        if v == False:
            cgo.render(basic1, x1, y1, self.scale, 0)

        return x2, y2

mychain = chain()

x1, y1 = mychain.basic_rot(-133.06,49.48, 20.78)

x2, y2=mychain.basic_rot(x1, y1,0.7800000000000011, True) 
x3, y3=mychain.basic_rot(x2, y2,-19.22, True) 
x4, y4=mychain.basic_rot(x3, y3,-39.22, True) 
x5, y5=mychain.basic_rot(x4, y4,-59.22, True) 
x6, y6=mychain.basic_rot(x5, y5,-79.22, True) 
x7, y7=mychain.basic_rot(x6, y6,-99.22, True) 
x8, y8=mychain.basic_rot(x7, y7,-119.22, True) 
x9, y9=mychain.basic_rot(x8, y8,-139.22, True) 
x10, y10=mychain.basic_rot(x9, y9,-159.22, True) 
x11, y11=mychain.basic_rot(x10, y10,-179.22, True) 
x12, y12=mychain.basic_rot(x11, y11,-199.22) 
x13, y13=mychain.basic_rot(x12, y12,-219.22) 
x14, y14=mychain.basic_rot(x13, y13,-239.22) 
x15, y15=mychain.basic_rot(x14, y14,-259.22) 
x16, y16=mychain.basic_rot(x15, y15,-279.22) 
x17, y17=mychain.basic_rot(x16, y16,-299.22) 
x18, y18=mychain.basic_rot(x17, y17,-319.22) 

#mychain = chain()

p1, k1 = mychain.basic_rot(82.11,93.98, 4.78)
p2, k2=mychain.basic_rot(p1, k1,-7.219999999999999) 
p3, k3=mychain.basic_rot(p2, k2,-19.22) 
p4, k4=mychain.basic_rot(p3, k3,-31.22) 
p5, k5=mychain.basic_rot(p4, k4,-43.22) 
p6, k6=mychain.basic_rot(p5, k5,-55.22) 
p7, k7=mychain.basic_rot(p6, k6,-67.22) 
p8, k8=mychain.basic_rot(p7, k7,-79.22) 
p9, k9=mychain.basic_rot(p8, k8,-91.22) 
p10, k10=mychain.basic_rot(p9, k9,-103.22) 
p11, k11=mychain.basic_rot(p10, k10,-115.22) 
p12, k12=mychain.basic_rot(p11, k11,-127.22) 
p13, k13=mychain.basic_rot(p12, k12,-139.22) 
p14, k14=mychain.basic_rot(p13, k13,-151.22) 
p15, k15=mychain.basic_rot(p14, k14,-163.22) 
p16, k16=mychain.basic_rot(p15, k15,-175.22) 
p17, k17=mychain.basic_rot(p16, k16,-187.22) 
p18, k18=mychain.basic_rot(p17, k17,-199.22, True) 
p19, k19=mychain.basic_rot(p18, k18,-211.22, True) 
p20, k20=mychain.basic_rot(p19, k19,-223.22, True) 
p21, k21=mychain.basic_rot(p20, k20,-235.22, True) 
p22, k22=mychain.basic_rot(p21, k21,-247.22, True) 
p23, k23=mychain.basic_rot(p22, k22,-259.22, True) 
p24, k24=mychain.basic_rot(p23, k23,-271.22, True) 
p25, k25=mychain.basic_rot(p24, k24,-283.22, True) 
p26, k26=mychain.basic_rot(p25, k25,-295.22, True) 
p27, k27=mychain.basic_rot(p26, k26,-307.22, True) 
p28, k28=mychain.basic_rot(p27, k27,-319.22, True) 
p29, k29=mychain.basic_rot(p28, k28,-331.22, True) 
p30, k30=mychain.basic_rot(p29, k29,-343.22, True) 

m1, n1 = mychain.basic_rot(x1, y1, 10.78)
m2, n2=mychain.basic_rot(m1, n1, 10.78)
m3, n3=mychain.basic_rot(m2, n2, 10.78)
m4, n4=mychain.basic_rot(m3, n3, 10.78)
m5, n5=mychain.basic_rot(m4, n4, 10.78)
m6, n6=mychain.basic_rot(m5, n5, 10.78)
m7, n7=mychain.basic_rot(m6, n6, 10.78)
m8, n8=mychain.basic_rot(m7, n7, 10.78)
m9, n9=mychain.basic_rot(m8, n8, 10.78)
m10, n10=mychain.basic_rot(m9, n9, 10.78)

r1, s1 = mychain.basic_rot(x11, y11, -10.78)
r2, s2=mychain.basic_rot(r1, s1, -10.78)
r3, s3=mychain.basic_rot(r2, s2, -10.78)
r4, s4=mychain.basic_rot(r3, s3, -10.78)
r5, s5=mychain.basic_rot(r4, s4, -10.78)
r6, s6=mychain.basic_rot(r5, s5, -10.78)
r7, s7=mychain.basic_rot(r6, s6, -10.78)
r8, s8=mychain.basic_rot(r7, s7, -10.78)
r9, s9=mychain.basic_rot(r8, s8, -10.78)
r10, s10=mychain.basic_rot(r9, s9, -10.78)
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;從上述 2D 傳動鏈條的繪圖中, 可以發現, 由於整個設計配置以上方兩個切點的直線距離 200 mm 為準進行繪圖後, 下方的切點位置並無法精確與實際齒盤鏈條定位, 表示在上述鏈條傳動組立下, 精確繞行圓周的長度並無法得到整數的鏈條單元數, 在實務上通常會多加上一個鏈條單元.&lt;/p&gt;
&lt;p&gt;而從下方的 2D 繪圖中可以發現, 依照上方取 10 個單元的鏈條長度, 比幾何運算的節圓鏈條線段長度長, 因此在實際鏈條組立時, 可以直接讓下方鏈條下垂的方式進行鏈條單元組立.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/2016springcdw12_chain_assembly_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;此外, 上面所列出的 Brython 鏈條傳動繪圖, 是由下方的 flask 程式片斷, 採 Blueprint 的程式架構所建立, 當使用者透過 Python3 與 flask 網際框架, 將協同程式配置在 Github 與 OpenShift 平台上時, 將可以透過更高階的網際協同程式架構, 執行各種產品開發專案.&lt;/p&gt;
&lt;p&gt;各學員參考下列 2D 鏈條傳動繪圖設計後, 可以自行練習 18 齒與 36 齒的傳動繪圖, 並配合後續的齒輪減速機與自行車設計, 完成各組的電動與人力兩用自行車期末專案.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from flask import Blueprint, request

ag100 = Blueprint('ag100', __name__, url_prefix='/ag100', template_folder='templates')

head_str = '''
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 2D 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id="plotarea" width="800" height="800"&amp;gt;&amp;lt;/canvas&amp;gt;
'''

tail_str = '''
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
'''

chain_str = '''
&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為 class variable
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    #chamber = "M 0, 0 L 0, -20 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    def __init__(self, fillcolor="green", border=True, strokecolor= "tan", linewidth=2, scale=1):
        self.fillcolor = fillcolor
        self.border = border
        self.strokecolor = strokecolor
        self.linewidth = linewidth
        self.scale = scale

    # 利用鏈條起點與終點定義繪圖
    def basic(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, self.scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, v=False):
        # 若 v 為 True 則為虛擬 chain, 不 render
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.v = v
        # 注意, cgoChamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole0 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)*self.scale
        y2 = y1 + 20*math.sin(rot*deg)*self.scale

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        if v == False:
            cgo.render(basic1, x1, y1, self.scale, 0)

        return x2, y2
'''

# 傳繪 A 函式內容
def a(x, y, scale=1, color="green"):
    outstring = '''
# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain(scale='''+str(scale)+''', fillcolor="'''+str(color)+'''")

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+''', 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1)
'''

    return outstring


# 傳繪 B 函式內容
def b(x, y):
    outstring = '''
# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 B
# 左邊四個垂直單元
# 每一個字元間隔為 65 pixels
#x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+''', 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, '''+str(x)+","+str(y)+''')
'''

    return outstring

# 傳繪 C 函式內容
def c(x, y):
    outstring = '''
# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
#x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+'''-10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
#x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
x5, y5 = mychain.basic_rot('''+str(x)+","+str(y)+'''-10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0)
'''

    return outstring


# 傳繪 D 函式內容
def d(x, y):
    outstring = '''
# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 左邊四個垂直單元
#x1, y1 = mychain.basic_rot(0+65*3, 0, 90)
x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+''', 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -40 度
x6, y6 = mychain.basic_rot(x5, y5, -40)
x7, y7 = mychain.basic_rot(x6, y6, -60)
# 右中垂直向下單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
# -120 度
x9, y9 = mychain.basic_rot(x8, y8, -120)
# -140
x10, y10 = mychain.basic_rot(x9, y9, -140)
# 水平接回原點
#mychain.basic(x10, y10, 0+65*3, 0, color="red")
mychain.basic(x10, y10, '''+str(x)+","+str(y)+''')
'''

    return outstring

def circle(x, y):
    outstring = '''
mychain = chain()

x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+''', 50)
'''
    for i in range(2, 10):
        outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*40)+") \n"
    return outstring

def circle1(x, y, degree=10):
    # 20 為鏈條兩圓距
    # chain 所圍之圓圈半徑為 20/2/math.asin(degree*math.pi/180/2)
    # degree = math.asin(20/2/radius)*180/math.pi
    #degree = 10
    first_degree = 90 - degree
    repeat = 360 / degree
    outstring = '''
mychain = chain()

x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+", "+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*degree)+") \n"
    return outstring


def circle2(x, y, degree=10):
    # 20 為鏈條兩圓距
    # chain 所圍之圓圈半徑為 20/2/math.asin(degree*math.pi/180/2)
    # degree = math.asin(20/2/radius)*180/math.pi
    #degree = 10
    first_degree = 90 - degree
    repeat = 360 / degree

    outstring = '''
mychain = chain()

x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+", "+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*degree)+") \n"
    return outstring


def twocircle(x, y):
    # 20 為鏈條兩圓距
    # chain 所圍之圓圈半徑為 20/2/math.asin(degree*math.pi/180/2)
    # degree = math.asin(20/2/radius)*180/math.pi
    x = 50
    y = 0
    degree = 12
    # 78, 66, 54, 42, 30, 18, 6度
    #必須有某些 chain 算座標但是不 render
    first_degree = 90 - degree
    repeat = 360 / degree
    # 第1節也是 virtual chain
    outstring = '''
mychain = chain()

x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+", "+str(first_degree)+''', True)
#x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+", "+str(first_degree)+''')
'''
    # 這裡要上下各多留一節虛擬 chain, 以便最後進行連接 (x7, y7) 與 (x22, y22)
    for i in range(2, int(repeat)+1):
        #if i &amp;lt; 7 or i &amp;gt; 23:        
        if i &amp;lt;= 7 or i &amp;gt;= 23:
            # virautl chain
            outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*degree)+", True) \n"
            #outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*degree)+") \n"
        else:
            outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*degree)+") \n"

    p = -150
    k = 0
    degree = 20
    # 70, 50, 30, 10
    # 從 i=5 開始, 就是 virautl chain
    first_degree = 90 - degree
    repeat = 360 / degree
    # 第1節不是 virtual chain
    outstring += '''
#mychain = chain()

p1, k1 = mychain.basic_rot('''+str(p)+","+str(k)+", "+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        if i &amp;gt;= 5 and i &amp;lt;= 13:
            # virautl chain
            outstring += "p"+str(i)+", k"+str(i)+"=mychain.basic_rot(p"+str(i-1)+", k"+str(i-1)+", 90-"+str(i*degree)+", True) \n"
            #outstring += "p"+str(i)+", k"+str(i)+"=mychain.basic_rot(p"+str(i-1)+", k"+str(i-1)+", 90-"+str(i*degree)+") \n"
        else:
            outstring += "p"+str(i)+", k"+str(i)+"=mychain.basic_rot(p"+str(i-1)+", k"+str(i-1)+", 90-"+str(i*degree)+") \n"

    # 上段連接直線
    # 從 p5, k5 作為起點
    first_degree = 10
    repeat = 11
    outstring += '''
m1, n1 = mychain.basic_rot(p4, k4, '''+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "m"+str(i)+", n"+str(i)+"=mychain.basic_rot(m"+str(i-1)+", n"+str(i-1)+", "+str(first_degree)+")\n"

    # 下段連接直線
    # 從 p12, k12 作為起點
    first_degree = -10
    repeat = 11
    outstring += '''
r1, s1 = mychain.basic_rot(p13, k13, '''+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "r"+str(i)+", s"+str(i)+"=mychain.basic_rot(r"+str(i-1)+", s"+str(i-1)+", "+str(first_degree)+")\n"

    # 上段右方接點為 x7, y7, 左側則為 m11, n11
    outstring += "mychain.basic(x7, y7, m11, n11)\n"
    # 下段右方接點為 x22, y22, 左側則為 r11, s11
    outstring += "mychain.basic(x22, y22, r11, s11)\n"

    return outstring
def eighteenthirty(x, y):
    '''
從圖解法與符號式解法得到的兩條外切線座標點
(-203.592946177111, 0.0), (0.0, 0.0), (-214.364148466539, 56.5714145924675), (-17.8936874260919, 93.9794075692901)
(-203.592946177111, 0.0), (0.0, 0.0), (-214.364148466539, -56.5714145924675), (-17.8936874260919, -93.9794075692901)
左邊關鍵鍊條起點 (-233.06, 49.48), 角度 20.78, 圓心 (-203.593, 0.0)
右邊關鍵鍊條起點 (-17.89, 93.9), 角度 4.78, 圓心 (0, 0)
    '''
    # 20 為鏈條兩圓距
    # chain 所圍之圓圈半徑為 20/2/math.asin(degree*math.pi/180/2)
    # degree = math.asin(20/2/radius)*180/math.pi
    x = 50
    y = 0
    degree = 20
    first_degree = 20.78
    startx = -233.06+100
    starty = 49.48
    repeat = 360 / degree
    # 先畫出左邊第一關鍵節
    outstring = '''
mychain = chain()

x1, y1 = mychain.basic_rot('''+str(startx)+","+str(starty)+", "+str(first_degree)+''')

'''
    # 接著繪製左邊的非虛擬鍊條
    for i in range(2, int(repeat)+1):
        if i &amp;gt;=2 and i &amp;lt;=11:
            # virautl chain
            #outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+","+str(first_degree+degree-i*degree)+") \n"
            outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+","+str(first_degree+degree-i*degree)+", True) \n"
        else:
            outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+","+str(first_degree+degree-i*degree)+") \n"

    # 接著處理右邊的非虛擬鍊條
    # 先畫出右邊第一關鍵節

    p = -17.89+100
    k = 93.98
    degree = 12
    first_degree = 4.78
    repeat = 360 / degree
    # 第1節不是 virtual chain
    outstring += '''
#mychain = chain()

p1, k1 = mychain.basic_rot('''+str(p)+","+str(k)+", "+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        if i &amp;gt;=18:
            # virautl chain
            outstring += "p"+str(i)+", k"+str(i)+"=mychain.basic_rot(p"+str(i-1)+", k"+str(i-1)+","+str(first_degree+degree-i*degree)+", True) \n"
            #outstring += "p"+str(i)+", k"+str(i)+"=mychain.basic_rot(p"+str(i-1)+", k"+str(i-1)+","+str(first_degree+degree-i*degree)+") \n"
        else:
            outstring += "p"+str(i)+", k"+str(i)+"=mychain.basic_rot(p"+str(i-1)+", k"+str(i-1)+","+str(first_degree+degree-i*degree)+") \n"

    # 上段連接直線
    # 從 x1, y1 作為起點
    first_degree = 10.78
    repeat = 10
    outstring += '''
m1, n1 = mychain.basic_rot(x1, y1, '''+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "m"+str(i)+", n"+str(i)+"=mychain.basic_rot(m"+str(i-1)+", n"+str(i-1)+", "+str(first_degree)+")\n"

    # 下段連接直線
    # 從 x11, y11 作為起點
    first_degree = -10.78
    repeat = 10
    outstring += '''
r1, s1 = mychain.basic_rot(x11, y11, '''+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "r"+str(i)+", s"+str(i)+"=mychain.basic_rot(r"+str(i-1)+", s"+str(i-1)+", "+str(first_degree)+")\n"

    return outstring


@ag100.route('/a')
def draw_a():
    return head_str + chain_str + a(0, 0) + tail_str


@ag100.route('/b')
def draw_b():
   # 每個橫向字元距離為 65 pixels, 上下字距則為 110 pixels
    return head_str + chain_str + b(0+65, 0) + tail_str


@ag100.route('/c')
def draw_c():
    # 每個橫向字元距離為 65 pixels
    return head_str + chain_str + c(0+65*2, 0) + tail_str


@ag100.route('/d')
def draw_d():
    return head_str + chain_str + d(0+65*3, 0) + tail_str


@ag100.route('/ab')
def draw_ab():
    #return head_str + chain_str + a(0, 0) + b(0+65, 0) + tail_str
    return head_str + chain_str + a(0, 0) + b(0, 0-110) + tail_str


@ag100.route('/ac')
def draw_ac():
    return head_str + chain_str + a(0, 0) + c(0+65, 0) + tail_str


@ag100.route('/bc')
def draw_bc():
    return head_str + chain_str + b(0, 0) + c(0+65, 0) + tail_str


@ag100.route('/abc')
def draw_abc():
    return head_str + chain_str + a(0, 0) + b(0+65, 0) + c(0+65*2, 0) + tail_str


@ag100.route('/aaaa')
def draw_aaaa():
    outstring = head_str + chain_str
    scale = 2
    for i in range(20):
        scale = scale*0.9
        outstring +=  a(0+10*i, 0, scale=scale)
    return outstring + tail_str
    #return head_str + chain_str + a(0, 0, scale=1) + a(0+65, 0, scale=0.8, color="red") + a(0+65*2, 0, scale=0.6) + a(0+65*3, 0, scale=0.4, color="red") + tail_str


@ag100.route('/badc')
def draw_badc():
    return head_str + chain_str + b(0, 0) + a(0+65, 0) + d(0+65*2, 0) + c(0+65*3, 0) + tail_str


@ag100.route('/abcd')
def draw_abcd():
    #return head_str + chain_str + a(0, 0) + b(0+65, 0) + c(0+65*2, 0) + d(0+65*3, 0) + tail_str
    return head_str + chain_str + a(0, 110) + b(0, 110-110) + c(0, 110-110*2) + d(0, 110-110*3) + tail_str


@ag100.route('/circle')
def drawcircle():
    return head_str + chain_str + circle(0, 0) + tail_str


@ag100.route('/circle1/&amp;lt;degree&amp;gt;', defaults={'x': 0, 'y': 0})
@ag100.route('/circle1/&amp;lt;x&amp;gt;/&amp;lt;degree&amp;gt;', defaults={'y': 0})
@ag100.route('/circle1/&amp;lt;x&amp;gt;/&amp;lt;y&amp;gt;/&amp;lt;degree&amp;gt;')
#@ag100.route('/circle1/&amp;lt;int:x&amp;gt;/&amp;lt;int:y&amp;gt;/&amp;lt;int:degree&amp;gt;')
def drawcircle1(x,y,degree):
    return head_str + chain_str + circle1(int(x), int(y), int(degree)) + tail_str


@ag100.route('/circle2/&amp;lt;degree&amp;gt;', defaults={'x': 0, 'y': 0})
@ag100.route('/circle2/&amp;lt;x&amp;gt;/&amp;lt;degree&amp;gt;', defaults={'y': 0})
@ag100.route('/circle2/&amp;lt;x&amp;gt;/&amp;lt;y&amp;gt;/&amp;lt;degree&amp;gt;')
#@ag100.route('/circle2/&amp;lt;int:x&amp;gt;/&amp;lt;int:y&amp;gt;/&amp;lt;int:degree&amp;gt;')
def drawcircle2(x,y,degree):
    return head_str + chain_str + circle2(int(x), int(y), int(degree)) + tail_str


@ag100.route('/twocircle/&amp;lt;x&amp;gt;/&amp;lt;y&amp;gt;')
@ag100.route('/twocircle', defaults={'x':0, 'y':0})
def drawtwocircle(x,y):
    return head_str + chain_str + twocircle(int(x), int(y)) + tail_str


@ag100.route('/eighteenthirty/&amp;lt;x&amp;gt;/&amp;lt;y&amp;gt;')
@ag100.route('/eighteenthirty', defaults={'x':0, 'y':0})
def draweithteenthirdy(x,y):
    return head_str + chain_str + eighteenthirty(int(x), int(y)) + tail_str


@ag100.route('/snap')
# http://svg.dabbles.info/snaptut-base
def snap():
    outstring = '''
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 snap 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
    &amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type="text/javascript" src="/static/snap.svg-min.js"&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;
    window.onload=function(){
    brython(1);
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;svg width="800" height="800" viewBox="0 0 800 800" id="svgout"&amp;gt;&amp;lt;/svg&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

s = snap("#svgout")
# 建立物件時, 同時設定 id 名稱
r = s.rect(10,10,100,100).attr({'id': 'rect'})
c = s.circle(100,100,50).attr({'id': 'circle'})
r.attr('fill', 'red')
c.attr({ 'fill': 'blue', 'stroke': 'black', 'strokeWidth': 10 })
r.attr({ 'stroke': '#123456', 'strokeWidth': 20 })
s.text(180,100, '點按一下圖形').attr({'fill' : 'blue',  'stroke': 'blue', 'stroke-width': 0.2 })

g = s.group().attr({'id': 'tux'})

def hoverover(ev):
    g.animate({'transform': 's1.5r45,t180,20'}, 1000, window.mina.bounce)

def hoverout(ev):
    g.animate({'transform': 's1r0,t180,20'}, 1000, window.mina.bounce) 

# callback 函式
def onSVGLoaded(data):
    #s.append(data)
    g.append(data)
    #g.hover(hoverover, hoverout )
    g.text(300,100, '拿滑鼠指向我')

# 利用 window.Snap.load 載入 svg 檔案
tux = window.Snap.load("/static/Dreaming_tux.svg", onSVGLoaded)
g.transform('t180,20')

# 與視窗事件對應的函式
def rtoyellow(ev):
    r.attr('fill', 'yellow')

def ctogreen(ev):
    c.attr('fill', 'green')

# 根據物件 id 綁定滑鼠事件執行對應函式
document['rect'].bind('click', rtoyellow)
document['circle'].bind('click', ctogreen)
document['tux'].bind('mouseover', hoverover)
document['tux'].bind('mouseleave', hoverout)
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
'''
    return outstring


@ag100.route('/snap_link')
# http://svg.dabbles.info/
def snap_link():
    outstring = '''
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 snap 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
    &amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type="text/javascript" src="/static/snap.svg-min.js"&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;
    window.onload=function(){
    brython(1);
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;svg width="800" height="800" viewBox="0 0 800 800" id="svgout"&amp;gt;&amp;lt;/svg&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標訂出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
'''
    return outstring


@ag100.route('/snap_gear')
def snap_gear():
    outstring = '''
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 snap 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
    &amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type="text/javascript" src="/static/snap.svg-min.js"&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;
    window.onload=function(){
    brython(1);
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;svg width="800" height="800" viewBox="0 0 800 800" id="svgout"&amp;gt;&amp;lt;/svg&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

s = snap("#svgout")
# 畫直線
s.line(0, 0, 100, 100).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "1"  }).attr({ 'id': 'line1' })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
'''
    return outstring
&lt;/pre&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>協同產品設計實習期中報告</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-qi-zhong-bao-gao.html" rel="alternate"></link><updated>2016-05-10T09:56:57+08:00</updated><author><name>kmol</name></author><id>tag:,2016-05-10:./xie-tong-chan-pin-she-ji-shi-xi-qi-zhong-bao-gao.html</id><summary type="html">&lt;p&gt;2016spring 的協同產品設計課程, 導入了 git 版次管理的 &lt;a href="https://help.github.com/articles/adding-collaborators-to-a-personal-repository/"&gt;collaborator&lt;/a&gt; (各組組長) 與 &lt;a href="https://help.github.com/articles/using-pull-requests/"&gt;pull request&lt;/a&gt; (各組組員)協同模式, 由於 Github 提供了免費的多人協同方案, 讓兩班 133 名學員(2a: 62, 2b: 71)可以各自在本地端與遠端的倉儲分支資料中進行改版.&lt;/p&gt;


&lt;p&gt;從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/tag/xie-tong-chan-pin-she-ji-shi-xi.html"&gt;協同產品設計實習課程 tag&lt;/a&gt; 可以查閱與協同產品設計實習有關的頁面, &lt;a href="http://chiamingyen.github.io/kmolab/blog/xie-tong-chan-pin-she-ji-shi-xi-de-wang-ji-2d-xie-tong-hui-tu.html"&gt;期中報告內容&lt;/a&gt; (&lt;a href="https://github.com/2015fallhw/cdw2/wiki/2016spring-CD-%E6%9C%9F%E4%B8%AD%E5%A0%B1%E5%91%8A%E5%85%A7%E5%AE%B9"&gt;cdw2 倉儲 wiki&lt;/a&gt;) 則包含 2D/3D 鏈條零組件的繪圖, 2D 零件繪圖以 &lt;a href="http://2015fallhw.github.io/arcidau/"&gt;Cango 繪圖程式庫&lt;/a&gt;與 &lt;a href="http://www.brython.info/"&gt;Brython 程式語言&lt;/a&gt;為主, 實際的繪圖程式採用 &lt;a href="http://flask.pocoo.org/"&gt;Flask 框架&lt;/a&gt;, 可以在近端與 &lt;a href="https://www.openshift.com/"&gt;Openshift 雲端&lt;/a&gt;平台上執行繪圖. 至於 3D 零組件繪圖則要求在 &lt;a href="https://www.onshape.com"&gt;Onshape 雲端 CAD&lt;/a&gt; 系統中完成.&lt;/p&gt;
&lt;p&gt;以下為期中報告的任務 (Task 1) 執行參考流程:&lt;/p&gt;
&lt;h2&gt;網際協同 2D 零組件繪圖:&lt;/h2&gt;
&lt;h3&gt;計算鏈條輪廓圓弧相切點座標&lt;/h3&gt;
&lt;p&gt;以下符號式運算使用 sympy, 並且能夠直接在 &lt;a href="https://github.com/jupyter/jupyterhub"&gt;Jupyter hub&lt;/a&gt; 環境中執行, 若&lt;a href="https://github.com/chiamingyen/kmol2016"&gt;隨身 Python3 程式環境&lt;/a&gt;無 sympy 模組, 可以 pip install sympy 安裝.&lt;/p&gt;
&lt;p&gt;假設上方圓弧圓心位於原點, 且鏈條輪廓上下垂直沒有轉角.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((x1, y1)\)&lt;/span&gt; 設為左側圓弧的圓心座標, &lt;span class="math"&gt;\((x2, y2)\)&lt;/span&gt; 則為上方圓弧與左側圓弧的相切點座標, &lt;span class="math"&gt;\((x3, y3)\)&lt;/span&gt; 則為下方圓弧與左側圓弧的相切點座標.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((x2-0)**2 + (y2-0)**2 - 7*7 = 0\)&lt;/span&gt;, 表示 &lt;span class="math"&gt;\((x2, y2)\)&lt;/span&gt; 位於圓心 (0, 0), 半徑 7 的圓上.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((x1-x2)**2+(y1-y2)**2 -40**2 = 0\)&lt;/span&gt;, 表示 &lt;span class="math"&gt;\((x2, y2)\)&lt;/span&gt; 也同時位於圓心 &lt;span class="math"&gt;\((x1, y1)\)&lt;/span&gt;, 半徑 40 的圓上.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((x1-x3)**2+(y1-y3)**2 -40**2 = 0\)&lt;/span&gt;, 表示 &lt;span class="math"&gt;\((x3, y3)\)&lt;/span&gt; 位於圓心 &lt;span class="math"&gt;\((x1, y1)\)&lt;/span&gt;, 半徑 40 的圓上.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((x1-0)**2+(y1-0)**2 -47**2 = 0\)&lt;/span&gt;, 表示 &lt;span class="math"&gt;\((x1, y1)\)&lt;/span&gt; 與 (0, 0) 兩個圓弧的圓心距離為 (40+7).&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((x1)**2+(y1+20)**2 -47**2 = 0\)&lt;/span&gt;, 表示 &lt;span class="math"&gt;\((x1, y1)\)&lt;/span&gt; 與 (0, -20) 兩個圓弧的圓心距離也是 (40+7).&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(x2 - x3 = 0\)&lt;/span&gt;, 表示鏈條輪廓上下垂直沒有轉角, 所以 &lt;span class="math"&gt;\(x2 = x3\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
from sympy import *
# center ot radius 40
x1 = Symbol('x1')
y1 = Symbol('y1')
# upper tangent point
x2 = Symbol('x2')
y2 = Symbol('y2')
# lower tangent point
x3 = Symbol('x3')
y3 = Symbol('y3')
answer = solve([(x2-0)**2 + (y2-0)**2 - 7*7, (x1-x2)**2+(y1-y2)**2 -40**2, (x1-x3)**2+(y1-y3)**2 -40**2, (x1)**2+(y1)**2 -47**2, \
       (x1)**2+(y1+20)**2 -47**2, x2 -x3], [x1, y1, x2, y2, x3, y3])
group = 1
for i in answer:
    try:
        g.es("group", group, ":")
    except:
        print("group", group, ":")
    for j in i:
        try:
            g.es(j.evalf(5))
        except:
            print(j.evalf(5))
    group += 1
&lt;/pre&gt;

&lt;p&gt;計算出的結果:&lt;/p&gt;
&lt;pre class="brush: xml;"&gt;
左邊半徑 40 的圓心座標 (-45.924, -10.000)
左上方的切點座標 (-6.8397, -1.4894)
左下方的切點座標 (-6.8397, -18.511)
右邊半徑 40 的圓心座標 (45.924, -10.000)
右上方切點座標 (6.8397, -1.4894)
右下方切點座標 (6.8397, -18.511)
&lt;/pre&gt;

&lt;p&gt;根據四個切點的座標, 利用 Cango 與 Brython 完成單一鍊條輪廓繪圖:&lt;/p&gt;
&lt;pre class="brush: xml;"&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 2D 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id="plotarea" width="800" height="800"&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 決定要不要畫座標軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  
def O(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 放大 5 倍
    cgo.render(cmbr, x, y, 5, rot)

O(0, 0, 0, 0, 0, "lightyellow", True, 4)
# 準備標示出4個點的座標 (放大 5 倍)
cgo.drawText("各點的座標值放大5倍", (-6.8397*5)-50, (-1.4894*5)+20, {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
# 左上角點
cgo.drawText("(-6.8397, -1.4894)", (-6.8397*5)-50, (-1.4894*5), {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (-6.8397*5), (-1.4894*5), {"fillColor": "red"})
# 右上角點
cgo.drawText("(6.8397, -1.4894)", (6.8397*5)+50, (-1.4894*5)+20, {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (6.8397*5), (-1.4894*5), {"fillColor": "red"})
# 左下角點
cgo.drawText("(-6.8397, -18.511)", (-6.8397*5)-50, (-18.511*5), {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (-6.8397*5), (-18.511*5), {"fillColor": "red"})
# 右下角點
cgo.drawText("(6.8397, -18.511)", (6.8397*5)+50, (-18.511*5), {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (6.8397*5), (-18.511*5), {"fillColor": "red"})
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;繪圖結果如下:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")
cgo.setWorldCoords(-250, -250, 500, 500)

# 決定要不要畫座標軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  
def O(x, y, rx, ry, rot, color, border, linewidth):
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 放大 5 倍
    cgo.render(cmbr, x, y, 5, rot)

O(0, 0, 0, 0, 0, "lightyellow", True, 4)
# 準備標示出4個點的座標 (放大 5 倍)
cgo.drawText("各點的座標值放大5倍", (-6.8397*5)-50, (-1.4894*5)+20, {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
# 左上角點
cgo.drawText("(-6.8397, -1.4894)", (-6.8397*5)-50, (-1.4894*5), {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (-6.8397*5), (-1.4894*5), {"fillColor": "red"})
# 右上角點
cgo.drawText("(6.8397, -1.4894)", (6.8397*5)+50, (-1.4894*5)+20, {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (6.8397*5), (-1.4894*5), {"fillColor": "red"})
# 左下角點
cgo.drawText("(-6.8397, -18.511)", (-6.8397*5)-50, (-18.511*5), {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (-6.8397*5), (-18.511*5), {"fillColor": "red"})
# 右下角點
cgo.drawText("(6.8397, -18.511)", (6.8397*5)+50, (-18.511*5), {"fontSize": 12, "fontWeight": 1200, "lorg":5 })
cgo.drawShape(shapedefs.circle(4), (6.8397*5), (-18.511*5), {"fillColor": "red"})
&lt;/script&gt;

&lt;p&gt;上述 2D 鏈條輪廓繪圖因為採用 Cango 與 Brython, 可以直接利用 Javascript 在 html 網頁上執行繪圖, 此特點與 PTC Creo Parametric 中的 Pro/Web.Link 3D 零組件繪圖模式相同, 但是為了要能夠利用雲端網際環境進行協同, 還必須要透過 Web Server based 的 Python3 wsgi 程式來派送 2D 與 3D 零組件的繪圖 (也可以採用 Java, Node.js 或其他 Web Server based 的程式方法完成).&lt;/p&gt;
&lt;p&gt;這裡的 Web Based Server 程式採用 Python3 與 Flask, 並且可以在近端與 &lt;a href="https://www.openshift.com/"&gt;Openshift&lt;/a&gt; 雲端派送上述的 2D 鏈條輪廓繪圖, 而此一協同架構隨後將應用到 PTC Creo Parametric 中的 Pro/Web.Link 3D 零組件繪圖, 比較不同的是, 在 Windows 環境下, Pro/Web.Link 的執行只能在嵌入式的 IE 瀏覽器中執行, 而且無法與支援較新 Javascript 版本的 Brython 結合. 換言之, 隨後的 Pro/Web.Link 3D 零組件繪圖, 必須採用純 Javascript 程式, 而且只能在 Creo Parametric 的嵌入式 IE 中執行.&lt;/p&gt;
&lt;h2&gt;Github cdw2 倉儲協同規劃&lt;/h2&gt;
&lt;p&gt;接下來, 為了要能夠在 Github 倉儲中實現近端與 &lt;a href="https://www.openshift.com/"&gt;Openshift&lt;/a&gt; 平台上的 Python3 &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; wsgi 程式 2D 零組件繪圖, 同時利用 &lt;a href="https://help.github.com/categories/github-pages-basics/"&gt;Github Pages&lt;/a&gt; 來集結各組所完成的期中報告結果, 我們決定要將 cdw2 倉儲分為 master 與 gh-pages 的分支版本, 而且不可合併. cdw2 的 master 可以直接在近端完成 2D 零組件繪圖, 而且同一組程式將利用 git remote add 由各組組員送到各自的 &lt;a href="https://www.openshift.com/"&gt;Openshift&lt;/a&gt; Python3 應用程式上執行, 而且各組員所完成的期中報告結果, 可以利用 cdw2 倉儲中的 gh-pages 分支, 以 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican 靜態網誌&lt;/a&gt;的架構執行協同內容管理.&lt;/p&gt;
&lt;p&gt;2D 零組件協同繪圖 (注意畫布名稱必須與上列繪圖名稱不同):&lt;/p&gt;
&lt;pre class="brush: xml;"&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 2D 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id="plotarea2" width="800" height="600"&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 決定要不要畫座標軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  
def O(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 放大 5 倍
    cgo.render(cmbr, x, y, 5, rot)

O(0, 0, 0, 0, 0, "red", True, 4)
&amp;lt;/script&amp;gt;
&amp;lt;!-- 以下為第2位組員的零件繪圖 --&amp;gt;
&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

deg = math.pi/180  
def O2(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 120 度
    basic1.rotate(120)

    # 放大 5 倍
    cgo.render(basic1, x, y, 5, rot)

O2(0, 0, 0, 0, 0, "blue", True, 4)
&amp;lt;/script&amp;gt;
&amp;lt;!-- 以下為第3位組員的零件繪圖 --&amp;gt;
&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

deg = math.pi/180  
def O3(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 90 度
    basic1.rotate(90)
    # 平移到 O2 的鏈條端點
    basic1.translate(20*math.cos(30*deg), 20*math.sin(30*deg))

    # 放大 5 倍
    cgo.render(basic1, x, y, 5, rot)

O3(0, 0, 0, 0, 0, "green", True, 4)
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;2D 協同繪圖結果如下:&lt;/p&gt;
&lt;canvas id="plotarea2" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 決定要不要畫座標軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  
def O(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 放大 5 倍
    cgo.render(cmbr, x, y, 5, rot)

O(0, 0, 0, 0, 0, "red", True, 4)
&lt;/script&gt;

&lt;!-- 以下為第2位組員的零件繪圖 --&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

deg = math.pi/180  
def O2(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 120 度
    basic1.rotate(120)

    # 放大 5 倍
    cgo.render(basic1, x, y, 5, rot)

O2(0, 0, 0, 0, 0, "blue", True, 4)
&lt;/script&gt;

&lt;!-- 以下為第3位組員的零件繪圖 --&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

deg = math.pi/180  
def O3(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "tan",
            "lineWidth": linewidth })

    # hole 為原點位置
    hole = cobj(shapedefs.circle(4), "PATH")
    cmbr.appendPath(hole)

    # 複製 cmbr, 然後命名為 basic1
    basic1 = cmbr.dup()
    # basic1 轉 90 度
    basic1.rotate(90)
    # 平移到 O2 的鏈條端點
    basic1.translate(20*math.cos(30*deg), 20*math.sin(30*deg))

    # 放大 5 倍
    cgo.render(basic1, x, y, 5, rot)

O3(0, 0, 0, 0, 0, "green", True, 4)
&lt;/script&gt;

&lt;p&gt;完成上述 2D 零組件協同繪圖後, 各組組長就可以直接將 cdw2 master 分支上的 wsgi 程式, 先在本地端測試無誤後, 再提交推送到 2015fallhw/cdw2, 若為組員則需透過 pull request, 以拉回請求的方式, 要求組長將 master 分支上的 wsgi 改版資料, 設法合併到 2015fallhw/cdw2 倉儲中.&lt;/p&gt;
&lt;p&gt;這裡利用 scrum1 示範帳號, 將上述 2D 零組件繪圖程式提交推送到 2015fallhw/cdw2 後, 再利用 git remote add openshift ssh://123e6d7b22d5271fb220000c9@cdw2-ladisai.rhcloud.com/~/git/cdw2.git/, 透過 /home/.ssh/id_rsa 中 OpenSSL 格式的 private key, 與 Openshift 應用程式上 settings 中的 public key 對應, 取得權限後, 以 git push openshift 將 cdw2 master 的資料送到 Openshift 平台上執行, 所得結果為:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_demo1"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_demo1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_demo2"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_demo2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_demo3"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_demo3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所對應的 2015fallhw/cdw2 提交版本為: &lt;a href="https://github.com/2015fallhw/cdw2/tree/92ccd643061f2fb43030a9423c825f425963d481"&gt;https://github.com/2015fallhw/cdw2/tree/92ccd643061f2fb43030a9423c825f425963d481&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;scrum1_task1.py 版本為: &lt;a href="https://github.com/2015fallhw/cdw2/blob/92ccd643061f2fb43030a9423c825f425963d481/users/s2a/g100/scrum1_task1.py"&gt;https://github.com/2015fallhw/cdw2/blob/92ccd643061f2fb43030a9423c825f425963d481/users/s2a/g100/scrum1_task1.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;scrum2_task1.py 版本則為: &lt;a href="https://github.com/2015fallhw/cdw2/blob/92ccd643061f2fb43030a9423c825f425963d481/users/s2a/g100/scrum2_task1.py"&gt;https://github.com/2015fallhw/cdw2/blob/92ccd643061f2fb43030a9423c825f425963d481/users/s2a/g100/scrum2_task1.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後, 當各組員首次建立 Openshift 平台上與 2015fallhw/cdw2 倉儲 master 分支對應的 wsgi 應用程式時, 可以將 https://github.com/2015fallhw/cdw2.git 列為該應用程式的原始碼, 當 2015fallhw/cdw2 倉儲 master 分支版本不斷改版後, 各組員可以利用類似 git clone ssh://123e6d7b22d5271fb220000c9@cdw2-ladisai.rhcloud.com/~/git/cdw2.git/ cdw2_openshift 將倉儲資料 clone 到近端後, 進入 cdw2_openshift 目錄後, 以 git rm -rf * 將所有先前的版本內容全數刪除後, 再放入 2015fallhw/cdw2 倉儲 master 分支中的最新版本資料後, 以 git add -A, git commit -m "提交訊息", git push 等提交與推送指令, 將 wsgi 程式送到對應的 Openshift 平台應用程式上執行, 每次各組有新的對應程式改版後, 再採用相同模式更新 Openshift 平台上的程式版本, 避免在 Openshift 對應倉儲中處理衝突問題.&lt;/p&gt;
&lt;h3&gt;2D 鏈條繪圖範例&lt;/h3&gt;
&lt;canvas id="plotarea3" width="800" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea3")

cgo.setGridboxRHC(10, 10, 100, 100)
cgo.fillGridbox("lightyellow")
cgo.setWorldCoords(-10, -10, 300, 300) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot(0, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1, color="red")

# 畫 B
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, 0, 0, color="red")

# 畫 C
# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0, color="red")


# 畫 D
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+65*3, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -40 度
x6, y6 = mychain.basic_rot(x5, y5, -40)
x7, y7 = mychain.basic_rot(x6, y6, -60)
# 右中垂直向下單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
# -120 度
x9, y9 = mychain.basic_rot(x8, y8, -120)
# -140
x10, y10 = mychain.basic_rot(x9, y9, -140)
# 水平接回原點
mychain.basic(x10, y10, 0+65*3, 0, color="red")
&lt;/script&gt;

&lt;h3&gt;3D 鏈條繪圖範例&lt;/h3&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/onshape_bike_chain_assembly.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/onshape_char_a.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/29d1a262b055745e59be7c09/w/1f25948ad73282e2440ffdcf/e/e27164ff303f821d684ca266"&gt;Onshape 字母 A 鏈條組立檔案&lt;/a&gt;&lt;/p&gt;
&lt;script src="https://embed.github.com/view/3d/chiamingyen/kmolab_data/gh-pages/files/bicycle%20chain%20-%20a_char.stl"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>2015 Fall CADP W16</title><link href="./2015-fall-cadp-w16.html" rel="alternate"></link><updated>2016-05-08T01:48:30+08:00</updated><author><name>yen</name></author><id>tag:,2016-05-08:./2015-fall-cadp-w16.html</id><summary type="html">&lt;p&gt;根據 &lt;a href="http://chiamingyen.github.io/kmolab_data/files/ProEMechanism.pdf"&gt;Nutcracker 機構&lt;/a&gt;的尺寸規格, 請設法算出 Piston 零件的有效運動範圍.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_left_limit.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_right_limit.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;計算 Piston 不發生干涉的有效行程, 可採如下方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;實際利用 Onshape 中的組立, 移動 piston 零件, 靠目測概略決定 piston 的有效行程. (目測法, 只能得到大概的行程範圍)&lt;/li&gt;
&lt;li&gt;利用 Solvespace 繪製 2D 約束圖, 然後利用約束點在線或圓上的方式, 以圖解法解出有效行程, 如下圖一, 圖二與圖三所示. (圖解法, 利用 Solvespace 既有的約束條件設定完成計算)&lt;/li&gt;
&lt;li&gt;利用 Jupyter 與 Python3 的 sympy 模組, 先進行符號式推導, 然後再利用數值分析解出 piston 的有效行程, 機構各點標示如下圖四所示, &lt;a href="https://github.com/2015fallhw/cptocadp/blob/master/ref/cadp_nutcracker.ipynb"&gt;計算出&lt;/a&gt;的 theta 轉角為 105.7, 如下圖五所示. (以自行編寫的 sympy 程式解題, 透過 Jupyterhub 可以有效進行協同設計運算)&lt;/li&gt;
&lt;li&gt;除了上述的目測, 圖解與符號式結合數值分析法之外, 也可以採用&lt;a href="https://github.com/2015fallhw/cptocadp/blob/master/ga_nutcracker1.py"&gt;基因演算法解題&lt;/a&gt;, 計算出的 theta 轉角為 105.7, 如下圖六所示. (利用演化法解題, 可以在單機運算, 也可以在 &lt;a href="https://github.com/2015fallhw/cptocadp/blob/master/ref/cadp_nutcracker.ipynb"&gt;Jupyterhub 平台&lt;/a&gt;上進行運算)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_solvespace1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖一: 利用 Solvespace 中的繪圖約束條件找出右邊的極限點距離 Onshape Piston 組立原點 0.5&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_solvespace2.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖二: 利用 Solvespace 中的繪圖約束條件找出左邊的極限點距離 Onshape Piston 組立原點 2.23&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_solvespace3.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖三: 當 piston 位於左邊極限點時, AB 轉角為 105.37 度&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_analysis1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖四: Jupyter 計算分析時機構各點標示圖&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_jupyter_result1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖五: 利用 Jupyter 符號式結合數值分析法所得結果&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/nutcracker_ga_result1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖六: 利用基因演算解題, 所得到的結果, 當 piston 位於左邊極限點時, AB 轉角為 105.7 度&lt;/p&gt;
&lt;p&gt;若採用 &lt;a href="https://github.com/deap/deap"&gt;deap&lt;/a&gt; 與 numpy 解題 (AB 轉角極限為 105.71 度):&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# 這裡採用 numpy 與 deap 模組解題, 使用 Genetic Algorithm 模式
# 解的問題為 Nutcracker 左邊 connect 轉角極限
import random
import array
from deap import base
from deap import creator
from deap import tools
import numpy
# for evalIntersect 函式中的 sqrt, sin, cos, pi
from math import *

# 1/4 最小化題目 type of problem
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", array.array, typecode='d', \
               fitness=creator.FitnessMin)
# 2/4 initilization
# 兩個變數題目
NDIM = 2
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, 0, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# 3/4 選擇 operator step3/4
toolbox.register("select", tools.selRandom, k=3)

# 也可以採用下列設定
#toolbox.register("mate", tools.cxTwoPoint)
#toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
#toolbox.register("select", tools.selTournament, tournsize=3, k=3)

def evalIntersect(individual):
    t = individual[0]
    deg = pi/180
    theta = individual[1]*deg
    xtarget = 0.75/2
    ytarget = 0.5
    x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 \
        + 529)/92 + 3*cos(theta)/2
    y = (-3*t/2 + 123/92)*sin(theta)
    # 適應值
    fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

    # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
    if t &gt; 1:
        fitness_value += 1000
    if t &lt; 0:
        fitness_value += 1000
    # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
    if theta &gt; 2*pi:
        fitness_value += 1000
    if theta &lt; 0:
        fitness_value += 1000
    return fitness_value,

toolbox.register("evaluate", evalIntersect)
# 以上到 evaluate 為止, 為定義 operators

# 4/4 以下則為 Algorithms
def main():
    # Differential evolution parameters
    CR = 0.25
    F = 1 
    MU = 300
    NGEN = 200   

    pop = toolbox.population(n=MU);
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)

    # Evaluate the individuals
    fitnesses = toolbox.map(toolbox.evaluate, pop)
    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit

    for g in range(1, NGEN):
        for k, agent in enumerate(pop):
            a,b,c = toolbox.select(pop)
            y = toolbox.clone(agent)
            index = random.randrange(NDIM)
            for i, value in enumerate(agent):
                if i == index or random.random() &lt; CR:
                    y[i] = a[i] + F*(b[i]-c[i])
            y.fitness.values = toolbox.evaluate(y)
            if y.fitness &gt; agent.fitness:
                pop[k] = y
        hof.update(pop)


    print("Best individual is ", hof[0], hof[0].fitness.values[0])

if __name__ == "__main__":
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
上述課程資料與 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4584#more-4584"&gt;Wordpress 網頁&lt;/a&gt;上的資料內容相同, Ｗordpress 網站屬於動態的網誌, 而 &lt;a href="http://chiamingyen.github.io/kmolab/"&gt;http://chiamingyen.github.io/kmolab/&lt;/a&gt; 則是靜態網誌系統, 採用靜態網誌的優點如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較安全&lt;/li&gt;
&lt;li&gt;比較不會過時&lt;/li&gt;
&lt;li&gt;部署成本比較低&lt;/li&gt;
&lt;li&gt;可在各種平台上使用&lt;/li&gt;
&lt;li&gt;各階段改版資料均有紀錄&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下為參考用的 GA 解 Nutcracker 題目的程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#encoding=utf8
# genetic.py
#
import random
import operator
# for Intersect
from math import *
MAXIMIZE, MINIMIZE = 11, 22
class Individual:
    chromosome = None
    score = None
    # Here the size of var depends on var_number
    var = []
    var_number = 2
    for i in range(var_number):
        var.append(0)
    alleles = (0,1)
    # 以下為參數可負數時的編碼考量
    #前10為小數,後10為整數,第21則為正負號
    #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
    #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
    #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
    # -1023 ~ 1023
    #length = 21*var_number,若接受負數參數,則必須同步修改 20-&gt;21
    length = 20*var_number
    seperator = ''
    optimization = MINIMIZE
    def __init__(self, chromosome=None):
        self.chromosome = chromosome or self._makechromosome()
        self.score = None  # set during evaluation
    def _getvar(self,chromosome=None):
        x = 0
        for i in range(0,self.var_number):
            for j in range(i*20,i*20+10):
                x +=self.chromosome[j]&lt;&lt;(j-(i*20))
            if (x&gt;999):
                x=999
            x/=1000.
            for j in range(i*20+10,i*20+20):
                x +=self.chromosome[j]&lt;&lt;(j-(i*20+10))
            self.var[i] = x
        return self.var
        ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
#for design variable -1023 ~1023
        for i in range(self.var_number):
            x = 0
            for j in range(i*21,i*21+10):
                x +=self.chromosome[j]&lt;&lt;(j-(i*21))
            if (x&gt;999):
                x=999
            x/=1000.
            for j in range(i*(21)+10,i*(21)+20):
                x +=self.chromosome[j]&lt;&lt;(j-(i*21+10))
            if(self.chromosome[i*(21)+20] == 1):
                self.var[i] = -x
            else:
                self.var[i] = x
            x = 0
        return self.var
        '''
    def _makechromosome(self):
        "makes a chromosome from randomly selected alleles."
        return [random.choice(self.alleles) for gene in range(self.length)]
    def evaluate(self, optimum=None):
        "this method MUST be overridden to evaluate individual fitness score."
        pass
    def crossover(self, other):
        "override this method to use your preferred crossover method."
        return self._twopoint(other)
    def mutate(self, gene):
        "override this method to use your preferred mutation method."
        self._pick(gene)
    # sample mutation method
    def _pick(self, gene):
        "chooses a random allele to replace this gene's allele."
        self.chromosome[gene] = random.choice(self.alleles)
    # sample crossover method
    def _twopoint(self, other):
        "creates offspring via two-point crossover between mates."
        left, right = self._pickpivots()
        def mate(p0, p1):
            chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
            chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
            #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對
            child = p0.__class__(chromosome)
            child._repair(p0, p1)
            return child
        return mate(self, other), mate(other, self)
    # some crossover helpers ...
    def _repair(self, parent1, parent2):
        "override this method, if necessary, to fix duplicated genes."
        pass
    def _pickpivots(self):
        left = random.randrange(1, self.length-2)
        right = random.randrange(left, self.length-1)
        return left, right
    #
    # other methods
    #
    def __repr__(self):
        "returns string representation of self"
        '''
        return '&lt;%s chromosome="%s" score=%s var=%s&gt;' % \
               (self.__class__.__name__,
                self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
        '''
        return '&lt;%s score=%s var=%s&gt;' % \
               (self.__class__.__name__,self.score,self._getvar(self.chromosome))
    # since the __cmp__ special function is gone  use the __lt__ in stead
    # use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b)
    #def __cmp__(self, other):
    # these are for python 3
    def __cmp__(self, other):
        if self.optimization == MINIMIZE:
            #return cmp(self.score, other.score)
            return (self.score &gt; other.score) - (self.score &lt; other.score)
        else: # MAXIMIZE
            #return cmp(other.score, self.score)
            return (other.score &gt; self.score) - (other.score &lt; self.score)

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0
    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0
    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0
    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0 
    def copy(self):
        twin = self.__class__(self.chromosome[:])
        twin.score = self.score
        return twin
class Environment(object):
    x = [0]
    y = [0]
    def __init__(self, kind, population=None, size=100, maxgenerations=100,
                 crossover_rate=0.90, mutation_rate=0.07, optimum=None):
        self.kind = kind
        self.size = size
        self.optimum = optimum
        self.population = population or self._makepopulation()
        for individual in self.population:
            individual.evaluate(self.optimum)
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.maxgenerations = maxgenerations
        self.generation = 0
        self.report()
    def _makepopulation(self):
        return [self.kind() for individual in range(self.size)]
    def run(self):
        while not self._goal():
            self.step()
    def _goal(self):
        return self.generation &gt; self.maxgenerations or \
               self.best.score == self.optimum
    def step(self):
        # this sort is not working with python 3.0, modification is needed
        self.population.sort()
        self._crossover()
        self.generation += 1
        self.report()
        self.x.append(self.generation)
        # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
        if self.best.score &lt;=5:
            self.y.append(self.best.score)
        else:
            self.y.append(5)
    def _crossover(self):
        next_population = [self.best.copy()]
        while len(next_population) &lt; self.size:
            mate1 = self._select()
            if random.random() &lt; self.crossover_rate:
                mate2 = self._select()
                offspring = mate1.crossover(mate2)
            else:
                offspring = [mate1.copy()]
            for individual in offspring:
                self._mutate(individual)
                individual.evaluate(self.optimum)
                next_population.append(individual)
        self.population = next_population[:self.size]
    def _select(self):
        "override this to use your preferred selection method"
        return self._tournament()
    def _mutate(self, individual):
        for gene in range(individual.length):
            if random.random() &lt; self.mutation_rate:
                individual.mutate(gene)
    #
    # sample selection method
    #
    def _tournament(self, size=8, choosebest=0.90):
        competitors = [random.choice(self.population) for i in range(size)]
        competitors.sort()
        if random.random() &lt; choosebest:
            return competitors[0]
        else:
            return random.choice(competitors[1:])
    def best():
        doc = "individual with best fitness score in population."
        def fget(self):
            return self.population[0]
        return locals()
    best = property(**best())
    def report(self):
        print ("="*70)
        print ("generation: ", self.generation)
        print ("best:       ", self.best)

# 以上為 genetic.py 目前將兩者結合在一起
#encoding=utf8
# volume.py - useage example
#
# the fittest individual will have a chromosome consisting of 40 '1's
#
#
#import genetic
#此一加總函式在 volume 最大化中,並未使用
def sum(seq):
    def add(x,y): return x+y
    return reduce(add, seq, 0)
class Volume(Individual):
    optimization = MAXIMIZE
    def evaluate(self, optimum=None):
        SURFACE = 80
        # self.score is the fitness value
        self._getvar(self.chromosome)

        x = self.var[0]
        y = self.var[1]
        z=(SURFACE - x*y)/(2.*(x+y))
        fitness_value = x*y*z

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip

class Intersect(Individual):
    optimization = MINIMIZE
    def evaluate(self, optimum=None):
        # self.score is the fitness value
        self._getvar(self.chromosome)

        t = self.var[0]
        deg = pi/180
        theta = self.var[1]*deg
        xtarget = 0.75/2
        ytarget = 0.5
        x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2
        y = (-3*t/2 + 123/92)*sin(theta)
        # 適應值
        fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

        # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
        if t &gt; 1:
            fitness_value += 1000
        if t &lt; 0:
            fitness_value += 1000
        # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
        if theta &gt; 2*pi:
            fitness_value += 1000
        if theta &lt; 0:
            fitness_value += 1000

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip


if __name__ == "__main__":
    #env = Environment(Volume, size=500, maxgenerations=100)
    env = Environment(Intersect, size=500, maxgenerations=100)
    env.run()
&lt;/pre&gt;</summary><category term="電腦輔助設計實習"></category><category term="2015 Fall cadp"></category></entry><entry><title>導入 Brython 與 Snap.svg 網際繪圖</title><link href="./dao-ru-brython-yu-snapsvg-wang-ji-hui-tu.html" rel="alternate"></link><updated>2016-05-03T21:46:47+08:00</updated><author><name>kmol</name></author><id>tag:,2016-05-03:./dao-ru-brython-yu-snapsvg-wang-ji-hui-tu.html</id><summary type="html">&lt;p&gt;&lt;a href="http://snapsvg.io/"&gt;http://snapsvg.io/&lt;/a&gt; 是一套 SVG 繪圖程式庫, 結合 &lt;a href="http://brython.info/"&gt;http://brython.info/&lt;/a&gt; 之後, 使用者可以直接在網際環境中利用 Python3 與 SVG 進行靜態或動態模擬繪圖. 也能逐步將 &lt;a href="http://rattlecad.sourceforge.net/"&gt;http://rattlecad.sourceforge.net/&lt;/a&gt; 轉換到網際環境中. 其中, 2D 零組件繪圖可以採 SVG 完成, 而對應的 3D 零組件則可利用 &lt;a href="https://www.onshape.com"&gt;https://www.onshape.com&lt;/a&gt; 完成.&lt;/p&gt;


&lt;p&gt;首先是典型的 Snap.svg 動態繪圖:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;p&gt;&lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
&lt;/script&gt;

&lt;p&gt;Brython 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&gt;&lt;/svg&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;接著則是簡單的 SVG 檔案導入與滑鼠事件測試:&lt;/p&gt;
&lt;p&gt;&lt;svg width="800" height="700" viewBox="0 0 800 700" id="svgout1"&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

s = snap("#svgout1")
# 建立物件時, 同時設定 id 名稱
r = s.rect(10,10,100,100).attr({'id': 'rect'})
c = s.circle(100,100,50).attr({'id': 'circle'})
r.attr('fill', 'red')
c.attr({ 'fill': 'blue', 'stroke': 'black', 'strokeWidth': 10 })
r.attr({ 'stroke': '#123456', 'strokeWidth': 20 })
s.text(180,100, '點按一下圖形').attr({'fill' : 'blue',  'stroke': 'blue', 'stroke-width': 0.2 })

g = s.group().attr({'id': 'tux'})

def hoverover(ev):
    g.animate({'transform': 's1.5r45,t180,20'}, 1000, window.mina.bounce)

def hoverout(ev):
    g.animate({'transform': 's1r0,t180,20'}, 1000, window.mina.bounce) 

# callback 函式
def onSVGLoaded(data):
    #s.append(data)
    g.append(data)
    #g.hover(hoverover, hoverout )
    g.text(300,100, '將滑鼠指向企鵝')

# 利用 window.Snap.load 載入 svg 檔案
tux = window.Snap.load("http://chiamingyen.github.io/kmolab_data/files/Dreaming_tux.svg", onSVGLoaded)
g.transform('t180,20')

# 與視窗事件對應的函式
def rtoyellow(ev):
    r.attr('fill', 'yellow')

def ctogreen(ev):
    c.attr('fill', 'green')

# 根據物件 id 綁定滑鼠事件執行對應函式
document['rect'].bind('click', rtoyellow)
document['circle'].bind('click', ctogreen)
document['tux'].bind('mouseover', hoverover)
document['tux'].bind('mouseleave', hoverout)
&lt;/script&gt;

&lt;p&gt;Brython 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;svg width="800" height="700" viewBox="0 0 800 700" id="svgout1"&gt;&lt;/svg&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

s = snap("#svgout1")
# 建立物件時, 同時設定 id 名稱
r = s.rect(10,10,100,100).attr({'id': 'rect'})
c = s.circle(100,100,50).attr({'id': 'circle'})
r.attr('fill', 'red')
c.attr({ 'fill': 'blue', 'stroke': 'black', 'strokeWidth': 10 })
r.attr({ 'stroke': '#123456', 'strokeWidth': 20 })
s.text(180,100, '點按一下圖形').attr({'fill' : 'blue',  'stroke': 'blue', 'stroke-width': 0.2 })

g = s.group().attr({'id': 'tux'})

def hoverover(ev):
    g.animate({'transform': 's1.5r45,t180,20'}, 1000, window.mina.bounce)

def hoverout(ev):
    g.animate({'transform': 's1r0,t180,20'}, 1000, window.mina.bounce) 

# callback 函式
def onSVGLoaded(data):
    #s.append(data)
    g.append(data)
    #g.hover(hoverover, hoverout )
    g.text(300,100, '將滑鼠指向企鵝')

# 利用 window.Snap.load 載入 svg 檔案
tux = window.Snap.load("http://chiamingyen.github.io/kmolab_data/files/Dreaming_tux.svg", onSVGLoaded)
g.transform('t180,20')

# 與視窗事件對應的函式
def rtoyellow(ev):
    r.attr('fill', 'yellow')

def ctogreen(ev):
    c.attr('fill', 'green')

# 根據物件 id 綁定滑鼠事件執行對應函式
document['rect'].bind('click', rtoyellow)
document['circle'].bind('click', ctogreen)
document['tux'].bind('mouseover', hoverover)
document['tux'].bind('mouseleave', hoverout)
&lt;/script&gt;
&lt;/pre&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category><category term="網際內容管理"></category></entry><entry><title>自行車傳動 2D 鏈條繪圖</title><link href="./zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu.html" rel="alternate"></link><updated>2016-05-03T13:27:19+08:00</updated><author><name>kmol</name></author><id>tag:,2016-05-03:./zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu.html</id><summary type="html">&lt;p&gt;利用 html canvas 完成的 2D 自行車鏈條繪圖練習:&lt;/p&gt;


&lt;p&gt;左側鏈輪齒數為 18, 右側鏈輪齒數為 30.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bike_chain_18_30.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bike_chain2_18_30.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;參考用繪圖程式碼:&lt;/p&gt;
&lt;p&gt;鏈條繪圖 class 定義:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from flask import Blueprint, request

ag100 = Blueprint('ag100', __name__, url_prefix='/ag100', template_folder='templates')

head_str = '''
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 2D 鏈條繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id="plotarea" width="800" height="800"&amp;gt;&amp;lt;/canvas&amp;gt;
'''

tail_str = '''
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
'''

chain_str = '''
&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為 class variable
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    def __init__(self, fillcolor="green", border=True, strokecolor= "tan", linewidth=2, scale=1):
        self.fillcolor = fillcolor
        self.border = border
        self.strokecolor = strokecolor
        self.linewidth = linewidth
        self.scale = scale

    # 利用鏈條起點與終點定義繪圖
    def basic(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, self.scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, v=False):
        # 若 v 為 True 則為虛擬 chain, 不 render
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.v = v
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": self.fillcolor,
                "border": self.border,
                "strokeColor": self.strokecolor,
                "lineWidth": self.linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4*self.scale), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)*self.scale
        y2 = y1 + 20*math.sin(rot*deg)*self.scale

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        if v == False:
            cgo.render(basic1, x1, y1, self.scale, 0)

        return x2, y2
'''
&lt;/pre&gt;

&lt;p&gt;利用鏈條元件傳繪出 A 字元的 Brython 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# 傳繪 A 函式內容
def a(x, y, scale=1, color="green"):
    outstring = '''
# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain(scale='''+str(scale)+''', fillcolor="'''+str(color)+'''")

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+''', 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1)
'''

    return outstring
&lt;/pre&gt;

&lt;p&gt;flask 框架程式中定義 A 繪圖連結:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@ag100.route('/a')
def draw_a():
    return head_str + chain_str + a(0, 0) + tail_str
&lt;/pre&gt;

&lt;p&gt;利用鏈條元件送出環繞 36 齒鏈齒輪的繪圖 Brython 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def circle36(x, y, degree=10):
    # 20 為鏈條輪廓之圓距
    # chain 所圍之圓圈半徑為 20/2/math.asin(degree*math.pi/180/2)
    # degree = math.asin(20/2/radius)*180/math.pi
    #degree = 10
    first_degree = 90 - degree
    repeat = 360 / degree
    outstring = '''
mychain = chain()

x1, y1 = mychain.basic_rot('''+str(x)+","+str(y)+", "+str(first_degree)+''')
'''
    for i in range(2, int(repeat)+1):
        outstring += "x"+str(i)+", y"+str(i)+"=mychain.basic_rot(x"+str(i-1)+", y"+str(i-1)+", 90-"+str(i*degree)+") \n"
    return outstring
&lt;/pre&gt;

&lt;p&gt;利用 circle36 函式, 搭配 flask 的 URL 連結多變數設定格式, 執行鏈條繪圖:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@ag100.route('/circle36/&amp;lt;degree&amp;gt;', defaults={'x': 0, 'y': 0})
@ag100.route('/circle36/&amp;lt;x&amp;gt;/&amp;lt;degree&amp;gt;', defaults={'y': 0})
@ag100.route('/circle36/&amp;lt;x&amp;gt;/&amp;lt;y&amp;gt;/&amp;lt;degree&amp;gt;')
#@ag100.route('/circle36/&amp;lt;int:x&amp;gt;/&amp;lt;int:y&amp;gt;/&amp;lt;int:degree&amp;gt;')
def drawcircle36(x,y,degree):
    return head_str + chain_str + circle36(int(x), int(y), int(degree)) + tail_str
&lt;/pre&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>歷年協同產品設計實習課程內容整理</title><link href="./li-nian-xie-tong-chan-pin-she-ji-shi-xi-ke-cheng-nei-rong-zheng-li.html" rel="alternate"></link><updated>2016-04-30T18:11:14+08:00</updated><author><name>kmol</name></author><id>tag:,2016-04-30:./li-nian-xie-tong-chan-pin-she-ji-shi-xi-ke-cheng-nei-rong-zheng-li.html</id><summary type="html">&lt;p&gt;&lt;a href="http://cd-cadp.rhcloud.com/"&gt;2015 Spring 協同產品設計實習課程網頁&lt;/a&gt;, &lt;a href="http://wiki.mde.tw/doku.php?id=%E5%8D%94%E5%90%8C%E7%94%A2%E5%93%81%E8%A8%AD%E8%A8%88:%E5%AF%A6%E7%BF%92%E7%9B%AE%E6%A8%99"&gt;2014 Spring 協同產品設計實習課程網頁&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;課程簡介&lt;/h2&gt;
&lt;p&gt;課程中文名稱: 協同產品設計實習&lt;/p&gt;
&lt;p&gt;課程英文名稱: Collaborative Product Design Principles and Practices&lt;/p&gt;
&lt;p&gt;課程主要介紹協同產品設計原理與協同產品設計流程的實踐&lt;/p&gt;
&lt;h2&gt;協同產品設計原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;牽涉多名與產品設計相關的成員&lt;/li&gt;
&lt;li&gt;以完成產品開發作為共同目標&lt;/li&gt;
&lt;li&gt;透過產品生命週期管理機制&lt;/li&gt;
&lt;li&gt;成員分別或共同完成產品專案中的分項任務&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;協同產品設計流程的實踐&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;產品開發流程確認&lt;/li&gt;
&lt;li&gt;成員角色確認&lt;/li&gt;
&lt;li&gt;協同工作模式&lt;/li&gt;
&lt;li&gt;產品生命週期管理系統&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;協同的背景&lt;/h2&gt;
&lt;p&gt;全球化帶來的密集與瞬息萬變的競爭, 即便是全球各領域目前領先的國際大公司都必須要靠快速併購, 才能具備克敵致勝的專業能力, 因此對於規模較小, 專業能力較不全面的公司與團隊, 為求生存, 必得積極尋求各方協同的機會.&lt;/p&gt;
&lt;p&gt;以機械設計流程的角度言, 協同產品設計過程中主要的項目在資訊與知識層次上的協同.&lt;/p&gt;
&lt;p&gt;協同的目的在追求速度, 效能, 多元, 互動與彈性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;速度 - 推出新產品的速度, 修正既有錯誤的速度&lt;/li&gt;
&lt;li&gt;效能 - 強調效率與功能, 持續降低成本&lt;/li&gt;
&lt;li&gt;多元 - 多方嘗試, 多方檢視, 多方調控, 多方出擊&lt;/li&gt;
&lt;li&gt;互動 - 有推有拉, 有來有往, 密切藕合&lt;/li&gt;
&lt;li&gt;彈性 - 及時調整適應, 配合需求能夠加以變化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;知識創建&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;知識分為隱性與顯性, 一般的 know-how 屬於技術性的隱性知識, 另一種隱性知識則稱為認知型隱性知識&lt;/li&gt;
&lt;li&gt;認知型的隱性知識則包括團隊間的認知文化, 經驗與潛規則&lt;/li&gt;
&lt;li&gt;顯性知識則泛指書本, 導引手冊, 指南等以文字, 影像, 語音, 圖表及多媒體型式, 清楚表達的資訊內容&lt;/li&gt;
&lt;li&gt;通常在新產品開發過程中, 透過團隊間付出與能力上的競爭, 會激化出隱性知識的創建&lt;/li&gt;
&lt;li&gt;隱性知識通常透過成員在組織間, 以較長時間浸濡方可傳承, 必須設法轉為顯性知識, 以加快並擴大知識所能產生的效益&lt;/li&gt;
&lt;li&gt;協同產品設計公司的挑戰之一則是如何將新產品開發過程中的隱性知識轉化為顯性知識&lt;/li&gt;
&lt;li&gt;顯性就是已經清楚表達出來的, 隱性就是存在但沒有清楚表達的&lt;/li&gt;
&lt;li&gt;書本, 導引手冊是顯性知識, 隱性知識又分兩種, 一種是團隊間大家都知道「一定」要這樣做才可以解決問題的知識, 又稱 know-how&lt;/li&gt;
&lt;li&gt;而另外一種隱性知識則是大家「一直」都這樣做的認知, 又稱文化, 習慣或潛規則&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;採用 Brython 與直線段繪製的漸開線正齒輪輪廓繪圖:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from math import *

# 準備在 id="plotarea" 的 canvas 中繪圖
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")

def create_line(x1, y1, x2, y2, width=3, fill="red"):
    ctx.beginPath()
    ctx.lineWidth = width
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = fill
    ctx.stroke()

# 導入數學函式後, 圓周率為 pi
# deg 為角度轉為徑度的轉換因子
deg = pi/180.
#
# 以下分別為正齒輪繪圖與主 tkinter 畫布繪圖
#
# 定義一個繪正齒輪的繪圖函式
# midx 為齒輪圓心 x 座標
# midy 為齒輪圓心 y 座標
# rp 為節圓半徑, n 為齒數
def gear(midx, midy, rp, n, 顏色):
    # 將角度轉換因子設為全域變數
    global deg
    # 齒輪漸開線分成 15 線段繪製
    imax = 15
    # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
    create_line(midx, midy, midx, midy-rp)
    # 畫出 rp 圓, 畫圓函式尚未定義
    #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
    # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
    # 模數也就是齒冠大小
    a=2*rp/n
    # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
    d=2.5*rp/n
    # ra 為齒輪的外圍半徑
    ra=rp+a
    print("ra:", ra)
    # 畫出 ra 圓, 畫圓函式尚未定義
    #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
    # rb 則為齒輪的基圓半徑
    # 基圓為漸開線長齒之基準圓
    rb=rp*cos(20*deg)
    print("rp:", rp)
    print("rb:", rb)
    # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
    #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
    # rd 為齒根圓半徑
    rd=rp-d
    # 當 rd 大於 rb 時
    print("rd:", rd)
    # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
    #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
    # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
    # 將圓弧分成 imax 段來繪製漸開線
    dr=(ra-rb)/imax
    # tan(20*deg)-20*deg 為漸開線函數
    sigma=pi/(2*n)+tan(20*deg)-20*deg
    for j in range(n):
        ang=-2.*j*pi/n+sigma
        ang2=2.*j*pi/n+sigma
        lxd=midx+rd*sin(ang2-2.*pi/n)
        lyd=midy-rd*cos(ang2-2.*pi/n)
        for i in range(imax+1):
            r=rb+i*dr
            theta=sqrt((r*r)/(rb*rb)-1.)
            alpha=theta-atan(theta)
            xpt=r*sin(alpha-ang)
            ypt=r*cos(alpha-ang)
            xd=rd*sin(-ang)
            yd=rd*cos(-ang)
            # i=0 時, 繪線起點由齒根圓上的點, 作為起點
            if(i==0):
                last_x = midx+xd
                last_y = midy-yd
            # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
            create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=顏色)
            # 最後一點, 則為齒頂圓
            if(i==imax):
                lfx=midx+xpt
                lfy=midy-ypt
            last_x = midx+xpt
            last_y = midy-ypt
        '''
        the line from last end of dedendum point to the recent
        end of dedendum point
        '''
        # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
        # 下列為齒根圓上用來近似圓弧的直線
        create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=顏色)
        for i in range(imax+1):
            r=rb+i*dr
            theta=sqrt((r*r)/(rb*rb)-1.)
            alpha=theta-atan(theta)
            xpt=r*sin(ang2-alpha)
            ypt=r*cos(ang2-alpha)
            xd=rd*sin(ang2)
            yd=rd*cos(ang2)
            # i=0 時, 繪線起點由齒根圓上的點, 作為起點
            if(i==0):
                last_x = midx+xd
                last_y = midy-yd
            # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
            create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=顏色)
            # 最後一點, 則為齒頂圓
            if(i==imax):
                rfx=midx+xpt
                rfy=midy-ypt
            last_x = midx+xpt
            last_y = midy-ypt
        # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
        # 下列為齒頂圓上用來近似圓弧的直線
        create_line(lfx,lfy,rfx,rfy,fill=顏色)

gear(400,400,300,20,"blue")
&lt;/pre&gt;

&lt;p&gt;利用 Cango 程式庫, 繪製曲線與漸開線正齒輪輪廓:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cadlab.mde.tw/post/js/Cango2D.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cadlab.mde.tw/post/js/Cango-min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cadlab.mde.tw/post/js/gearUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://cadlab.mde.tw/post/js/CangoAnimation.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="gear1" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="gear1" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
''' data 印出來為:
M 代表 Move to, L 代表 Line to, C 代表 Curve to
參考: https://www.w3.org/TR/SVG11/paths.html
齒輪函式庫: http://cadlab.mde.tw/post/js/gearUtils.js
['M', 213.42546567394663, -26.249132721692735, 'L', 216.4771485764625, -26.59457489332413, 'C', 218.01364355836117, -26.670135871173535, 222.6241377296874, -26.675359459917235, 230.33407980945245, -24.786115738049222, 239.516053270179, -22.484881644156854, 252.57720520079252, -17.521220042103984, 268.1953141424361, -6.908892817203213, 'A', 268.2352941176471, 268.2352941176471, 0, 0, 1, 268.1953141424361, 6.908892817203213, 'C', 252.57720520079252, 17.521220042103984, 239.516053270179, 22.484881644156854, 230.33407980945245, 24.786115738049222, 222.6241377296874, 26.675359459917235, 218.01364355836117, 26.670135871173535, 216.4771485764625, 26.59457489332413, 'L', 213.42546567394663, 26.249132721692735, 'A', 10.588235294117652, 10.588235294117652, 0, 0, 0, 201.7022692356982, 34.938415176795026, 'A', 204.70588235294116, 204.70588235294116, 0, 0, 1, 200.70297598253308, 40.28416192067229, 'A', 10.588235294117652, 10.588235294117652, 0, 0, 0, 208.49560022899982, 52.62158351789785]
'''
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;利用 Brython 將漸開線正齒輪輪廓繪圖, 寫為 spur.py 模組:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#coding: utf-8
import math
# 導入數學函式後, 圓周率為 pi
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 以下為正齒輪繪圖
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 注意 n 為 52 齒時繪圖產生錯誤, 因為 base circle 與齒根圓大小未進行判斷, 必須要修正
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
&lt;/pre&gt;

&lt;p&gt;假如將 spur.py 放入 Brython 函式庫 Lib/site-packages 目錄中, 則使用者可以導入 spur.py 後進行&lt;a href="http://project-scrum2mdetw.rhcloud.com/mygeartest2"&gt;齒輪組輪廓繪圖&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
    &lt;script type="text/python"&gt;
    # 從 browser 導入 document
    from browser import document
    from math import *
    # 請注意, 這裡導入位於 Lib/site-packages 目錄下的 spur.py 檔案
    import spur

    # 準備在 id="plotarea" 的 canvas 中繪圖
    canvas = document["plotarea"]
    ctx = canvas.getContext("2d")

    # 以下利用 spur.py 程式進行繪圖, 接下來的協同設計運算必須要配合使用者的需求進行設計運算與繪圖
    # 其中並將工作分配給其他組員建立類似 spur.py 的相關零件繪圖模組
    # midx, midy 為齒輪圓心座標, rp 為節圓半徑, n 為齒數, pa 為壓力角, color 為線的顏色
    # Gear(midx, midy, rp, n=20, pa=20, color="black"):
    # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
    # 壓力角 pa 單位為角度
    pa = 20
    # m 為模數
    m = 20
    # 第1齒輪齒數
    n_g1 = 17
    # 第2齒輪齒數
    n_g2 = 11
    # 第3齒輪齒數
    n_g3 = 13
    # 計算兩齒輪的節圓半徑
    rp_g1 = m*n_g1/2
    rp_g2 = m*n_g2/2
    rp_g3 = m*n_g3/2

    # 繪圖第1齒輪的圓心座標
    x_g1 = 400
    y_g1 = 400
    # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
    x_g2 = x_g1 + rp_g1 + rp_g2
    y_g2 = y_g1
    # 第3齒輪的圓心座標
    x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
    y_g3 = y_g1

    # 將第1齒輪順時鐘轉 90 度
    # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
    ctx.save()
    # translate to the origin of second gear
    ctx.translate(x_g1, y_g1)
    # rotate to engage
    ctx.rotate(pi/2)
    # put it back
    ctx.translate(-x_g1, -y_g1)
    spur.Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
    ctx.restore()

    # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
    ctx.save()
    # translate to the origin of second gear
    ctx.translate(x_g2, y_g2)
    # rotate to engage
    ctx.rotate(-pi/2-pi/n_g2)
    # put it back
    ctx.translate(-x_g2, -y_g2)
    spur.Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
    ctx.restore()

    # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
    ctx.save()
    # translate to the origin of second gear
    ctx.translate(x_g3, y_g3)
    # rotate to engage
    # pi+pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
    # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
    # 第1個 -pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
    # -pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
    # (pi+pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
    # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
    # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
    ctx.rotate(-pi/2-pi/n_g3+(pi+pi/n_g2)*n_g2/n_g3)
    # put it back
    ctx.translate(-x_g3, -y_g3)
    spur.Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
    ctx.restore()

    # 按照上面三個正齒輪的囓合轉角運算, 隨後的傳動齒輪轉角便可依此類推, 完成6個齒輪的囓合繪圖
    &lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;利用 Pro/Web.Link 建立 PTC/Creo Parametric 網際參數繪圖範例:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
&lt;h1&gt;Creo 參數化零件&lt;/h1&gt;
&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;
document.writeln ("Error loading Pro/Web.Link header!");
&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;
if (!pfcIsWindows()) netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
var ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false);
if (!ret.Status) {
alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
//將 ProE 執行階段設為變數 session
var session = pfcGetProESession();
// 在視窗中打開零件檔案, 並且顯示出來
var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"));
var solid = session.GetModel("cube.prt",pfcCreate("pfcModelType").MDL_PART);
var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
// 將模型檔中的 length 變數設為 javascript 中的 length 變數
length = solid.GetParam("a1");
// 將模型檔中的 width 變數設為 javascript 中的 width 變數
width = solid.GetParam("a2");
//改變零件尺寸
//myf=20;
//myn=20;
volume=0;
count=0;
try
{
    // 以下採用 URL 輸入對應變數
    //createParametersFromArguments ();
    // 以下則直接利用 javascript 程式改變零件參數
    for(i=0;i&lt;=5;i++)
    {
        //for(j=0;j&lt;=2;j++)
        //{
            myf=100.0;
            myn=100.0+i*5.0;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
 d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
 d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);
// 將處理好的變數值, 指定給對應的零件變數
            length.Value = d1Value;
            width.Value = d2Value;
            //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
            solid.Regenerate(void null);
            //利用 GetMassProperty 取得模型的質量相關物件
            properties = solid.GetMassProperty(void null);
            //volume = volume + properties.Volume;
volume = properties.Volume;
            count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt");
if (!newfile.Status) {
alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
    } //外圈 for 迴圈
    //alert("共執行:"+count+"次,零件總體積:"+volume);
    //alert("零件體積:"+properties.Volume);
    //alert("零件體積取整數:"+Math.round(properties.Volume));
}
catch(err)
{
    alert ("Exception occurred: "+pfcGetExceptionType (err));
}
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://cd-cadp.rhcloud.com/get_page?heading=gear%20width%20Design"&gt;漸開線正齒輪減速機齒面寬設計運算與繪圖&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cd-cadp.rhcloud.com/get_page?heading=lego%20man%20assembly"&gt;樂高人偶以程式組立&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cd-cadp.rhcloud.com/get_page?heading=lego%20man2%20assembly"&gt;樂高人偶以程式組立 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;樂高人偶以程式組立範例:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
if (!pfcIsWindows())
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
var session = pfcGetProESession();
//建立擺放零件的位置矩陣
var identityMatrix = pfcCreate ("pfcMatrix3D");
for (var x = 0; x &lt; 4; x++)
for (var y = 0; y &lt; 4; y++)
{
if (x == y)
identityMatrix.Set (x, y, 1.0);
else
identityMatrix.Set (x, y, 0.0);
}
var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
//取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
//以目前已開檔, 作為 model
var model = session.CurrentModel;
//查驗有無 model, 或 model 類別是否為組立件
if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
var assembly = model;
function MAN_wai() {
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_waist.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        //0為組合匯入順序第一個
        var featID = components.Item(0).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;

        var asmDatums = new Array ("DTM4","DTM5","DTM6");
        var compDatums =new Array ("DTM1","DTM2","DTM3");
        var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 3; j++)
        {
        var asmItem = subassembly.GetItemByName (pfcCreate("pfcModelItemType").ITEM_SURFACE,asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[j]);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_1() {
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_body.prt");
// 若 link1.prt 在 session 則直接取用
var componentModel = session.GetModelFromDescr (descr);
//若 link1.prt 不在 session 則從工作目錄中載入 session
var componentModel = session.RetrieveModel(descr);
//若 link1.prt 已經在 session 則放入組立檔中
if (componentModel != void null)
{
//注意這個 asmcomp 即為設定約束條件的本體
//asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
//將指定的組件模型加到組立模組所指定的初始位置。
var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
//設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
var asmDatums = new Array ("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
//設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
var compDatums = new Array ("FRONT","TOP","RIGHT");
// 建立約束條件變數
var constrs = pfcCreate ("pfcComponentConstraints");
//利用迴圈分別約束組立與零件檔中的三個定位平面
for (var i = 0; i &lt; 3; i++)
{
//設定組立參考面 ，GetItemByName:存取指定模型項目名稱， 組立參考面:ASM_FRONT", "ASM_TOP", "ASM_RIGHT。
var asmItem = assembly.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE,asmDatums [i]);
//若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
if (asmItem == void null)
{
interactFlag = true;
continue;
}
//設定零件參考面，零件參考面:"FRONT","TOP","RIGHT"
var compItem = componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE,compDatums [i]);
//若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
if (compItem == void null)
{
interactFlag = true;
continue;
}
//建立 ids 變數, intseq 為 sequence of integers 為資料類別,使用者可以經由整數索引擷取此資料類別的元件,第一個索引為 0
var ids = pfcCreate ("intseq");
//建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
var path = pfcCreate ("MpfcAssembly").CreateComponentPath (assembly,ids);
//採用互動式設定相關的變數
var MpfcSelect = pfcCreate ("MpfcSelect");
//屬於 asmSel 的 asmItem 參考面。
var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, path);
//屬於 compSel 的 compItem 參考面。
var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
//constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
var constr = pfcCreate ("pfcComponentConstraint").Create ( pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
//組立基準
constr.AssemblyReference = asmSel;
//放置組件的基準。
constr.ComponentReference = compSel;
//約束屬性
constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (false, false);
//將互動選擇相關資料, 附加在程式約束變數之後
constrs.Append (constr);
}
//設定組立約束條件，(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)。
asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_h() {
        var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_head.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        var featID = components.Item(0).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;
        var asmDatums = new Array ("A_16","DTM3");
        var compDatums =new Array ("A_2","DTM1");
        var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[j]);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_la() {
        var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_arm_lt.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        var featID = components.Item(0).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;
        var asmDatums = new Array ("A_15","DTM2");
        var compDatums =new Array ("A_7","TOP");
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_lh(){
        var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_hand.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        var featID = components.Item(2).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;
        var asmDatums = new Array ("A_8","DTM1");
        var compDatums =new Array ("A_1","DTM3");
        var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[j]);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_rh(){
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_hand.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        var featID = components.Item(1).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;
        var asmDatums = new Array ("A_10","DTM1");
        var compDatums =new Array ("A_1","DTM3");
        var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[j]);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_ll(){
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_leg_lt.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        //0為組合匯入順序第一個
        var featID = components.Item(5).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;

        var asmDatums = new Array ("A_8","DTM4");
        var compDatums =new Array ("A_10","DTM1");
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_ra(){
        var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_arm_rt.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        var featID = components.Item(0).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;
        var asmDatums = new Array ("A_14","DTM1");
        var compDatums =new Array ("A_9","TOP");
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_rl(){
        var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_leg_rt.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        //0為組合匯入順序第一個
        var featID = components.Item(5).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;

        var asmDatums = new Array ("A_8","DTM5");
        var compDatums =new Array ("A_10","DTM1");
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function MAN_hat(){
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("lego_hat.prt");
        // 若 link1.prt 在 session 則直接取用
        var componentModel = session.GetModelFromDescr (descr);
        //若 link1.prt 不在 session 則從工作目錄中載入 session
        var componentModel = session.RetrieveModel(descr);
        //若 link1.prt 已經在 session 則放入組立檔中
        if (componentModel != void null)
        {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
        var ids = pfcCreate ("intseq");
        //回傳序列模型中的功能，True:該功能只列出公共功能。
        var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
        //取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
        var featID = components.Item(3).Id;
        ids.Append(featID);
        //在 assembly 模型中建立子零件所對應的路徑
        //建立路徑變數，CreateComponentPath:回傳組件的路徑物件，把組立模型和的ID路徑給所需的組件。
        var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
        document.write("id 為:"+subPath.ComponentIds(0));
        //回傳實體模型，最後的組件路徑
        subassembly = subPath.Leaf;
        var asmDatums = new Array ("A_2","TOP");
        var compDatums =new Array ("A_2","FRONT");
        var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
        var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
        //建立約束條件變數
        var constrs = pfcCreate ("pfcComponentConstraints");
        for(var j = 0; j &lt; 2; j++)
        {
        var asmItem = subassembly.GetItemByName (relationItem[j],asmDatums [j]);
        //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
        if (asmItem == void null)
        {
        interactFlag = true;
        }
        //設定零件參考面, compItem 為 model item，零件參考面:"FRONT","TOP","RIGHT"
        var compItem = componentModel.GetItemByName (relationItem[j], compDatums [j]);
        //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
        if (compItem == void null)
        {
        interactFlag = true;
        }
        //採用互動式設定相關的變數
        var MpfcSelect = pfcCreate ("MpfcSelect");
        //屬於 asmSel 的 asmItem 參考面。
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        //屬於 compSel 的 compItem 參考面。
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        //constr約束方式，ASM_CONSTRAINT_ALIGN 貼齊
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[j]);
        //組立基準
        constr.AssemblyReference = asmSel;
        //放置組件的基準。
        constr.ComponentReference = compSel;
        //約束屬性
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true , false);
        //將互動選擇相關資料, 附加在程式約束變數之後
        constrs.Append (constr);
        }
        //設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
        //請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
        //(約束的組件,void null:如果約束只適用於組件，參數的值應該是空的)
        asmcomp.SetConstraints (constrs, void null);
try
{
document.write("目前 Creo 的工作目錄:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
}
function main() {
MAN_1();
MAN_ra();
MAN_la();
MAN_h();
MAN_hat();
MAN_wai();
MAN_rh();
MAN_lh();
MAN_ll();
MAN_rl();
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();
}
&lt;form&gt;
&lt;p&gt;&lt;input onclick="main()" type="button" value="Start assembly"&gt;?&lt;/p&gt;
&lt;/form&gt;
&lt;/pre&gt;

&lt;p&gt;nutcracker 程式組立範例:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
if (!pfcIsWindows())
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
var session = pfcGetProESession();
// 設定 config option
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣
var identityMatrix = pfcCreate ("pfcMatrix3D");
for (var x = 0; x &lt; 4; x++)
    for (var y = 0; y &lt; 4; y++)
    {
        if (x == y)
            identityMatrix.Set (x, y, 1.0);
        else
            identityMatrix.Set (x, y, 0.0);
    }
var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件
if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
var assembly = model;

/**----------------------------------------------- fix -------------------------------------------------------------**/

    var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("nutcracker/fix.prt");
    // 若 link1.prt 在 session 則直接取用
    var componentModel = session.GetModelFromDescr (descr);
    //若 link1.prt 不在 session 則從工作目錄中載入 session
    var componentModel = session.RetrieveModel(descr);
    //若 link1.prt 已經在 session 則放入組立檔中
    if (componentModel != void null)
    {
        //注意這個 asmcomp 即為設定約束條件的本體
        //asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
        var asmcomp = assembly.AssembleComponent (componentModel, transf);
    }

// 建立約束條件變數
var constrs = pfcCreate ("pfcComponentConstraints");
//設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
var asmDatums = new Array ("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
//設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
var compDatums = new Array ("FRONT", "TOP", "RIGHT");
    //建立 ids 變數, intseq 為 sequence of integers 為資料類別, 使用者可以經由整數索引擷取此資料類別的元件, 第一個索引為 0
    var ids = pfcCreate ("intseq");
    //建立路徑變數
    var path = pfcCreate ("MpfcAssembly").CreateComponentPath (assembly, ids);
    //採用互動式設定相關的變數
    var MpfcSelect = pfcCreate ("MpfcSelect");
//利用迴圈分別約束組立與零件檔中的三個定位平面
for (var i = 0; i &lt; 3; i++)
{
    //設定組立參考面
    var asmItem = assembly.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, asmDatums [i]);
    //若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    //設定零件參考面
    var compItem = componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, compDatums [i]);
    //若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, path);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (false, false);
    //將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append (constr);
}

//設定組立約束條件
asmcomp.SetConstraints (constrs, void null);
/**-------------------------------------------------------------------------------------------------------------------**/

/**----------------------------------------------- fixture -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("nutcracker/fixture.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var featID = components.Item(0).Id;

ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2", "RIGHT");
var compDatums = new Array ("A_3", "DTM1");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
        constrs.Append (constr);
    }
asmcomp.SetConstraints (constrs, void null);


/**-------------------------------------------------------------------------------------------------------------------**/

/**----------------------------------------------- cracker -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("nutcracker/cracker.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate ("intseq");
ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_4");
var compDatums = new Array ("A_1");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 1; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
        constrs.Append (constr);
    }
asmcomp.SetConstraints (constrs, void null);

/**-------------------------------------------------------------------------------------------------------------------**/

/**----------------------------------------------- link -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("nutcracker/link.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate ("intseq");
ids.Append(featID+2);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2","DTM1");
var compDatums = new Array ("A_1","DTM1");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
        constrs.Append (constr);
    }
asmcomp.SetConstraints (constrs, void null);



/**-------------------------------------------------------------------------------------------------------------------**/


/**----------------------------------------------- handle -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("nutcracker/handle.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");

var ids = pfcCreate ("intseq");
ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_3","DTM3");
var compDatums = new Array ("A_1","DTM1");
for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
        constrs.Append (constr);
    }
asmcomp.SetConstraints (constrs, void null);


var ids = pfcCreate ("intseq");

ids.Append(featID+3);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2", "DTM1");
var compDatums = new Array ("A_2", "DTM1");
for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, true);
        constrs.Append (constr);
    }
asmcomp.SetConstraints (constrs, void null);

/**-------------------------------------------------------------------------------------------------------------------**/
var session = pfcGetProESession ();
var solid = session.CurrentModel;

properties = solid.GetMassProperty(void null);
var COG = properties.GravityCenter;

document.write("MassProperty:&lt;br /&gt;");
document.write("Mass:"+(properties.Mass.toFixed(2))+"       pound&lt;br /&gt;");
document.write("Average Density:"+(properties.Density.toFixed(2))+"       pound/inch^3&lt;br /&gt;");
document.write("Surface area:"+(properties.SurfaceArea.toFixed(2))+"           inch^2&lt;br /&gt;");
document.write("Volume:"+(properties.Volume.toFixed(2))+"   inch^3&lt;br /&gt;");
document.write("COG_X:"+COG.Item(0).toFixed(2)+"&lt;br /&gt;");
document.write("COG_Y:"+COG.Item(1).toFixed(2)+"&lt;br /&gt;");
document.write("COG_Z:"+COG.Item(2).toFixed(2)+"&lt;br /&gt;");

try
{
document.write("Current Directory:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();
&lt;/pre&gt;

&lt;p&gt;PTC Creo Parametric 程式組立 &lt;a href="http://cd-cadp.rhcloud.com/get_page?heading=Creo%20Pro/Web.Link"&gt;Pro/Web.Link 相關參考檔案&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>使用 flask-cors 延伸模組</title><link href="./shi-yong-flask-cors-yan-shen-mo-zu.html" rel="alternate"></link><updated>2016-04-30T15:10:57+08:00</updated><author><name>kmol</name></author><id>tag:,2016-04-30:./shi-yong-flask-cors-yan-shen-mo-zu.html</id><summary type="html">&lt;p&gt;在 &lt;a href="wang-ji-kua-lai-yuan-zi-yuan-gong-xiang-2d-ling-jian-hui-tu.html"&gt;網際跨來源資源共享 2D 零件繪圖&lt;/a&gt;中, 我們已經利用 flask 的 make_response 送出跨網址 ajax 導入資源的方法, 其中因為目前的 make_response 函式只能接受單一字串的 origins, 所以若需要同時支援 http://localhost:5000 與某一廣域的網址擷取程式段, 通常採用 response.headers['Access-Control-Allow-Origin'] = '*' 處理, 也就是允許所有的主機呼叫, 並使用對應函式所提供的 ajax 資源.&lt;/p&gt;


&lt;p&gt;假如使用 flask 框架, 並且希望明確指定多台 ajax 資源共享的網址, 則可以使用 flask-cors 延伸模組 (這裡以 flask-cors 2.1.2 版為例).&lt;/p&gt;
&lt;p&gt;flask-cors 延伸模組的安裝共有三種情況:&lt;/p&gt;
&lt;p&gt;假如是在 Windows 可攜 Python3 程式環境, 可以直接利用 pip install flask-cors 安裝.&lt;/p&gt;
&lt;p&gt;假如是在 16.04 版之前的 Ubuntu (因為 Python2 與 Python3 共存),使用 必須使用 pip3 install flask-cors 安裝.&lt;/p&gt;
&lt;p&gt;假如使用 OpenShift 雲端平台上的 Python3 應用程式, 則利用 setup.py 指定安裝 flask-cors 延伸模組.&lt;/p&gt;
&lt;p&gt;實際操作時, 則必須先導入 flask.ext.cors 模組中的 cross_origin decorator 方法.&lt;/p&gt;
&lt;p&gt;from flask.ext.cors import cross_origin&lt;/p&gt;
&lt;p&gt;然後在對應的協同繪圖函式中, 指定可以引用的網址, 例如, 允許 localhost 與 cdw2-ag100.rhcloud.com 擷取繪圖程式段的範例:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# 畫 C 函式
@scrum1_task1.route('/scrum1_week8_c')
@cross_origin(origins=['http://localhost', 'http://cdw2-ag100.rhcloud.com'], allow_headers=['Content-Type'])
def week8_c():
    outstring = '''
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 C
# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0, color="red")
'''
    return outstring
&lt;/pre&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category><category term="CORS"></category><category term="flask-cors"></category></entry><entry><title>網際跨來源資源共享 2D 零件繪圖</title><link href="./wang-ji-kua-lai-yuan-zi-yuan-gong-xiang-2d-ling-jian-hui-tu.html" rel="alternate"></link><updated>2016-04-23T00:28:47+08:00</updated><author><name>kmol</name></author><id>tag:,2016-04-23:./wang-ji-kua-lai-yuan-zi-yuan-gong-xiang-2d-ling-jian-hui-tu.html</id><summary type="html">&lt;p&gt;跨來源資源共享 (Cross-Origin Resource Sharing): &lt;a href="https://www.w3.org/TR/cors/"&gt;https://www.w3.org/TR/cors/&lt;/a&gt; 機制是本地端從多個伺服器分別取得相關資源後, 以其中某一個伺服器的內容為主體進行近端程式執行的架構, 就協同機械設計流程而言, 可以應用在工程師與工程師之間的 2D 與 3D 零組件繪圖.&lt;/p&gt;


&lt;p&gt;此地的 2D 零件繪圖以 &lt;a href="http://www.brython.info/"&gt;Brython&lt;/a&gt; 加上 &lt;a href="http://2015fallhw.github.io/arcidau/"&gt;Cango&lt;/a&gt; Javascript 繪圖程式庫為例, 而 3D 零件繪圖則希望以 PTC Creo Parametric 的 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=1507"&gt;Pro/Web.Link&lt;/a&gt; 二次開發進行練習.&lt;/p&gt;
&lt;p&gt;以下將以 ag100 與 ladisai 等兩個網站的 2D 鏈條零件協同繪圖說明 Cross-Origin Resource Sharing 的用法.&lt;/p&gt;
&lt;p&gt;ag100 用戶對應的網站為 cdw2-ag100.rhcloud.com 而 ladisai 用戶對應的網站則為 cdw2-ladisai.rhcloud.com, 其中兩個網站都有 /ag100/scrum1_week8_abcd 繪圖函式, 其中 &lt;a href="http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_abcd"&gt;http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_abcd&lt;/a&gt; 零件繪圖, A 與 B 鏈條由 ag100 主體程式進行繪圖, 而 C 與 D 則交由 ladisai 用戶的網站提供. 因此 &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_c"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_c&lt;/a&gt; 與 &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_d"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_d&lt;/a&gt; 繪圖網站內容送出時, 必須指名可以讓 ag100 的對應網站進行跨來源呼叫, 也就是必須利用 flask 指定 response.headers['Access-Control-Allow-Origin'] = 'http://cdw2-ag100.rhcloud.com'.&lt;/p&gt;
&lt;p&gt;利用瀏覽器開發工具檢視 &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_c"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_c&lt;/a&gt; 所送出的 header 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/cdw2_ladisai_week8_c_cors.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;相同原理, &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_abcd"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_abcd&lt;/a&gt; 零件繪圖, C 與 D 鏈條由 ladisai 主體程式進行繪圖, 而 A 與 B 則交由 ag100 用戶的網站提供, 因此, &lt;a href="http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_a"&gt;http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_a&lt;/a&gt; 與 &lt;a href="http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_b"&gt;http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_b&lt;/a&gt; 繪圖網站內容送出時, 必須指名可以讓 ladisai 的對應網站進行跨來源呼叫, 也就是必須利用 flask 指定 response.headers['Access-Control-Allow-Origin'] = 'http://cdw2-ladisai.rhcloud.com'.&lt;/p&gt;
&lt;p&gt;利用瀏覽器開發工具檢視 &lt;a href="http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_a"&gt;http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_a&lt;/a&gt; 所送出的 header 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/cdw2_ag100_week8_a_cors.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下就是 &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_abcd"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_abcd&lt;/a&gt; 繪圖的對應原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# on cdw2-ladisai.rhcloud.com
@scrum1_task1.route('/scrum1_week8_abcd')
def week8_abcd():
    outstring = week8_main()
    #outstring += "&lt;script type='text/python' src='/ag100/scrum1_week8_a'&gt;&lt;/script&gt;"
    #outstring += "&lt;script type='text/python' src='/ag100/scrum1_week8_b'&gt;&lt;/script&gt;"
    outstring += "&lt;script type='text/python' src='http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_a'&gt;&lt;/script&gt;"
    outstring += "&lt;script type='text/python' src='http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_b'&gt;&lt;/script&gt;"
    outstring += "&lt;script type='text/python' src='/ag100/scrum1_week8_c'&gt;&lt;/script&gt;"
    outstring += "&lt;script type='text/python' src='/ag100/scrum1_week8_d'&gt;&lt;/script&gt;"
    outstring += week8_tail()
    return outstring
&lt;/pre&gt;

&lt;p&gt;其中包含主體程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# on cdw2-ladisai.rhcloud.com
def week8_main():
    outstring = '''
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 2D 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id="plotarea2" width="800" height="800"&amp;gt;&amp;lt;/canvas&amp;gt;
'''
    return outstring
&lt;/pre&gt;

&lt;p&gt;超文件收尾程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# on cdw2-ladisai.rhcloud.com
@scrum1_task1.route('/scrum1_week8_tail')
def week8_tail():
    return "&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;"
&lt;/pre&gt;

&lt;p&gt;ag100 網站繪製 A 的函式, 必須在標頭送出 response.headers['Access-Control-Allow-Origin'] = 'http://cdw2-ladisai.rhcloud.com', 才能讓 ladisai 網站跨來源呼叫.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# on cdw2-ag100.rhcloud.com
# 必須要 from flask import make_response
@scrum1_task1.route('/scrum1_week8_a')
def week8_a():
    outstring = '''
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot(0, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1, color="red")
'''
    response = make_response(outstring)
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    response.headers['Access-Control-Allow-Origin'] = 'http://cdw2-ladisai.rhcloud.com'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'
    response.headers['Access-Control-Max-Age'] = '86400'
    return response
&lt;/pre&gt;

&lt;p&gt;ag100 網站繪製 B 的函式, 必須在標頭送出 response.headers['Access-Control-Allow-Origin'] = 'http://cdw2-ladisai.rhcloud.com', 才能讓 ladisai 網站跨來源呼叫.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# on cdw2-ag100.rhcloud.com
# 必須要 from flask import make_response
@scrum1_task1.route('/scrum1_week8_b')
def week8_b():
    outstring = '''
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 B
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, 0, 0, color="red")
'''
    response = make_response(outstring)
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    response.headers['Access-Control-Allow-Origin'] = 'http://cdw2-ladisai.rhcloud.com'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'
    response.headers['Access-Control-Max-Age'] = '86400'
    return response
&lt;/pre&gt;

&lt;p&gt;最後, 配合送到 ag100 主機的 scrum1_task1.py 程式版本: &lt;a href="https://github.com/2015fallhw/cdw2/blob/6aed4cad87f21317c1f337dcf4d1dfec9a06277c/users/s2a/g100/scrum1_task1.py"&gt;https://github.com/2015fallhw/cdw2/blob/6aed4cad87f21317c1f337dcf4d1dfec9a06277c/users/s2a/g100/scrum1_task1.py&lt;/a&gt;, 與之前未採用跨主機的程式呼叫差異, 分別為從 flask 模組導入 make_response 函式, 以及透過 response 介入傳送特定 Cross-Origin Resources Sharing  所需的 headers.&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category><category term="CORS"></category></entry><entry><title>2016Spring 課程期中自評</title><link href="./2016spring-ke-cheng-qi-zhong-zi-ping.html" rel="alternate"></link><updated>2016-04-17T22:05:45+08:00</updated><author><name>kmol</name></author><id>tag:,2016-04-17:./2016spring-ke-cheng-qi-zhong-zi-ping.html</id><summary type="html">&lt;p&gt;本學期各班課程將依照下列時程規劃, 完成所有學員的期中自評工作.&lt;/p&gt;


&lt;p&gt;協同產品設計實習課程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;期中自評的任務描述: &lt;a href="http://chiamingyen.github.io/kmolab/blog/xie-tong-chan-pin-she-ji-shi-xi-de-wang-ji-2d-xie-tong-hui-tu.html"&gt;on kmolab&lt;/a&gt; 加上 &lt;a href="https://github.com/2015fallhw/cdw2/wiki/2016spring-CD-%E6%9C%9F%E4%B8%AD%E5%A0%B1%E5%91%8A%E5%85%A7%E5%AE%B9"&gt;on cdw2 wiki&lt;/a&gt; 的補充說明.&lt;/li&gt;

&lt;li&gt;自評要求: 各學員自評分數與依據內容必須呈現在 &lt;a href="http://2015fallhw.github.io/cdw2/"&gt;http://2015fallhw.github.io/cdw2/&lt;/a&gt; (自評查驗將透過 Tags-&gt;學員學號進行) 以及期限內所指定的即時試算表上 (2a 期限為 2016.04.25 (一) 下課前, 2b 期限為 2016.04.21 (四) 下課前, 期中成績將在 2016.04.29 (五) 中午前送出, 期中成績評定為不及格學員, 申請最後 review 期限為第十二週上課結束前).&lt;/li&gt;
&lt;li&gt; 各組員的自評內容必須包括: 自評成績, 期中報告操作流程介紹, 期中報告心得, 以及期中報告內容參考連結等.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;網際內容管理:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;期中自評的任務描述: &lt;a href="https://cmsimply-cadlab.rhcloud.com/get_page?heading=2016springwcm"&gt;第七週到第九週自評&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;自評要求: 各學員自評分數與依據內容必須呈現在 &lt;a href="http://wp-ladisai.rhcloud.com/"&gt;http://wp-ladisai.rhcloud.com/&lt;/a&gt; 以及期限內所指定的即時試算表上 (1a 期限為 2016.04.22 (五) 下課前, 期中成績將在 2016.04.29 (五) 中午前送出, 期中成績評定為不及格學員, 申請最後 review 期限為第十二週上課結束前).&lt;/li&gt;
&lt;li&gt; 各組員的自評內容必須包括: 自評成績, 期中報告操作流程介紹, 期中報告心得, 以及期中報告內容參考連結等.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category><category term="網際內容管理"></category></entry><entry><title>2D 鏈條零組件繪圖</title><link href="./2d-lian-tiao-ling-zu-jian-hui-tu.html" rel="alternate"></link><updated>2016-04-14T18:58:57+08:00</updated><author><name>kmol</name></author><id>tag:,2016-04-14:./2d-lian-tiao-ling-zu-jian-hui-tu.html</id><summary type="html">&lt;p&gt;2D 鏈條輪廓繪圖的目的在讓學員了解如何透過數值運算與程式技巧, 完成產品開發流程中所被交付的零組件繪圖.&lt;/p&gt;


&lt;p&gt;何謂 &lt;a href="https://zh.wikipedia.org/wiki/Atan2"&gt;atan2()&lt;/a&gt; 函數？&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.python-course.eu/python3_object_oriented_programming.php"&gt;Python3 物件導向&lt;/a&gt;程式方法.&lt;/p&gt;
&lt;pre class="brush: xml"&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;title&amp;gt;網際 2D 繪圖&amp;lt;/title&amp;gt;
    &amp;lt;!-- IE 9: display inline SVG --&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=9"&amp;gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
window.onload=function(){
brython(1);
}
&amp;lt;/script&amp;gt;

&amp;lt;canvas id="plotarea2" width="800" height="800"&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setWorldCoords(-250, -250, 500, 500) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot(0, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1, color="red")

# 畫 B
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, 0, 0, color="red")

# 畫 C
# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0, color="red")


# 畫 D
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+65*3, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -40 度
x6, y6 = mychain.basic_rot(x5, y5, -40)
x7, y7 = mychain.basic_rot(x6, y6, -60)
# 右中垂直向下單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
# -120 度
x9, y9 = mychain.basic_rot(x8, y8, -120)
# -140
x10, y10 = mychain.basic_rot(x9, y9, -140)
# 水平接回原點
mychain.basic(x10, y10, 0+65*3, 0, color="red")
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;繪圖結果如下:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea2" width="800" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import alert
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea2")

cgo.setGridboxRHC(10, 10, 100, 100)
cgo.fillGridbox("lightyellow")
cgo.setWorldCoords(-10, -10, 300, 300) 

# 畫軸線
cgo.drawAxes(0, 240, 0, 240, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 20,
    "xLabelInterval": 20,
    "yTickInterval": 20,
    "yLabelInterval": 20})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(y2-y1, x2-x1)/deg+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=1):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgo.Chamber 為成員變數
        cmbr = cobj(self.cgoChamber, "SHAPE", {
                "fillColor": color,
                "border": border,
                "strokeColor": "tan",
                "lineWidth": linewidth })

        # hole 為原點位置
        hole = cobj(shapedefs.circle(4), "PATH")
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = x1 + 20*math.cos(rot*deg)
        y2 = y1 + 20*math.sin(rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(rot+90)

        # 放大 scale 倍
        cgo.render(basic1, x1, y1, scale, 0)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot(0, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1, color="red")

# 畫 B
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, 0, 0, color="red")

# 畫 C
# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0, color="red")


# 畫 D
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+65*3, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -40 度
x6, y6 = mychain.basic_rot(x5, y5, -40)
x7, y7 = mychain.basic_rot(x6, y6, -60)
# 右中垂直向下單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
# -120 度
x9, y9 = mychain.basic_rot(x8, y8, -120)
# -140
x10, y10 = mychain.basic_rot(x9, y9, -140)
# 水平接回原點
mychain.basic(x10, y10, 0+65*3, 0, color="red")
&lt;/script&gt;

&lt;p&gt;將上述程式拆解成 scrum1 與 scrum2 兩人協同繪圖的結果:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_abc"&gt;http://cdw2-ag100.rhcloud.com/ag100/scrum1_week8_abc&lt;/a&gt; 與 &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_abc"&gt;http://cdw2-ladisai.rhcloud.com/ag100/scrum1_week8_abc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;版本程式的 scrum1_task1.py: &lt;a href="https://github.com/2015fallhw/cdw2/blob/6622e2381ebb3c6f1116e5bf63096a8d74122ec7/users/s2a/g100/scrum1_task1.py"&gt;https://github.com/2015fallhw/cdw2/blob/6622e2381ebb3c6f1116e5bf63096a8d74122ec7/users/s2a/g100/scrum1_task1.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;版本程式的 scrum2_task2.py: &lt;a href="https://github.com/2015fallhw/cdw2/blob/6622e2381ebb3c6f1116e5bf63096a8d74122ec7/users/s2a/g100/scrum2_task1.py"&gt;https://github.com/2015fallhw/cdw2/blob/6622e2381ebb3c6f1116e5bf63096a8d74122ec7/users/s2a/g100/scrum2_task1.py&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>任務一 2D 協同繪圖之二</title><link href="./ren-wu-yi-2d-xie-tong-hui-tu-zhi-er.html" rel="alternate"></link><updated>2016-03-30T23:59:43+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-30:./ren-wu-yi-2d-xie-tong-hui-tu-zhi-er.html</id><summary type="html">&lt;p&gt;這裡要介紹的是 scrum-2 組員利用 forked cdw2 倉儲版本, git clone 到近端後, 以 git checkout gh-pages 轉到 Github Pages 對應的網頁資料上工作.&lt;/p&gt;


&lt;p&gt;在 users/s2a/g100 目錄下建立 scrum2.leo 後, 就利用 Leo Editor 在 content 目錄中, 建立 .md 檔案, 完成後先在近端利用 local-pelican 測試結果, 若能夠正確轉換 Pelican post 目錄中的網誌, 就可以再用 gh-pages-pelican 按鈕, 將 post 目錄中轉成遠端網頁所需要的格式 (主要是讓 disqus 留言系統可以正常運作).&lt;/p&gt;
&lt;p&gt;然後 scrum-2 用戶就可以利用 git add -A, git commit -m "提交註記訊息", 以及 git push origin gh-pages 將近端的版本提交推送到 scrum-2 自己 forked 的 cdw2 倉儲.&lt;/p&gt;
&lt;p&gt;接著, scrum-2 用戶就必須登入到 github, 然後從自己帳號下的 scrum-2/cdw2 倉儲中建立 pull request.&lt;/p&gt;
&lt;p&gt;因為 scrum-2 要將 gh-pages 分支的資料版本, 以拉回請求 (pull request) 的方式送到 2015fallhw/cdw2 倉儲, 而這項請求, 必須由 ag100 的組長來進行檢查並且設法完成版本的衝突解決與合併.&lt;/p&gt;
&lt;p&gt;建立 pull request 時, scrum-2 必須確定基底互刻 (base fork) 為 2015fallhw/cdw2 倉儲中的 gh-pages 分支, 而標頭互刻 (head fork) 則為 scrum-2/cdw2 倉儲中的 gh-pages 分支, 其間 Github 還特別顯示 "Can't automatically merge", 表示這個拉回請求無法自動合併, scrum-1 組長必須要採用手動合併.&lt;/p&gt;
&lt;p&gt;接著 scrum-2 組員按下 Create pull request 按鈕, 並在 comment 表單中寫下此一拉回請求的改版要點, 完成後的請求連結為 &lt;a href="https://github.com/2015fallhw/cdw2/pull/169"&gt;https://github.com/2015fallhw/cdw2/pull/169&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;接下來的 pull request 審核與合併工作就落在 scrum-1 組長的身上, scrum-1 登入 Github 後, 進入 2015fallhw/cdw2 倉儲. 點下 &lt;a href="https://github.com/2015fallhw/cdw2/pull/169"&gt;https://github.com/2015fallhw/cdw2/pull/169&lt;/a&gt; pull request.&lt;/p&gt;
&lt;p&gt;這時可以看到 "This branch has conflicts that must be resolved", 表示 scrum-1 必須手動處理衝突與合併.&lt;/p&gt;
&lt;p&gt;假如 scrum-1 近端沒有 &lt;a href="https://github.com/2015fallhw/cdw2.git"&gt;https://github.com/2015fallhw/cdw2.git&lt;/a&gt; 倉儲的版本資料, 必須要利用 git clone 複製到本地端, 然後確定分支指在 gh-pages 分支上.&lt;/p&gt;
&lt;p&gt;Github 針對此一流程, 建立的基本步驟如下:&lt;/p&gt;
&lt;pre&gt;
Step 1: From your project repository, check out a new branch and test the changes.

git checkout -b scrum-2-gh-pages gh-pages
git pull https://github.com/scrum-2/cdw2.git gh-pages

Step 2: Merge the changes and update on GitHub.

git checkout gh-pages
git merge --no-ff scrum-2-gh-pages
git push origin gh-pages
&lt;/pre&gt;

&lt;p&gt;有關 git checkout 指令, 使用 -b 表示要利用 git branch 建立新分支 scrum-2-gh-pages, 同時切換到該分支, 至於 start-point 指的是該新建立的分支, 其對應分支起點為 gh-pages. 假如 scrum-1 近端的倉儲資料已經在之前使用 -b 建立過 scrum-2-gh-pages 分支, 且 start-point 設為 gh-pages 分支, 則必須改用 git checkout  scrum-2-gh-pages&lt;/p&gt;
&lt;p&gt;接著執行 git pull https://github.com/scrum-2/cdw2.git gh-pages, 拉回 scrum-2/cdw2 的 gh-pages 分支版本資料, 這時 users/s2a/g100/scrum2.leo 因為無法自動合併而無法從 Leo Editor 開啟, 必須用純文字編輯器打開後解決衝突.&lt;/p&gt;
&lt;p&gt;開啟 scrum2.leo 後, 看到的第1段衝突為:&lt;/p&gt;
&lt;pre&gt;
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
&lt;v t="amd.20160329174139.1"&gt;&lt;vh&gt;@clean scrum2-20160330.md&lt;/vh&gt;&lt;/v&gt;
&lt;v t="amd.20160330205248.1"&gt;&lt;vh&gt;@clean scrum2-20160330-1.md&lt;/vh&gt;&lt;/v&gt;
=======
&lt;v t="amd.20160329174139.1"&gt;&lt;vh&gt;@clean scrum2-20160330-2.md&lt;/vh&gt;&lt;/v&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 61b5812abdc9cdb907dbd1b865194e5bdb70bbdf
&lt;/pre&gt;

&lt;p&gt;表示 scrum-1 近端版本有 @clean scrum2-20160330.md 與 @clean scrum2-20160330-1.md 等兩個節點, 而 scrum-2 pull request 的版本則有 @clean scrum2-20160330-2.md 節點, 這裡必須保留這3個分別建立網誌文章的 .md 檔案, 因此刪除衝突標示符號後即可.&lt;/p&gt;
&lt;p&gt;過程中 scrum-1 組長可以根據 content 目錄中的組員對應 .md 檔案來解決 .leo 檔案中的衝突, 同時各組員也必須經常利用反向的 pull request, 儘量自行在 task 1 任務執行期間跟上 2015fallhw/cdw2 的最新版本, 才能減少組長審查組員 pull request 的版本差異.&lt;/p&gt;
&lt;p&gt;完成 scrum-2 pull request  版本的合併後, scrum-1 必須利用近端與遠端按鈕建立 Pelican 網誌後, 進行近端的版本提交, git add -A 與 git commit -m "提交訊息", 之後繼續執行 scrum-2-gh-pages 與 gh-pages 分支版本的合併.&lt;/p&gt;
&lt;p&gt;先利用 git checkout gh-pages 將分支轉為 gh-pages, 然後執行的指令為 git merge --no-ff scrum-2-gh-pages, 其中的 --no-ff 表示合併時不使用快進 (fast-forward) 模式. 而是考量互刻 (fork) 分支後, 2015fallhw/cdw2 的版本可能已經被其他協同組員改版, 必須將這些版本資料納入合併.&lt;/p&gt;
&lt;p&gt;接著必須要再利用近端與遠端按鈕進行 post 目錄中網誌資料的轉檔後, 就可以提交推送到遠端的 cdw2 倉儲 gh-pages 分支.&lt;/p&gt;
&lt;p&gt;步驟為:&lt;/p&gt;
&lt;p&gt;git add -A&lt;/p&gt;
&lt;p&gt;git commit -m "提交訊息"&lt;/p&gt;
&lt;p&gt;git push origin gh-pages&lt;/p&gt;
&lt;p&gt;最後, 當組長 scrum-1 完成  scrum-2 pull request 的合併後, scrum-2 就可以利用反向 pull request 更新 scrum-2/cdw2 gh-pages 分支上的版本資料.&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>任務一 2D 協同繪圖</title><link href="./ren-wu-yi-2d-xie-tong-hui-tu.html" rel="alternate"></link><updated>2016-03-30T00:44:15+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-30:./ren-wu-yi-2d-xie-tong-hui-tu.html</id><summary type="html">&lt;p&gt;假設 2a CD 課程中有第 100 組, 由四位組員: scrum-1, scrum-2,  scrum-3 與 scrum-4 所組成, 且 scrum-1 為組長. 在協同產品設計課程中, scrum-1 將會是 cdw2 倉儲的 collaborator, 可以直接將本地端的 CDW2 倉儲版本資料提交推送到遠端, 其餘三人則必須透過 Pull Requests 進行協同.&lt;/p&gt;


&lt;p&gt;scrum-1 可以直接 git clone cdw2, 然後改版提交推送, 其他組員參與協同的方法都是先根據 &lt;a href="http://chiamingyen.github.io/kmolab/blog/xie-tong-chan-pin-she-ji-shi-xi-de-wang-ji-2d-xie-tong-hui-tu.html"&gt;http://chiamingyen.github.io/kmolab/blog/xie-tong-chan-pin-she-ji-shi-xi-de-wang-ji-2d-xie-tong-hui-tu.html&lt;/a&gt; 中的說明. 登入 Github 後, 以瀏覽器連結到 &lt;a href="https://github.com/2015fallhw/cdw2"&gt;https://github.com/2015fallhw/cdw2&lt;/a&gt; 後, 按一下右上方的  Fork 鍵後, 就可建立與原始倉儲互有關聯的"互刻"內容.&lt;/p&gt;
&lt;p&gt;scrum-1 git clone cdw2 倉儲後, 可以在本地端就工作目錄中的內容進行處理. 由於現在 cdw2 倉儲中的 master 與 gh-pages 已經徹底分離, master 分支主要用來執行 Python3 wsgi 程式, 而 gh-pages 分支則要協同各組回報的資料, 以 Github Pages 的網頁呈現.&lt;/p&gt;
&lt;p&gt;在 cdw2 master 分支上的工作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;git clone cdw2 倉儲, 以 git branch 指令確定工作目錄中的資料為 master 分支.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 users/s2a/g100 分組目錄中, 建立 scrum1.leo, 主要目的建立 scrum1_task1.py 然後在近端測試後, 要利用 git remote add 建立同步設定後, 再推送到各分組自行建立的 OpenShift 應用程式倉儲,  然後再將結果回報到 cdw2 的 gh-pages 分支的 Pelican 網站.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先是在 scrum1_task1.py 程式中, 利用 Flask 的 Blueprint() 建立藍圖, 且名稱為 scrum1_task1, 這個變數名稱, 就是後面用來指定路徑 decorator 用的藍圖案例, 從這裡可以知道隨後測試可以 /ag100/scrum1_task1 呼叫 task1() 函式傳回的繪圖程式.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接著則是在 myflaskapp.py 檔案中, 利用 import users.s2a.g100.scrum1_task1 導入 scrum1_task1.py 程式內容, 且在 flask app 註冊的時候, 利用 app.register_blueprint(users.s2a.g100.scrum1_task1.scrum1_task1) 註冊 scrum1_task1.py 程式中的 scrum1_task1 藍圖變數.&lt;/p&gt;
&lt;p&gt;完整的程式碼: &lt;a href="https://github.com/2015fallhw/cdw2/blob/efc0bf77c01c2d4218f16fb0603bb5ed27639e1b/users/s2a/g100/scrum1_task1.py"&gt;https://github.com/2015fallhw/cdw2/blob/efc0bf77c01c2d4218f16fb0603bb5ed27639e1b/users/s2a/g100/scrum1_task1.py&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;完成上述的 /ag100/scrum1_task1 繪圖的本地端測試後, 可以正常顯示繪圖內容後, 將 master 分支的版本提交推送到 https://github.com/2015fallhw/cdw2.git 倉儲後, 接著就利用組長所登記的 OpenShift python3 應用程式, 將原始碼指到 https://github.com/2015fallhw/cdw2.git 後就可以完成 ag100 組所對應的 &lt;a href="http://cdw2-ag100.rhcloud.com/ag100/scrum1_task1"&gt;http://cdw2-ag100.rhcloud.com/ag100/scrum1_task1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;最後,為了將 ag100 組員 scrum-1 所完成的繪圖結果回報到 https://github.com/2015fallhw/cdw2.git 的 gh-pages 網頁, 因此將本地端的 cdw2 切換到 gh-pages 分支, 並且複製 users 目錄中的 template.leo 檔案, 並且建立 s2a/g100 目錄, 再將 template.leo 存為 scrum1.leo 後, 進行修改.&lt;/p&gt;
&lt;p&gt;scrum1.leo 是 ag100 組員 scrum-1 所對應的 .leo 檔案, 目的是要建立 content 目錄中的 .md 檔案, 並在本地端用近端按鈕將 .md 轉為 Pelican 網誌, 進行檢視後, 然後再利用遠端按鈕將資料轉為遠端專用格式, 以提交推送到 cdw2 倉儲的 gh-pages 分支.&lt;/p&gt;
&lt;p&gt;scrum1.leo 位於 users/s2a/g100 目錄中, 編輯 .md 檔案時必須特別注意:&lt;/p&gt;
&lt;p&gt;Title: scrum1-回報 ag100 scrum1 初步繪圖主機與連結&lt;/p&gt;
&lt;p&gt;必須加入 scrum1 個人學號, 以免多組員使用相同文章標題後, Pelican 無法轉成 html, 因為設定中是以 Title 名稱來決定最後 .html 的檔名.&lt;/p&gt;
&lt;p&gt;其次則是要在 Category: 中標示自己的組別, 這裡的標題為 ag100, 表示 scrum-1 組員為甲班 g100 的成員.&lt;/p&gt;
&lt;p&gt;寫完文章後, 先將滑鼠停在 @button local pelican 節點, 然後按上方的 local-pelican 按鈕, 完成轉換為 html 後, 打開 cdw2 倉儲中 gh-pages 分支中的 index.html 檢查是否正確轉檔, 若是, 則再將滑鼠停在 @button gh-pages pelican 節點, 再按上方的 gh-pages-pelican 按鈕後, 將版本資料提交推送到 cdw2 的 gh-pages 分支中.&lt;/p&gt;
&lt;p&gt;因為這裡要推送到 gh-pages 分支, 若以指令推送, 必須使用 git push origin gh-pages, 若是需要拉回 gh-pages 的分支版本, 則使用 git pull origin gh-pages 指令.&lt;/p&gt;
&lt;p&gt;當 scrum-1 用戶完成 cdw2 gh-pages 分支版次資料後, 所新增的網誌文章為: &lt;a href="http://2015fallhw.github.io/cdw2/post/scrum1-hui-bao-ag100-scrum1-chu-bu-hui-tu-zhu-ji-yu-lian-jie.html"&gt;http://2015fallhw.github.io/cdw2/post/scrum1-hui-bao-ag100-scrum1-chu-bu-hui-tu-zhu-ji-yu-lian-jie.html&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>協同流程的規劃與實踐</title><link href="./xie-tong-liu-cheng-de-gui-hua-yu-shi-jian.html" rel="alternate"></link><updated>2016-03-23T21:24:55+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-23:./xie-tong-liu-cheng-de-gui-hua-yu-shi-jian.html</id><summary type="html">&lt;p&gt;隨著分散式版次管理系統技術的不斷進展, 各種軟硬體協同開發流程的規劃也跟著日漸多元, 當然, 從機械設計的角度來看, &lt;a href="https://www.onshape.com"&gt;Onshape&lt;/a&gt; 的推出, 或許可以讓過去許多無緣一窺大型制式 PDM 或 PLM 系統的學員, 透過免費帳號的使用, 稍微體會一個版本多方推升改版所帶來的便利.&lt;/p&gt;


&lt;p&gt;而在這個課程中, 我們則透過 &lt;a href="https://github.com/"&gt;Github&lt;/a&gt; 協同倉儲的運作, 從學員分組、指定組長、安排座位、各組組長設為倉儲直接協同者 (collaborator)、其他組員以 Pull Request 參與協同, 一直到本地端 &lt;a href="http://solvespace.com/"&gt;Solvespace&lt;/a&gt; 的零件輪廓繪製, 進而透過 SVG (Scalable Vector Graphics) 格式將零件斷面輪廓搬上全球資訊網, 然後以各組協同完成網際 2D 組件繪圖告一段落.&lt;/p&gt;
&lt;p&gt;其中的程式皆以 Python3 完成, 工具組則包含 Leo Editor, Github 倉儲, Git client, Github Pages, Flask 框架, WSGI 協定, OpenShift 雲端平台等.&lt;/p&gt;
&lt;p&gt;以雲端上的學員分組到安排座位, 初步的說明在 &lt;a href="wcm-dian-nao-jiao-shi-fen-zu-yan-jiu.html"&gt;電腦教室分組研究&lt;/a&gt;, 而當各組組長確立後, 則必須要利用 &lt;a href="https://developer.github.com/v3/"&gt;Github API&lt;/a&gt; 自動建立對應協同倉儲, 並且自動按照協同產品設計期程與內容規劃, 將各組組長設為各協同倉儲的直接協同者 (collaborator), 以便審核該組組員透過 Pull Request 送出的協同內容版次合併事宜.&lt;/p&gt;
&lt;p&gt;針對此一自動建立 Github 倉儲與納組長為直接協同者的流程, 我們將利用 &lt;a href="https://github.com/sigmavirus24/github3.py"&gt;https://github.com/sigmavirus24/github3.py&lt;/a&gt; 與 &lt;a href="https://github.com/mitsuhiko/flask"&gt;https://github.com/mitsuhiko/flask&lt;/a&gt;, 在 &lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt; 平台上完成. &lt;/p&gt;
&lt;h2&gt;讀取學員分組基本資料&lt;/h2&gt;
&lt;pre class="brush: python;"&gt;
content = '''40323101,40323102,40323103,40323108,40323124,,
40323109,40323130,40323135,40323136,40323138,40323144,
40323111,40323117,40323118,40323119,40323120,40323122,
40323110,40323113,40323116,40323121,40323151,,
40323112,40323133,40323147,40323152,40323155,40323156,
40323105,40323106,40323107,40323146,40223153,40023139,
40123119,40123141,40123149,40123216,40123227,40123255,40023234
40323125,40323126,40323132,40323149,40323150,40323153,
40323123,40323131,40323137,40323143,40323145,40323154,
40323127,40323128,40323139,40323141,,,
'''
result = []

# splitlines() 方法會將每一行內容作為字串後傳回分割行資料數列
for line in content.splitlines():
    try:
        g.es(line.split(","))
    except:
        print(line.split(","))
    #各行字串再以逗點隔開成為各組學號數列, 再一一放入 result 數列中
    result.append(line.split(","))

try:
    g.es(result)
except:
    print(result)
&lt;/pre&gt;

&lt;h2&gt;組內學號排序, 以及組間之組長學號排序&lt;/h2&gt;
&lt;pre class="brush: python;"&gt;
# 依照總組數, 逐一取出各組學號數列進行排序
for i in range(len(result)):
    #學號遞增排序
    group_list = sorted(list(filter(None, result[i])))
    #學號遞減排序
    group_list = sorted(list(filter(None, result[i])), reverse=True)
    group_sorted.append(group_list)
#根據各組第一位組員學號, 進行各組間排序, 以訂出組序
final_result = sorted(group_sorted)
#學號遞減排序
#final_result = sorted(group_sorted, reverse=True)
&lt;/pre&gt;

&lt;p&gt;當確定各組組長以及各組的組序後, 就可以利用下列流程, 自動建立對應倉儲, 並將組長納為 collaborator:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#導入 github3.py
import github3
# account 為要加為 collaborator 的用戶名稱
account = "github_account_to_be_added_as_collaborator"
# user_account 為 repository 倉儲擁有者的帳號
user_account = "your_github_account"
repository = "your_repository"
#url = "https://github.com/your_github_account/your_repository.git"
# 登入系統
g = github3.login("your_github_account", "your_github_password")
# 以下則新增協同者
#若新增 collaborator 成功傳回 True 否則傳回 False
result = g.repository(user_account, repository).add_collaborator(account):
#移除 collaborator
#result = g.repository(user_account, repository).remove_collaborator(account):
&lt;/pre&gt;

&lt;p&gt;建立新倉儲(&lt;a href="http://github3py.readthedocs.org/en/latest/examples/github.html#creating-a-new-repository"&gt;參考&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
repo = {}
keys = ['name', 'description', 'homepage', 'private', 'has_issues',
    'has_wiki', 'has_downloads']

for key in keys:
    try:
        repo[key] = raw_input(key + ': ')
    except KeyboardInterrupt:
        pass

r = None
if repo.get('name'):
    r = g.create_repo(repo.pop('name'), **repo)

if r:
    print("Created {0} successfully.".format(r.name))
&lt;/pre&gt;

&lt;p&gt;最後則配合 &lt;a href="http://cadlab.mde.tw"&gt;http://cadlab.mde.tw&lt;/a&gt; 的電腦教室配置, 依據已經完成分組的名單, 以依組序分別取出單一組員, 排入各排座位, 以分散各組組員, 令其儘量透過網路與系統資料進行協同產品設計.&lt;/p&gt;
&lt;p&gt;分組與列出座位表的程式如下:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
@app.route('/optionaction', methods=['POST'])
def optionaction():
    # 最後傳回的字串為 out_string
    out_string = ""
    # 程式內需要暫時使用的 tmp_string
    tmp_string = ""
    # 傳回字串中, 用來說明排序原則的 desc_string
    desc_string = ""
    result = []
    group_sorted = []
    num_of_stud = 0
    # 每組至多 7 人
    max_num_in_one_group = 7
    # 電腦教室配置, 共有 9 排
    total_column = 9
    # 上面為相關變數的初始值設定, 以下開始取出 data_a 或 data_b 進行處理, 由 option3 傳回值決定
    if request.form["option3"]  == "2a":
        content = request.form["data_a"]
    else:
        content = request.form["data_b"]
    #result = content.splitlines()
    for line in content.splitlines():
        result.append(list(line.split(",")))
    # i 為行序
    for i in range(len(result)):
        # j 為組員序
        for j in range(len(result[i])):
            tmp_string += result[i][j] + ", "
        out_string += "第" + str(i+1) + "排資料:"+ tmp_string + "&lt;br /&gt;"
        tmp_string = ""
    for i in range(len(result)):
        # 開始進入組內排序, 根據 request.form["option1"]  的值決定遞增或遞減
        if request.form["option1"]  == "遞增":
            group_list = sorted(list(filter(None, result[i])))
        else:
            group_list = sorted(list(filter(None, result[i])), reverse=True)
        group_sorted.append(group_list)
    if request.form["option1"]  == "遞增":
        desc_string += "組內學號最小者為組長."
    else:
         desc_string += "組內學號最大者為組長."
    # 開始進入組間組長學號排序, 根據 request.form["option2"] 的值決定遞增或遞減
    if request.form["option2"]  == "遞增":
        desc_string += "各組長中學號最小者為第1組."
        final_result = sorted(group_sorted)
    else:
        desc_string += "各組長中學號最大者為第1組."
        final_result = sorted(group_sorted, reverse=True)
    out_string += "&lt;br /&gt;" + desc_string + "&lt;br /&gt;"
    # i 為行序
    for i in range(len(final_result)):
        # j 為組員序
        for j in range(len(final_result[i])):
            num_of_stud += 1
            tmp_string += final_result[i][j] + ","
        out_string += "第" + str(i+1) + "組:"+ tmp_string + "&lt;br /&gt;"
        tmp_string = ""
    #return "總共有" + str(i+) + "組"
    # group_num 為總組數
    group_num = i + 1
    # 截至這裡, 已經完成選組長, 以及定組序的工作 ,接下來要排座位, 並且印出座位表
    # 先算每班的總人數
    #return "總共有"+ str(num_of_stud) + "人"
    seat_by_column = []
    for row in range(max_num_in_one_group):
    # 每組最多 7 人
    #for row in range(7):
        # 這裡的 11 為總組數
        #for column in range(11):
        for column in range(group_num):
            # 因為各分組數列的長度並不相同, 但是最長的有 7 位組員, 因此若無法取得的資料 (因為索引超值), 就補上空字串
            try:
                seat_by_column.append(final_result[column][row])
            except:
                seat_by_column.append("")
    # seat_by_column 為去除空白字串前的座位數列
    # 然後利用 filter(None, seat_by_column) 去除空白字串, 就可以得到以 column 為主的座位排序
    seat_by_column = list(filter(None, seat_by_column))
    # 然後每 N 個取為 1 排, 即可得到以排為主的座位序列, 而 N 則視全班人數除以 9, 也就是 total_column 進位決定, 因為共有 9 排
    N = math.ceil(num_of_stud/total_column)
    # for debug
    #return str(num_of_stud) + ":" + str(total_column) + ":" + str(N)
    column_list = [seat_by_column[n:n+N] for n in range(0, len(seat_by_column), N)]
    # 列出每 N 個組員一排的數列 column_list
    # 接下來要納入以排為主的座位
    # 根據 column_list, 建立一個 dictionary, 其中學號為 index, 座位號為對應值
    seat_dict = {}
    for column in range(len(column_list)):
        for i in range(N):
            try:
                seat_dict.update({column_list[column][i]: (column, i)})
            except:
                seat_dict.update({"": ""})

    # 開始準備用順序列出學員座號
    # 根據學號, 排序 dictionary 的方法
    import operator
    seat_dict_sort = sorted(seat_dict.items(), key = operator.itemgetter(0), reverse = False)
    # 依照學號順序, 列出座位表
    out_string += "&lt;br /&gt;按照學號次序列出座位表:&lt;br /&gt;&lt;br /&gt;"
    for i in range(1, len(seat_dict_sort)):
        out_string +=  str(i) + ":"+ str(seat_dict_sort[i]) + "&lt;br /&gt;"
    # 結束準備用順序列出學員座號
    # dont know why .reverse() did not work, 只有 [::-1] 可以 reverse list elements
    #g.es(column_list[::-1])

    # 因為經由 zip 逐一重新 transpose 的列資料, 必須配合最大 (也就是總共有 7 列, 也就是 N 的值) 列數補上空白字串 (也就是空位)
    # 所以不能使用 zip, 而必須導入 zip_longest 模組方法
    from itertools import zip_longest
    final_seat = list(zip_longest(*column_list[::-1], fillvalue=""))
    # 列出最後的座位表
    #g.es(final_seat)
    # 最後轉成 html table 標註格式
    out_string += "&lt;br /&gt; &lt;br /&gt;"
    out_string += "&lt;table border='1' width='100%'&gt;"
    out_string += "&lt;tr&gt;&lt;td colspan='9' style='text-align:center'&gt;講台&lt;/td&gt;&lt;/tr&gt;"
    for row in range(len(final_seat)):
        out_string += "&lt;tr&gt;"
        # 因為每一 row 有 9, 也就是 total_column 個位子
        for i in range(total_column):
            try:
                if i%2 != 0:
                    out_string += "&lt;td style='text-align:center'  bgcolor='#FFD78C' height='30'&gt;" + str(final_seat[row][i]) + "&lt;/td&gt;"
                else:
                    out_string += "&lt;td style='text-align:center' height='30'&gt;" + str(final_seat[row][i]) + "&lt;/td&gt;"
            except:
                out_string += "&lt;td&gt;&amp;nbsp;&lt;/td&gt;"
        out_string += "&lt;/tr&gt;"
    out_string += "&lt;/table&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;"
    return out_string
    # 等運算或資料處理結束後, 再將相關值送到對應的 template 進行資料的展示
    #return render_template('optionaction.html', option_list1=option_list1, option_list2=option_list2)
&lt;/pre&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category><category term="協同產品設計實習"></category></entry><entry><title>SVG 檔案解讀</title><link href="./svg-dang-an-jie-du.html" rel="alternate"></link><updated>2016-03-21T22:06:23+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-21:./svg-dang-an-jie-du.html</id><summary type="html">&lt;p&gt;利用 Python 的 xml 模組, 可以讀出一個 SVG 檔案的尺寸與路徑字串.&lt;/p&gt;


&lt;pre class="brush: python;"&gt;
from xml.dom import minidom

svg_file = "cd_task1_chain_ss.svg"

# 利用 minidom 解讀 svg 檔案
doc = minidom.parse(svg_file)

# 設法取得 svg 檔案的長與寬, 並且去除 mm 單位字串
width = float([path.getAttribute('width') for path
             in doc.getElementsByTagName('svg')][0].replace("mm", ""))

height = float([path.getAttribute('height') for path
              in doc.getElementsByTagName('svg')][0].replace("mm", ""))

# 取得 svg 的路徑字串
path_strings = [path.getAttribute('d') for path
                in doc.getElementsByTagName('path')][0]

doc.unlink()

print("width:", width, "\nheight:", height, "\npath:", path_strings)
&lt;/pre&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category><category term="協同產品設計實習"></category></entry><entry><title>Cango 全球資訊網繪圖程式庫</title><link href="./cango-quan-qiu-zi-xun-wang-hui-tu-cheng-shi-ku.html" rel="alternate"></link><updated>2016-03-16T21:21:39+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-16:./cango-quan-qiu-zi-xun-wang-hui-tu-cheng-shi-ku.html</id><summary type="html">&lt;p&gt;Cango 是一套 Canvas Graphics Library, 以 Javascript 編寫, 為了將它導入機械設計產品開發流程, 透過 Brython 程式呼叫.&lt;/p&gt;


&lt;p&gt;以 Solvespace 繪製輪廓圖: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/cd_task1_chain_profile.slvs"&gt;http://chiamingyen.github.io/kmolab_data/files/cd_task1_chain_profile.slvs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;從 Solvespace 輪廓圖長出 3D 零件後, 以 export 2D section SVG 圖檔: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/cd_task1_chain_ss.svg"&gt;http://chiamingyen.github.io/kmolab_data/files/cd_task1_chain_ss.svg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;從 cd_task1_chain_ss.svg 圖檔, 可以得知斷面圖檔寬度為 26.696mm, 而高度為 47.906mm, 且 SVG 各點的座標原點位於圖檔的左下角落點. 從此資訊就可以算出 svgToCgoSVG 函式中的座標 offset 值為 (26.696/2, 47.906/2+10) (因為上下兩個圓弧的圓心距離 20 mm), 而 Solvespace 轉出 SVG 時將上下圓弧分別截為三段表示. 下圖中綠色輪廓繪圖數據即來自 Solvespace.&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/Cango2D-6v13.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://cptocadp-2015fallhw.rhcloud.com/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cobj = JSConstructor(window.Cobj)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")

#cgo.setWorldCoords(-300, -300, 600, 600)
cgo.setWorldCoords(-200, -200, 400, 400) 

#畫座標軸線

cgo.drawAxes(0, 190, 0, 190, {
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 10,
    "xLabelInterval": 20,
    "yTickInterval": 10,
    "yLabelInterval": 20})

deg = math.pi/180

#選擇長弧, 且向內畫弧
def chain1(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894                      A 7, 7, 0, 1, 0, 6.8397, -1.4894                      A 40, 40, 0, 0, 1, 6.8397, -18.511                      A 7, 7, 0, 1, 0, -6.8397, -18.511                      A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("1-長向內", x, y-10, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

# 選擇短弧, 且向內畫弧
def chain2(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894                      A 7, 7, 0, 0, 0, 6.8397, -1.4894                      A 40, 40, 0, 0, 1, 6.8397, -18.511                      A 7, 7, 0, 1, 0, -6.8397, -18.511                      A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("2-短向內", x, y-10, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

#選擇長弧, 且向外畫弧
def chain3(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894                      A 7, 7, 0, 1, 1, 6.8397, -1.4894                      A 40, 40, 0, 0, 1, 6.8397, -18.511                      A 7, 7, 0, 1, 0, -6.8397, -18.511                      A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("3-長向外", x, y-30, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

#選擇短弧, 且向外畫弧
def chain4(x, y, rx, ry, rot, color, border, linewidth):
    # 旋轉必須要針對相對中心 rot not working yet
    chamber = "M -6.8397, -1.4894                      A 7, 7, 0, 0, 1, 6.8397, -1.4894                      A 40, 40, 0, 0, 1, 6.8397, -18.511                      A 7, 7, 0, 1, 0, -6.8397, -18.511                      A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": color,
            "border": border,
            "strokeColor": "black",
            "lineWidth": linewidth })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, rot)
    cgo.drawText("4-短向外", x, y-30, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

#利用 boundary 界定出繪圖的範圍
def boundary():
    chamber = "M -200, -200 L 200, -200 L 200, 200 L -200, 200z"
    cgoChamber = window.svgToCgoSVG(chamber)
    cmbr = cobj(cgoChamber, "PATH", {
            "fillColor": "black",
            "border": True,
            "strokeColor": "black",
            "lineWidth": 5 })
    # 尺寸放大兩倍
    cgo.render(cmbr, 0, 0, 1, 0)
    #cgo.drawText("2-短向內", x, y-10, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

def drawSpiral():
    chamber = "M 289.16,447.14 \
                 C 233.33,399.03 267.47,290.34 364.53,265.28 \
                   408.88,269.91 448.14,282.58 483.22,303.79 \
                   391.79,287.12 292.99,369.50 331.90,451.11 \
                   318.79,447.43 302.35,446.61 289.16,447.14 z"
    cgoChamber = window.svgToCgoSVG(chamber, -287, -536)
    cmbr = cobj(cgoChamber, "SHAPE", {
        "fillColor":"lightyellow",
        "strokeColor":"tan",
        "lineWidthWC":4,
        "border":True })
    #cgo.drawShape(shapedefs.circle(8),0 ,0 , {"fillColor":"tan"})
    cmbr.scale(0.5)
    scl = 1
    for i in range(50):
        scl = scl/(1.08)
        cgo.render(cmbr, 0, 0, scl, -i*24.5)

# 從 solvespace 轉出的 SVG (必須長出實體, 然後選擇斷面後, 以 export 2D section 轉出 SVG) 
# width='26.696mm' height='47.906mm', 且原點在左下角落
def solvespace(x, y):
    centerx = 26.696/2
    centery = 47.906/2+10
    chamber = "M16.772 7.656 \
            A7.000,7.000 0 0,1 8.924,7.656 \
            A7.000,7.000 0 0,1 6.008,14.942 \
            A40.000,40.000 0 0,1 6.008,31.964 \
            A7.000,7.000 0 0,0 8.924,39.250 \
            A7.000,7.000 0 0,0 16.772,39.250 \
            A7.000,7.000 0 0,0 19.688,31.964 \
            A40.000,40.000 0 0,1 19.688,14.942 \
            A7.000,7.000 0 0,0 16.772,7.656z"
    # 以其中一個相切點作為關鍵原點
    # -centerx 為 x 座標的 offset 值, 也就是新原點位於 (centerx, centery)
    cgoChamber = window.svgToCgoSVG(chamber, -centerx, -centery)
    cmbr = cobj(cgoChamber, "SHAPE", {
            "fillColor": "green",
            "border": True,
            "strokeColor": "black",
            "lineWidth": 4 })
    # 尺寸放大兩倍
    cgo.render(cmbr, x, y, 2, 0)
    cgo.drawText("從 ss 轉出", x, y-30, {"fontSize":10, "fontWeight": 1200, "lorg":5 })

boundary()
drawSpiral()
yellow = "#f4c20d"
white = "#ffffff"
chain1(0, 0, 0, 0, 0, white, True, 4)
chain2(35, 0, 0, 0, 0, white, True, 4)
chain3(70, 0, 0, 0, 0, white, True, 4)
chain4(105, 0, 0, 0, 0, white, True, 4)
solvespace(140, 0)
&lt;/script&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category><category term="協同產品設計實習"></category></entry><entry><title>協同產品設計實習的網際 2D 協同繪圖</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-de-wang-ji-2d-xie-tong-hui-tu.html" rel="alternate"></link><updated>2016-03-15T20:19:13+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-15:./xie-tong-chan-pin-she-ji-shi-xi-de-wang-ji-2d-xie-tong-hui-tu.html</id><summary type="html">&lt;p&gt;在這個範例中, 所有參與協同的機械設計課程學員, 透過 Github 的 pull request 機制進行協同繪圖程式開發, 而各組組長則以 collaborator 的角色負責審核各組員送出的 pull requests, 本繪圖任務中的基本單 2D 繪圖單元, 是由 4 個彼此相切的圓弧所組成, 各組必須根據幾何約束條件求出各相切點的座標後, 使用指定的網際繪圖程式庫, 著手結合各組員, 在一致的內容格式規劃下, 完成所要求的 2D 組件繪圖.&lt;/p&gt;


&lt;p&gt;任務倉儲: &lt;a href="https://github.com/2015fallhw/cdw2"&gt;https://github.com/2015fallhw/cdw2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;兩位虛擬組員, 分別是位於 s2a 中的 &lt;a href="https://github.com/2015fallhw/cdw2/tree/6ebf1e29c7379eb8c86eeae61ffea9fe1d79b098/users/s2a/g100"&gt;g100&lt;/a&gt;, 以及位於 s2b 中的 &lt;a href="https://github.com/2015fallhw/cdw2/tree/6ebf1e29c7379eb8c86eeae61ffea9fe1d79b098/users/s2b/g99"&gt;g99&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;在 cdw2 倉儲 1.1 版本中 &lt;a href="https://github.com/2015fallhw/cdw2/releases"&gt;https://github.com/2015fallhw/cdw2/releases&lt;/a&gt; 已經完成 &lt;a href="http://cdw2-ladisai.rhcloud.com/ag100/task2"&gt;http://cdw2-ladisai.rhcloud.com/ag100/task2&lt;/a&gt; 的範例繪圖.&lt;/p&gt;
&lt;p&gt;而此一範例繪圖的程式碼來自 &lt;a href="https://github.com/2015fallhw/cdw2/blob/6ebf1e29c7379eb8c86eeae61ffea9fe1d79b098/users/s2b/g99/task0.py"&gt;s2b g99 的 task0.py&lt;/a&gt;, 且 Github 的倉儲資料以 git remote add 與 OpenShift 平台上的雲端應用程式倉儲進行同步.&lt;/p&gt;
&lt;p&gt;Task1 任務:&lt;/p&gt;
&lt;p&gt;請各組利用上述協同繪圖所提供的鏈條元件輪廓, 完成下列字母排列方式中的 ABCD 4個字母繪圖, 且每一位組員在各字母中必須至少繪製一小截鏈條, 各組所完成的規劃過程與結果, 則必須在 cdw2 倉儲對應的 &lt;a href="http://2015fallhw.github.io/cdw2/"&gt;http://2015fallhw.github.io/cdw2/&lt;/a&gt; Github Pages 網頁中完成.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bike_chain_1.jpg" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bike_chain_2.jpg" width="800" /&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category><category term="協同產品設計實習"></category></entry><entry><title>WCM 電腦教室分組研究</title><link href="./wcm-dian-nao-jiao-shi-fen-zu-yan-jiu.html" rel="alternate"></link><updated>2016-03-13T12:24:53+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-13:./wcm-dian-nao-jiao-shi-fen-zu-yan-jiu.html</id><summary type="html">&lt;p&gt;在網際內容管理的課程中, 有一個針對電腦教室實際的配置, 讓學員自行籌組, 然後再依據各組組員的學號排序選出組長後, 再根據各組長的學號排序決定組序, 這裡希望採用 Flask 網際框架, 並且將 Github 倉儲中的程式與 OpenShift 上的應用程式同步, 以便讓機械設計學員體會之後如何應用類似的網際流程來提升產品開發的效能.&lt;/p&gt;


&lt;p&gt;在網際內容管理的&lt;a href="https://github.com/2015fallhw/2016springwcm/wiki/%E7%B6%B2%E9%9A%9B%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%A0%94%E7%A9%B6%E4%B8%BB%E9%A1%8C"&gt;研究主題&lt;/a&gt;中, 列出與全球資訊網應用相關的軟體與硬體內容管理, 其中透過全球資訊網應用程式, 能夠讓使用者:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接利用瀏覽器輸入基本資料&lt;/li&gt;
&lt;li&gt;讓使用者選擇處理基本資料的方法&lt;/li&gt;
&lt;li&gt;利用雲端上的主機進行資訊的運算或處理&lt;/li&gt;
&lt;li&gt;處理結束後, 使用者可以在瀏覽器上檢視處理結果 ,然後再設法利用資料庫儲存這些資料, 並依照需求進行下一階段的工作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而上述處理資料的流程與許多機械設計的流程類似:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用者利用瀏覽器輸入基本的設計需求 (例如, 從機械元件設計資料庫中, 選擇以漸開線正齒輪組, 輸入傳遞功率與減速需求, 設計減速機)&lt;/li&gt;
&lt;li&gt;使用者利用網際選單, 進一步選擇設計條件 (例如, 使用者可以選擇安全係數, 某一個齒輪的齒數或材料或熱處理的方法等)&lt;/li&gt;
&lt;li&gt;網際機械設計程式根據使用者的輸入與設計要求, 選擇既定的設計運算流程, 其中包括自動查表, 自動選擇適用的配合零組件&lt;/li&gt;
&lt;li&gt;處理或運算結數後, 使用者可以直接從瀏覽器取得設計結果 (例如, 系統直接完成各零組件的參數繪圖, 使用者可以選擇零件格式下載, 進行下一步的原型列印與組裝測試)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先看看目前這個簡單的分組程式操作畫面:&lt;/p&gt;
&lt;p&gt;使用者輸入各組自行籌組的資料, 這裡實際上採用雲端即時試算表讓所有組員同時利用瀏覽器輸入分組資料後, 轉進表單:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/simpleflask-2014openshift.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;分別選擇組內排序方法, 選出組長 ,然後再選各組間的組長排序方法 ,定出組序, 按下 Select, 即可列出分組結果:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/simpleflask-2014openshift_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;上述這個基本的 Flask 程式配置流程, 請參考 &lt;a href="http://project.mde.tw/blog/yen-wang-ji-flask-cheng-shi-jia-gou.html"&gt;http://project.mde.tw/blog/yen-wang-ji-flask-cheng-shi-jia-gou.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;有了能夠接受網際表單的 Flask 程式後, 分別將程式與 Leo Editor 專案資料送到 Github 倉儲 &lt;a href="https://github.com/2015fallhw/simpleflask"&gt;https://github.com/2015fallhw/simpleflask&lt;/a&gt;, 然後再利用本地端的 git remote add 與 OpenShift 上的雲端程式同步 &lt;a href="http://simpleflask-2014openshift.rhcloud.com/option"&gt;http://simpleflask-2014openshift.rhcloud.com/option&lt;/a&gt;, 就能夠讓使用者直接在瀏覽器執行自動分組的流程.&lt;/p&gt;
&lt;p&gt;有關這個版次的程式, 請參考 &lt;a href="https://github.com/2015fallhw/simpleflask/tree/c153e0a1d192138646be192c207541a527f91c45"&gt;https://github.com/2015fallhw/simpleflask/tree/c153e0a1d192138646be192c207541a527f91c45&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category></entry><entry><title>全球資訊網上的內容管理系統</title><link href="./quan-qiu-zi-xun-wang-shang-de-nei-rong-guan-li-xi-tong.html" rel="alternate"></link><updated>2016-03-12T23:16:49+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-12:./quan-qiu-zi-xun-wang-shang-de-nei-rong-guan-li-xi-tong.html</id><summary type="html">&lt;p&gt;這裡要舉的例子為架構在 OpenShift 平台上的 CMSimply, 目前採用 Python3 與 Cherrypy 編寫, 使用者只要建立帳號後, 將內容管理平台的原始碼, 架構在雲端平台, 馬上就能擁有一個可儲存機械設計相關內容的網站.&lt;/p&gt;


&lt;p&gt;由於本課程的目的, 不僅要將機械設計的各式內容送到雲端上的 CMSimply, 而且還要修改 Python3 內容管理系統的程式碼, 因此必須在本地端建立 rsa 格式的 key pair.&lt;/p&gt;
&lt;p&gt;在 Windows 平台上, 可以利用 puttygen: &lt;a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html"&gt;http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html&lt;/a&gt; 完成, 使用步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;開啟 puttygen.exe 後, 以 Generate 按鈕後, 移動滑鼠後即可完成.&lt;/li&gt;
&lt;li&gt;將 Public key 送到 OpenShift 帳號中的 settings 處.&lt;/li&gt;
&lt;li&gt;按 Conversions 功能表, 以 export OpenSSH 格式的 private key, 存到 home 目錄下的 .ssh 目錄中, 且以 id_rsa 命名檔案.&lt;/li&gt;
&lt;li&gt;之後若需從 OpenShift git clone 與這把 key 對應的應用程式, OpenShift 端會利用 settings 上所登錄的 public key 與 .ssh 目錄中的 id_rsa 進行驗證, 必須通過驗證才能順利完成倉儲的 git clone.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Ubuntu 平台上, 除了利用 ssh-keygen -t rsa 來建立 rsa 格式的 key pair 外, 其他步驟同 Windows.&lt;/p&gt;
&lt;p&gt;至於在 Windows 配合 Filezilla 與 OpenShift 雲端應用程式相連時, 必須利用 pageant.exe 載入 private key 後才能通過認証, 而在 Ubuntu 則可以透過 ssh-add ~/.ssh/id_rsa, 載入對應的 private key.&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category></entry><entry><title>機械設計流程的內容與管理</title><link href="./ji-jie-she-ji-liu-cheng-de-nei-rong-yu-guan-li.html" rel="alternate"></link><updated>2016-03-12T22:52:53+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-12:./ji-jie-she-ji-liu-cheng-de-nei-rong-yu-guan-li.html</id><summary type="html">&lt;p&gt;機械設計流程中可能產生的內容, 可分為口語表達、文字表達、2D 圖像、3D 表達、解析表達與實體表達等六大類.&lt;/p&gt;


&lt;p&gt;所謂的口語表達即是在機械設計過程中採口頭方式呈現, 可以利用錄音方式將口語表達轉為 mp3, 或者採逐字稿, 轉為文字檔, 然後上傳到網際內容管理系統.&lt;/p&gt;
&lt;p&gt;文字表達就網際而言, 就是利用 html 將文字內容寫在全球資訊網路上, 也可以整理成 pdf, 或其他格式的文字檔, 然後再上傳到網際內容管理系統&lt;/p&gt;
&lt;p&gt;而 2D 圖像, 可以是一張照片, 手繪圖, 說明圖檔, 流程圖, 或者是產品的工程圖, 通常以 png、jpeg  或 gif 副檔名檔案格式.&lt;/p&gt;
&lt;p&gt;3D 表達, 包括一般影片、模擬動畫、CAD 零件, CAD 組件等.&lt;/p&gt;
&lt;p&gt;解析表達就是與機械設計相關的理論分析, 可以是方程式推導, 設計流程最佳化或各類型 CAE 模擬分析.&lt;/p&gt;
&lt;p&gt;實體表達就是實際做出實體的過程, 牽涉許多不同類型的製造程序, 一旦根據前述的五種表達方式模擬與規劃之後, 透過原型實驗測試來驗證機械設計的可行性與可靠度.&lt;/p&gt;
&lt;p&gt;以下則是利用 2D 圖像來表達數學式:&lt;/p&gt;
&lt;p&gt;在文章中, 一旦啟用 render_math plugin, 就可以利用一前一後的 $ 與數學式相連的方式來呈現符號.&lt;/p&gt;
&lt;p&gt;例如: 前後用 $ 符號包圍 e=mc^2, 可以得到:&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(e=mc^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也可以利用一對 $$ 符號界定方程式, 利用 LaTeX 語法來表示:&lt;/p&gt;
&lt;p&gt;x^2  被一前一後的兩個 $$ 包圍, 可以得到:&lt;/p&gt;
&lt;div class="math"&gt;$$
x^2 
$$&lt;/div&gt;
&lt;p&gt;A_\text{c} = (\pi/4) d^2 則得到:&lt;/p&gt;
&lt;div class="math"&gt;$$
A_\text{c} = (\pi/4) d^2
$$&lt;/div&gt;
&lt;p&gt;\alpha{}_t(i) = P(O_1, O_2, … O_t, q_t = S_i \lambda{}) 則得到:&lt;/p&gt;
&lt;div class="math"&gt;$$
\alpha{}_t(i) = P(O_1, O_2, … O_t, q_t = S_i \lambda{})
$$&lt;/div&gt;
&lt;p&gt;\cos (2\theta) = \cos^2 \theta - \sin^2 \theta 則得到:&lt;/p&gt;
&lt;div class="math"&gt;$$
\cos (2\theta) = \cos^2 \theta - \sin^2 \theta
$$&lt;/div&gt;
&lt;p&gt;\int_0^\infty e^{-x^2} dx=\frac{\sqrt{\pi}}{2} 則得到:&lt;/p&gt;
&lt;div class="math"&gt;$$
\int_0^\infty e^{-x^2} dx=\frac{\sqrt{\pi}}{2}
$$&lt;/div&gt;
&lt;p&gt;y =x^4 + 4 \nonumber \
=(x^2+2)^2 -4x^2 \nonumber \
\le(x^2+2)^2&lt;/p&gt;
&lt;p&gt;則成為:&lt;/p&gt;
&lt;div class="math"&gt;$$
y =x^4 + 4 \nonumber \\
=(x^2+2)^2 -4x^2 \nonumber \\
\le(x^2+2)^2
$$&lt;/div&gt;
&lt;p&gt;\lim_{x \to a} f(x) 則成為:&lt;/p&gt;
&lt;div class="math"&gt;$$
\lim_{x \to a} f(x)
$$&lt;/div&gt;
&lt;p&gt;而程式碼的部份, 則使用 syntaxhighlighter 來顯示:&lt;/p&gt;
&lt;pre class="brush: python; html-script: true"&gt;
# python 程式碼
# 定義一個 myfunction 函式
def myfunciont():
    # 設定變數 i 與 10 對應
    i = 10
    # 啟動一個 for 重複迴圈, 以 j 為指標變數
    for j in range(i):
        # 在迴圈中列印 j 變數的對應值
        print(j)
# 呼叫 myfunction 函式
myfunction()
&lt;/pre&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category></entry><entry><title>利用 Github 執行協同設計專案</title><link href="./li-yong-github-zhi-xing-xie-tong-she-ji-zhuan-an.html" rel="alternate"></link><updated>2016-03-08T16:34:58+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-08:./li-yong-github-zhi-xing-xie-tong-she-ji-zhuan-an.html</id><summary type="html">&lt;p&gt;Github 的分散式版次管理, 可以讓機械設計工程師體會非同步協同的團隊合作模式, 在眾目睽睽之下, 所有與設計相關的細節都能夠加以保留.&lt;/p&gt;


&lt;h2&gt;協同設計規劃&lt;/h2&gt;
&lt;p&gt;協同產品設計實習的專案倉儲位於 &lt;a href="https://github.com/2015fallhw/2016springcd"&gt;https://github.com/2015fallhw/2016springcd&lt;/a&gt;, 其中的 gh-pages 分支可以對應到 Github Pages 的網頁 &lt;a href="http://2015fallhw.github.io/2016springcd/"&gt;http://2015fallhw.github.io/2016springcd/&lt;/a&gt;, 而需要依賴 Python 程式作為伺服器端的同步對應網站, 則位於 &lt;a href="http://cd-2015fallhw.rhcloud.com/"&gt;http://cd-2015fallhw.rhcloud.com/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;實習課程運作前的任務為 Task0: &lt;a href="http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html"&gt;http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html&lt;/a&gt; 主旨在利用 Python 程式對所有學員進行分組, 每一組 4-7 人, 經過自由籌組之後, 利用雲端即時試算表, 收集各組組員的學號後, 根據學號遞增排列, 分別排出組序並決定各組組長後, 各組長將納為 &lt;a href="https://github.com/2015fallhw/2016springcd"&gt;https://github.com/2015fallhw/2016springcd&lt;/a&gt; 倉儲與&lt;a href="http://cd-2015fallhw.rhcloud.com/"&gt;http://cd-2015fallhw.rhcloud.com/&lt;/a&gt; OpenShift 網站的協同管理者.&lt;/p&gt;
&lt;p&gt;各組組長的任務在協助審核或回應各協同組員所提交的 Pull Request 改版資料, 而各改版資料的內容即在分別解決各組所被交付的實習任務.&lt;/p&gt;
&lt;p&gt;Task0: &lt;a href="http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html"&gt;http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html&lt;/a&gt; 的實習任務目的, 希望各組能夠利用 OpenShift 雲端系統中的 Python3 應用程式, 以 Flask 網際框架: &lt;a href="http://flask.pocoo.org/"&gt;http://flask.pocoo.org/&lt;/a&gt;, 建立自動分組的網際程式, 而這個程式延伸自先前的計算機程式與電腦輔助設計實習課程的內容: &lt;a href="https://github.com/2015fallhw/cptocadp"&gt;https://github.com/2015fallhw/cptocadp&lt;/a&gt;. 希望以 Ethercalc 所採集到的分組學號原始資料作為輸入, 使用者可以利用 Task0 網際程式, 輸入這些原始資料後, 選擇組長排序規定 (遞增或遞減), 並選擇定組序規定 (遞增或遞減) 後, 網際程式可以自動列出各組組長名單, 各組組員名單, 以及依照電腦教室座位列表的學員座位表, 還有依照學號次序排列的座位表等.&lt;/p&gt;
&lt;p&gt;Task0 實習任務牽涉如何利用 Python 程式讀取資料檔, 按照各行資料納入數列資料結構, 如何進行數列的排序, 如何根據電腦教室的座位約束條件, 將學員逐一按照特定方法納入座位.&lt;/p&gt;
&lt;p&gt;Task0 實習任務的相關程式架構, 可以修改為網際機械元件設計系統, 使用者提供基本輸入要求, 網際輔助設計程式便可以根據設計條件執行運算後列出結果.&lt;/p&gt;
&lt;h2&gt;Github 的 Pull Request 協同&lt;/h2&gt;
&lt;p&gt;使用 Github 的 Pull Request 協同之前, 各協同組員必須先登入 Github 後, fork &lt;a href="https://github.com/2015fallhw/2016springcd"&gt;https://github.com/2015fallhw/2016springcd&lt;/a&gt; 父倉儲, 之後所有的組員協同將在各自 fork 後的子倉儲中進行.&lt;/p&gt;
&lt;p&gt;完成上述 fork 倉儲之後,各使用者利用 git clone 將這個 fork 的子倉儲複製到近端, 然後再依據 master 分支 (用於與 OpenShift 網站同步) 或 gh-pages 分支 (用於 Github Pages 網站) 中的內容, 切換各分支內容到近端工作目錄中工作.&lt;/p&gt;
&lt;p&gt;為了方便, 也可以讓 master 與 gh-pages 分支的資料同步, 然後再將 master 版本資料推送到 OpenShift 雲端網站中開機啟動運行.&lt;/p&gt;
&lt;p&gt;當各組員在近端倉儲完成特定任務後, 可以利用 ungit:&lt;a href="https://github.com/FredrikNoren/ungit"&gt;https://github.com/FredrikNoren/ungit&lt;/a&gt; 或 sourcetree: &lt;a href="https://www.sourcetreeapp.com/"&gt;https://www.sourcetreeapp.com/&lt;/a&gt; 或可攜 sourcetree: &lt;a href="https://github.com/cosmomill/SourceTreePortable"&gt;https://github.com/cosmomill/SourceTreePortable&lt;/a&gt; 或 git 命令套件: &lt;a href="https://github.com/msysgit/msysgit/releases"&gt;https://github.com/msysgit/msysgit/releases&lt;/a&gt;, 將近端資料提交推送到個人的子倉儲中, 然後再透過 pull request, 請求各組組長將子倉儲的改版資料納入父倉儲中.&lt;/p&gt;
&lt;p&gt;當 Taks0 任務結束後, 各組組員可以透過 Pull Request 逆轉提交的方式, 設法自動或手動合併遠端 &lt;a href="https://github.com/2015fallhw/2016springcd"&gt;https://github.com/2015fallhw/2016springcd&lt;/a&gt; 倉儲的資料, 然後再透過 git pull 的方式拉到近端, 以便用協同倉儲的最新資料執行 Task1.&lt;/p&gt;
&lt;h2&gt;Github Pull Request 逆轉&lt;/h2&gt;
&lt;p&gt;Pull Request 的功能在 fork 某一倉儲資料後進行改版後, 可以要求原倉儲管理者 (這裡的管理者係指各組組長), 將各組員的改版資料併入父倉儲, 而當原始倉儲經過各組協同, 不斷改版後, 各參與 Pull Request 的學員, 則可以利用 Github 的 Pull Request 逆轉設定, 更新自己的倉儲資料內容.&lt;/p&gt;
&lt;p&gt;所謂的 Pull Request 逆轉方法, 其觀念正好與 Pull Request 相反, 因為 Pull Request 希望被 fork 的原始倉儲 (父倉儲) 能夠取回已經被改版的各組員倉儲 (子倉儲) 資料, 而所謂的 Pull Request 逆轉, 就是各組員在各自的倉儲中, 新增 Pull Request, 但是要將 Pull Request 的 base 與 head 的兩端資料選項互換, 也就是將 base fork 設為子倉儲的分支, 而 head fork 就設為父倉儲的對應分支, 如此就可以透過此一 Pull Request 從父倉儲取得最新的資料內容, 而在 Github 的  New Pull Request 頁面中, 就提供了這個 switching base 的功能.&lt;/p&gt;
&lt;p&gt;在以下的範例畫面中, 2015fallhw/2016springcd 為父倉儲, coursemdetw 登入 Github 後, 連結到 &lt;a href="https://github.com/2015fallhw/2016springcd"&gt;https://github.com/2015fallhw/2016springcd&lt;/a&gt;, 就可以 fork 此一倉儲, 操作後回到 coursemdetw/2016springcd 倉儲畫面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;接著 coursemdetw 用戶將 &lt;a href="https://github.com/coursemdetw/2016springcd"&gt;https://github.com/coursemdetw/2016springcd&lt;/a&gt; 資料 git clone 到近端, 然後對 master 分支中的資料進行改版後提交推送回 &lt;a href="https://github.com/coursemdetw/2016springcd"&gt;https://github.com/coursemdetw/2016springcd&lt;/a&gt; 倉儲, 操作後畫面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;接著, 因為子倉儲的資料已經改版, 所以 Github 的對應倉儲頁面中, 出現了 New pull request 的按鈕, 表示可以利用新增 pull request, 請求父倉儲將此一版本拉回合併, 按下 New pull request 之後的畫面如下, 特別注意, 這個時候的 base fork 為 2015fallhw/2016springcd 父倉儲的 master 分支, 而 head fork 則為 coursemdetw/2016springcd 子倉儲的 master 分支, 表示請求的新版本內容為 head fork, 希望併入 base fork 中.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;當子倉儲的使用者按下 Create pull request 後的畫面:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_5.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;此時從 coursemdetw 的 pull request 畫面中, 可以看到這個版本與父倉儲的版本沒有衝突, 可以自動合併, 但是 coursemdetw 沒有權限合併, 必須讓父倉儲的管理者 (各組組長將具有此權限), 檢查此一 pull request 的請求內容, 確定沒有問題後, 再將資料納入父倉儲中.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_6.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;當組長登入 Github, 進入父倉儲之後, 便可以合併上述組員的 pull request, 操作後畫面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_7.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;此時, 另外一位組員 course-mde-tw, 原先與 coursemdetw 組員同時在組員改版之前 fork 了父倉儲的資料, 但此時 course-mde-tw 若希望能夠取得已經透過 pull request 流程併入父倉儲的資料, 則可以登入 Github 後, 利用反向的 pull request 設定, 就可以更新資料, 取得 coursemdetw 組員併入父倉儲的資料. course-mde-tw 登入 Github 後進入自己的子倉儲, 然後按下 New pull request 的按鈕後, 進入如下的畫面, 其中, 所謂的 pull request reversing 就是按下 switching the base 按鈕.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_8.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;先看一下上一個畫面中的 base fork 為 2015fallhw/2016springcd 中的 master 分支, 而 head fork 則為 course-mde-tw/2016springcd 中的 master 分支, 表示一般的 pull request 是從子倉儲 (head fork) 將資料併入父倉儲 (base fork).&lt;/p&gt;
&lt;p&gt;但是, 現在 course-mde-tw 用戶希望能夠從父倉儲取得最新資料, 因此必須就必須按下 switch the base 後, 如下一個畫面, 讓 base fork 變成 course-mde-tw/2016springcd, 而 head fork 則設為 2015fallhw/2016springcd, 表示此一請求是從父倉儲取版本資料.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_quest_reversing_9.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;course-mde-tw 用戶按下上一個畫面中的 Create pull request 按鈕後, 進入下一個畫面, 可以填寫 pull request 的標題與說明.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_10.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;course-mde-tw 填寫完 pull request 的請求後, 按下送出, 就可以在此一 pull request 中具備同意權, 因為版本資料是從父倉儲更新到子倉儲, 若兩端資料沒有衝突就可以直接在 Github 的畫面中, 按下 Merge pull request 自動完成合併, 畫面如下圖.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/github_pull_request_reversing_11.png" width="800" /&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>KMOL 可攜程式系統改版</title><link href="./kmol-ke-xi-cheng-shi-xi-tong-gai-ban.html" rel="alternate"></link><updated>2016-03-03T20:54:35+08:00</updated><author><name>kmol</name></author><id>tag:,2016-03-03:./kmol-ke-xi-cheng-shi-xi-tong-gai-ban.html</id><summary type="html">&lt;p&gt;將原有的 nodejs 目錄刪除, 改用 NodeJSPortable, 位於 apps 目錄下, 仍以 start_ungit.bat 啟動&lt;/p&gt;


&lt;p&gt;直接下載: 2016springkmol.7z &lt;a href="https://my.pcloud.com/publink/show?code=XZT4I4Ztpna2PMhDtVAOQKD7FI6CyfFf2H7"&gt;https://my.pcloud.com/publink/show?code=XZT4I4Ztpna2PMhDtVAOQKD7FI6CyfFf2H7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用 git clone 下載: &lt;a href="https://github.com/chiamingyen/kmol2016.git"&gt;https://github.com/chiamingyen/kmol2016.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在電腦輔助設計室 &lt;a href="http://cadlab.mde.tw"&gt;http://cadlab.mde.tw&lt;/a&gt; 時 &lt;a href="http://140.130.17.17/public/fix2016.zip"&gt;下載 fix2016.zip&lt;/a&gt;.&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category><category term="協同產品設計實習"></category></entry><entry><title>2016 Spring Collaborative Product Design Course</title><link href="./2016-spring-collaborative-product-design-course.html" rel="alternate"></link><updated>2016-02-24T21:32:24+08:00</updated><author><name>kmol</name></author><id>tag:,2016-02-24:./2016-spring-collaborative-product-design-course.html</id><summary type="html">&lt;p&gt;2016 Spring 產品設計實習課程 W1&lt;/p&gt;


&lt;h2&gt;2016 Spring 協同產品設計實習:&lt;/h2&gt;
&lt;h3&gt;可攜套件倉儲:&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kmol2016 下載:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX"&gt;https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啟動倉儲 &lt;a href="https://github.com/2015fallhw/test"&gt;https://github.com/2015fallhw/test&lt;/a&gt;, ungit: &lt;a href="https://github.com/FredrikNoren/ungit"&gt;https://github.com/FredrikNoren/ungit&lt;/a&gt; 工具導入&lt;/p&gt;
&lt;p&gt;網際繪圖程式庫 (與 WCM 課程共用): &lt;a href="https://github.com/2015fallhw/arcidau"&gt;https://github.com/2015fallhw/arcidau&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github Pages 網站: &lt;a href="http://2015fallhw.github.io/arcidau/"&gt;http://2015fallhw.github.io/arcidau/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Task 1: &lt;/p&gt;
&lt;p&gt;如何求出下列圖形中的4個相切點座標? 如何自行利用程式畫出這個 2D 的輪廓圖? (or Solvespace 或 PTC Creo Parametric 或 Onshape 是如何讓使用者運用繪圖工具完成此類, 具有特定尺寸與相關約束條件的產品輪廓圖)&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/2016cd_task1.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;動機 1:&lt;/p&gt;
&lt;p&gt;從 &lt;a href="http://rattlecad.sourceforge.net/"&gt;http://rattlecad.sourceforge.net/&lt;/a&gt; 可以得知桌面下單機的客製化自行車零組件繪圖工具, 能讓使用者根據自身尺寸, 訂製各零組件, 因此若能透過網路協同, 讓產品使用者、零件設計者、標準零件供應商與零組件製造商, 共同參與某一特定產品的設計與製造, 協同者需要俱備那些條件, 打造那些系統?該如何協同?&lt;/p&gt;
&lt;p&gt;解題規劃:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;該如何求出相切點的座標?我們擁有那些工具?在近端?在遠端?採用商用套件或自由開放工具?學會之後, 這些工具能否讓我們帶出學校合法使用?&lt;/li&gt;
&lt;li&gt;求出各相切點座標後, 該如何進行繪圖?我們擁有那些工具?採用商用套件或自由開放工具?學會之後, 這些工具能否讓我們帶出學校合法使用?&lt;/li&gt;
&lt;li&gt;畫出所需要的輪廓圖之後, 該如何以分組協同的方式打造類似 &lt;a href="http://rattlecad.sourceforge.net/"&gt;http://rattlecad.sourceforge.net/&lt;/a&gt; 的客製化產品設計工具?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;協同倉儲: &lt;a href="https://github.com/2015fallhw/2016springcd"&gt;https://github.com/2015fallhw/2016springcd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;協同倉儲對應 Github Pages 網站: &lt;a href="http://2015fallhw.github.io/2016springcd/"&gt;http://2015fallhw.github.io/2016springcd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;技術回顧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git 的功能? Github Pages 的功能?&lt;/li&gt;
&lt;li&gt;Python3 的功能? &lt;a href="http://jupyter.org/"&gt;http://jupyter.org/&lt;/a&gt; 的功能?&lt;/li&gt;
&lt;li&gt;OpenShift 的功能? Html5 與 Canvas 的功能? &lt;a href="http://2015fallhw.github.io/arcidau/"&gt;http://2015fallhw.github.io/arcidau/&lt;/a&gt; 所提供的功能?&lt;/li&gt;
&lt;li&gt;Vimeo 的功能? &lt;a href="https://www.pcloud.com/"&gt;https://www.pcloud.com/&lt;/a&gt; 的功能? (用來取代 copy.com)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;歷年課程回顧&lt;/h2&gt;
&lt;h3&gt;2015 Spring 協同產品設計實習:&lt;/h3&gt;
&lt;p&gt;Wordpress: &lt;a href="http://wordpress-2015course.rhcloud.com/?cat=3"&gt;http://wordpress-2015course.rhcloud.com/?cat=3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CMSimply: &lt;a href="http://cd-cadp.rhcloud.com/"&gt;http://cd-cadp.rhcloud.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vimeo 教學影片: &lt;a href="https://vimeo.com/tag:2015cd"&gt;https://vimeo.com/tag:2015cd&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2014 Spring 協同產品設計實習:&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wiki.mde.tw/doku.php?id=%E5%8D%94%E5%90%8C%E7%94%A2%E5%93%81%E8%A8%AD%E8%A8%88:%E5%AF%A6%E7%BF%92%E7%9B%AE%E6%A8%99"&gt;Dokuwiki 網站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2a Github 倉儲: &lt;a href="https://github.com/coursemdetw/2014cda"&gt;https://github.com/coursemdetw/2014cda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2a OpenShift 同步網站: &lt;a href="http://2014cda-mdenfu.rhcloud.com/"&gt;http://2014cda-mdenfu.rhcloud.com/&lt;/a&gt; (以 2014cdaproject@ 帳號負責維護)&lt;/p&gt;
&lt;p&gt;2b Github 倉儲: &lt;a href="https://github.com/coursemdetw/2014cdb"&gt;https://github.com/coursemdetw/2014cdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2b OpenShift 同步網站: &lt;a href="http://2014cdb-mdenfu.rhcloud.com/"&gt;http://2014cdb-mdenfu.rhcloud.com/&lt;/a&gt; (以 2014cdaproject@ 帳號負責維護)&lt;/p&gt;
&lt;p&gt;同年 C2 Github 倉儲: &lt;a href="https://github.com/coursemdetw/2014c2"&gt;https://github.com/coursemdetw/2014c2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同年程式語言(二)課程網頁: &lt;a href="http://2014c2-mdenfu.rhcloud.com/"&gt;http://2014c2-mdenfu.rhcloud.com/&lt;/a&gt; (以 2014cdaproject@ 帳號負責維護)&lt;/p&gt;
&lt;p&gt;Vimeo 教學影片: &lt;/p&gt;
&lt;p&gt;W1-1 &lt;a href="https://vimeo.com/87531218"&gt;https://vimeo.com/87531218&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W1-2 &lt;a href="https://vimeo.com/87534543"&gt;https://vimeo.com/87534543&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W2-a1 &lt;a href="https://vimeo.com/88125916"&gt;https://vimeo.com/88125916&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W2-b1 &lt;a href="https://vimeo.com/88225866"&gt;https://vimeo.com/88225866&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W2-b2 &lt;a href="https://vimeo.com/88229349"&gt;https://vimeo.com/88229349&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W2-3 &lt;a href="https://vimeo.com/88230051"&gt;https://vimeo.com/88230051&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W3-a1 &lt;a href="https://vimeo.com/88719135"&gt;https://vimeo.com/88719135&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W3-a2 &lt;a href="https://vimeo.com/88720436"&gt;https://vimeo.com/88720436&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W3-b1 &lt;a href="https://vimeo.com/88847174"&gt;https://vimeo.com/88847174&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W3-b2 &lt;a href="https://vimeo.com/88855247"&gt;https://vimeo.com/88855247&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W4-a1 &lt;a href="https://vimeo.com/89371363"&gt;https://vimeo.com/89371363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W5-a1 &lt;a href="https://vimeo.com/89371363"&gt;https://vimeo.com/89371363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W5-a2 &lt;a href="https://vimeo.com/89980644"&gt;https://vimeo.com/89980644&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W5-a3 &lt;a href="https://vimeo.com/89986371"&gt;https://vimeo.com/89986371&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W5-b1 &lt;a href="https://vimeo.com/90098081"&gt;https://vimeo.com/90098081&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W6-a1 &lt;a href="https://vimeo.com/90607449"&gt;https://vimeo.com/90607449&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W6-a2 &lt;a href="https://vimeo.com/90612598"&gt;https://vimeo.com/90612598&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W6-b1 &lt;a href="https://vimeo.com/90726318"&gt;https://vimeo.com/90726318&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W6-b2 &lt;a href="https://vimeo.com/90731025"&gt;https://vimeo.com/90731025&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W7-b1 &lt;a href="https://vimeo.com/91490333"&gt;https://vimeo.com/91490333&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W7-b2 &lt;a href="https://vimeo.com/91491493"&gt;https://vimeo.com/91491493&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W11-a1 &lt;a href="https://vimeo.com/94104234"&gt;https://vimeo.com/94104234&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Camstudio 與 Zoomit &lt;a href="https://vimeo.com/90818335"&gt;https://vimeo.com/90818335&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Video Converter &lt;a href="https://vimeo.com/90818467"&gt;https://vimeo.com/90818467&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W12-a1 &lt;a href="https://vimeo.com/95069384"&gt;https://vimeo.com/95069384&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W13-a1 &lt;a href="https://vimeo.com/95823422"&gt;https://vimeo.com/95823422&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W13-a2 &lt;a href="https://vimeo.com/95823554"&gt;https://vimeo.com/95823554&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W13-b1 &lt;a href="https://vimeo.com/95946099"&gt;https://vimeo.com/95946099&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W13-b2 &lt;a href="https://vimeo.com/95946189"&gt;https://vimeo.com/95946189&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W14-a1 &lt;a href="https://vimeo.com/96546108"&gt;https://vimeo.com/96546108&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W14-b1 &lt;a href="https://vimeo.com/96671856"&gt;https://vimeo.com/96671856&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2013 Spring 協同產品設計實習:&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://blog.kmol.info/indexd65e.html?cat=8"&gt;http://blog.kmol.info/indexd65e.html?cat=8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2013 CP: &lt;a href="http://cp-2013fall.rhcloud.com/"&gt;http://cp-2013fall.rhcloud.com/&lt;/a&gt; (以 2013fall@mde.tw 帳號控管)&lt;/p&gt;
&lt;h3&gt;2012 Spring 協同產品設計實習:&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://blog.kmol.info/indexd06b.html?cat=8&amp;amp;paged=3"&gt;http://blog.kmol.info/indexd06b.html?cat=8&amp;amp;paged=3&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2011 Spring 協同產品設計實習:&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://blog.kmol.info/index8040.html?cat=8&amp;amp;paged=4"&gt;http://blog.kmol.info/index8040.html?cat=8&amp;amp;paged=4&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>About Lektor Content Management System</title><link href="./about-lektor-content-management-system.html" rel="alternate"></link><updated>2016-02-24T15:30:43+08:00</updated><author><name>kmol</name></author><id>tag:,2016-02-24:./about-lektor-content-management-system.html</id><summary type="html">&lt;p&gt;初探 Lektor 內容管理系統, 假如它能在第1時間就支援 Python3, 應該會更棒&lt;/p&gt;


&lt;p&gt;&lt;a href="http://lucumr.pocoo.org/2015/12/21/introducing-lektor/"&gt;http://lucumr.pocoo.org/2015/12/21/introducing-lektor/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/lektor/lektor"&gt;https://github.com/lektor/lektor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/lektor"&gt;https://github.com/lektor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lektor 的作者說, 我們與其他類似的工具都不相同: &lt;a href="https://www.getlektor.com/docs/what/"&gt;https://www.getlektor.com/docs/what/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lektor 是靜態文件網頁&lt;/p&gt;
&lt;p&gt;也是內容管理系統&lt;/p&gt;
&lt;p&gt;還能當作程式框架&lt;/p&gt;
&lt;p&gt;可以協同, 也允許同步&lt;/p&gt;
&lt;p&gt;有人說, Lektor 很像 &lt;a href="http://urubu.jandecaluwe.com/"&gt;http://urubu.jandecaluwe.com/&lt;/a&gt;, 但有更好的管理環境&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.getlektor.com/docs/what/"&gt;https://www.getlektor.com/docs/what/&lt;/a&gt; 網站的資料就放在 &lt;a href="https://github.com/lektor/lektor-website"&gt;https://github.com/lektor/lektor-website&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只不過, 目前的 Desktop 應用程式只能用在 OsX 系統, 而 Python 也只支援 2.7 版, 真是可惜!&lt;/p&gt;
&lt;p&gt;有關目前只能支援 Python 2.7 的情形, 幾乎就與當年 Flask 推出時的情況一樣, 也許作者對於 Python 2.7 版比較熟, 可能要再等一陣子, 才能在 Python3 的環境中使用了.&lt;/p&gt;
&lt;p&gt;所以, 現階段, 想要靜態網頁系統, 而且自外於 Pelican: &lt;a href="https://github.com/getpelican/pelican"&gt;https://github.com/getpelican/pelican&lt;/a&gt;, 只能先從 &lt;a href="http://urubu.jandecaluwe.com/"&gt;http://urubu.jandecaluwe.com/&lt;/a&gt; 看起.&lt;/p&gt;
&lt;p&gt;另外, 假如想要脫離 Python3 一些些, 可以從 &lt;a href="https://github.com/meteor/meteor"&gt;https://github.com/meteor/meteor&lt;/a&gt; 入手.&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category></entry><entry><title>2016 CD course</title><link href="./2016-cd-course.html" rel="alternate"></link><updated>2016-02-24T10:43:59+08:00</updated><author><name>yen</name></author><id>tag:,2016-02-24:./2016-cd-course.html</id><summary type="html">&lt;p&gt;2016 Spring 協同產品設計實習課程規劃&lt;/p&gt;
&lt;h2&gt;MCAD 套件&lt;/h2&gt;
&lt;p&gt;Mechanical Computer Aided Design (MCAD) 套件將使用:&lt;/p&gt;
&lt;p&gt;Onshape: &lt;a href="https://www.onshape.com/"&gt;https://www.onshape.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Solvespace: &lt;a href="http://solvespace.com/index.pl"&gt;http://solvespace.com/index.pl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PTC Creo Parametric: &lt;a href="http://www.ptc.com/cad/creo/parametric"&gt;http://www.ptc.com/cad/creo/parametric&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;rattleCAD: &lt;a href="http://rattlecad.sourceforge.net/"&gt;http://rattlecad.sourceforge.net/&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;零組件繪圖與設計&lt;/h2&gt;
&lt;p&gt;將以自行車設計與 3D 模型組裝作為主題&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/gocycle1.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/gocycle2.png" width="600" /&gt;&lt;/p&gt;
&lt;h2&gt;標準零件庫&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.mcmaster.com/"&gt;http://www.mcmaster.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.bolts-library.org/"&gt;http://www.bolts-library.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://b2b.partcommunity.com/community/"&gt;https://b2b.partcommunity.com/community/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://grabcad.com/library/tag/bicycle"&gt;https://grabcad.com/library/tag/bicycle&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;客製化設計&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/vallettea/Bicycle"&gt;https://github.com/vallettea/Bicycle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.atom3dp.com/"&gt;http://www.atom3dp.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/smoqadam/PyFladesk-rss-reader"&gt;https://github.com/smoqadam/PyFladesk-rss-reader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Planar Linkage Analysis: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/planar_linkage_analysis.pdf"&gt;http://chiamingyen.github.io/kmolab_data/files/planar_linkage_analysis.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fourbar Synthesis: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/fourbar_synthesis.pdf"&gt;http://chiamingyen.github.io/kmolab_data/files/fourbar_synthesis.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spur Gear Design: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/spurGears.pdf"&gt;http://chiamingyen.github.io/kmolab_data/files/spurGears.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spur Gear in Creo Parametric: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/creo_spurgear.7z"&gt;http://chiamingyen.github.io/kmolab_data/files/creo_spurgear.7z&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Design of Spur and Helical Gears Transmissions: &lt;a href="https://github.com/efirvida/python-gearbox"&gt;https://github.com/efirvida/python-gearbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自行車控制設計: &lt;a href="https://plot.ly/ipython-notebooks/bicycle-control-design/"&gt;https://plot.ly/ipython-notebooks/bicycle-control-design/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Architecture of Collaboration: &lt;a href="http://chiamingyen.github.io/kmolab_data/files/architecture_of_collaboration.pdf"&gt;http://chiamingyen.github.io/kmolab_data/files/architecture_of_collaboration.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Pomax/bezierjs"&gt;https://github.com/Pomax/bezierjs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bicycledesign.net/"&gt;http://bicycledesign.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/List_of_bicycle_parts"&gt;https://en.wikipedia.org/wiki/List_of_bicycle_parts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Bicycle Parts (自行車零件):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_parts.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Chains (鏈條):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_chain.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Crank (曲柄):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_crank.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Frame (車架):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_frame.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Front Derailleur (前變速器):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_frontDerailer.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Handle Bar (車把):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_handlebar.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Hub (花鼓):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_hub.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Lever (桿):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_lever.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Rear Derailleur (後變速器):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_rearDerailer.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Rear Hub and Casette (後輪花鼓與飛輪組):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_rearHub_Casette.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Seat (座墊):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_seat.jpg" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Wheel (車輪):&lt;/p&gt;
&lt;p&gt;&lt;img src="http://chiamingyen.github.io/kmolab_data/files/bicycle_wheel.jpg" width="600" /&gt;&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;Bicycle 自行車
Tire 輪胎
Rim 輪圈
Saddle 坐墊
Seat post 座桿
Seat post clamp 座桿束子
Rear brake 後剎車
Front brake 前剎車
Seat stay 後上叉
Chain stay 後下叉
Seat tube 座管
Top tube 上管
Down tube 下管
Freewheel / cassette Sprockets 飛輪
Rear Ends/Dropouts 後叉端
Derailleur Cable 變速導線
Rear Derailleur 後變速器
Chain 鏈條
Pedal 腳踏
Front Derailleur 前變速器
軸 axle
滾珠軸承 ball bearing
車鈴 bicycle ball
車架 bicycle frame
Rear suspension 後避震
Chainwheel&amp;amp;cranks 大齒盤及曲柄
Valve 汽門嘴
Spoke (輪圈)幅條
Spoke Nipple (幅條)接頭
Front fork end 前叉端
Hubs 花鼓
Quick release 快拆桿
Front fork 前叉
Brake cable 剎車導線
Front crown 前叉肩蓋
Brake cable housing 剎車導線
Brake lever 剎車握把
Bar end 小手把（副把手）
Grip/tape 握把套
Head tube 頭管
Handlebar 車把
Derailleur lever 變速桿
Stem 豎管
Head parts 車頭碗組
Kickstand 停車柱
Chain cover 鏈蓋
Head Light 前燈
Back mirror 後照鏡
Reflector 反光片
Luggage Carrier 貨架
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><category term="協同產品設計實習"></category><category term="2016 Spring"></category></entry><entry><title>2016 Spring CD Task0</title><link href="./2016-spring-cd-task0.html" rel="alternate"></link><updated>2016-02-23T18:18:27+08:00</updated><author><name>kmol</name></author><id>tag:,2016-02-23:./2016-spring-cd-task0.html</id><summary type="html">&lt;p&gt;這個實習任務的目的, 在讓學員根據分組與電腦教室座位編排的問題, 進行思考, 如何以協同方式或流程, 有效完成任務&lt;/p&gt;


&lt;p&gt;學期伊始, 一如往常, 各班學員以每 6 人一組為原則, 在 Cadlab 電腦教室安排固定座位, 但是 2016 Spring 開始, 儘管允許學員自行編組, 但是同組學員卻希望故意錯開座位, 讓所有爾後各組的產品設計解題都能夠儘量透過資訊與通訊系統完成, 而且所有溝通流程與內容都能夠存在產品開發專案中.&lt;/p&gt;
&lt;p&gt;首先採用 &lt;a href="https://ethercalc.tw/"&gt;https://ethercalc.tw/&lt;/a&gt; 讓所有上課學員, 以即時同步模式, 填入分組資料, 若以 2a 班級為例, 分組資料中只填入學員學號, 則可以直接從瀏覽器畫面中複製分組資料, 放入 SciTE 中, 存為 2016_cd_2a_1.txt, 若利用 ethercalc 的 clipboard 格式轉檔, 可以存為 csv 格式, 存為 2016_cd_2a_2.txt, 且從學校開課前學員選課資料, 可得選課學員學號名單, 存為 2016_cd_2a_3.txt.&lt;/p&gt;
&lt;p&gt;Task0 的任務, 就是以各班協同分組後所取得的這 3 個檔案開始, 依據下列敘述, 完成各班的 Cadlab 電腦教室座位表, 讓每一位學員都能夠知道所被分配的學期固定座位, 並在爾後上課依序入座.&lt;/p&gt;
&lt;p&gt;任務描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每組以 6 人為原則, 至少 4 人, 至多 7 人&lt;/li&gt;
&lt;li&gt;各組學員, 以學號遞增排序後, 排序第1者為組長, 負責代表該組與其他組進行溝通&lt;/li&gt;
&lt;li&gt;各組的班級分組序號, 則依據各組組長的學號, 再進行各組比序, 以遞增方式排列, 排序第1者為第1組, 其餘依序定下各組序號組別&lt;/li&gt;
&lt;li&gt;Cadlab 電腦教室的配置為每列 9 排, 共有 7 列, 因此若每人一台電腦排座位, 可以容納 63 名學員&lt;/li&gt;
&lt;li&gt;固定座位命名方式, 以面對講台的最右邊為第1排, 以最靠近講台者為第1列&lt;/li&gt;
&lt;li&gt;一旦各組依照學員學號排序定組序後, 第1組的第1名同學, 從第1排第1列開始固定座位, 接著排第二組的第1位同學, 排在第1排的第2列座位, 然後將第三組的第1位同學, 排在第1排的第3列座位, 依此類推&lt;/li&gt;
&lt;li&gt;座位安排中, 第1排排至第七列後, 則接著排在第2排的第1列座位上, 且各組若不及 7 位學員時, 則該座位由下一組的順位同學遞補&lt;/li&gt;
&lt;li&gt;完成座位編排後, 必須能夠轉為網頁格式, 放入各組的協同倉儲所對應的 gh-pages 網頁或 OpenShift 網頁中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可能的任務變化:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;與上述編排座位的問題類似, 在產品開發過程中, 許多設計參數可能因為特定協同團隊的意見而變更&lt;/li&gt;
&lt;li&gt;上述座位編排問題, 可能從學號遞增排序, 改為遞減排序或亂數排序&lt;/li&gt;
&lt;li&gt;可能從原先的以排 (column) 為主 (也就是先排第1排, 之後排第2排), 改為以列 (row) 為主 (也就是先排第1列, 之後排第2列)&lt;/li&gt;
&lt;li&gt;假如電腦教室的配置更動, 從 9 排 7 列改為其他不同配置時, 整個座位安排流程, 就必須因應改變&lt;/li&gt;
&lt;li&gt;換言之, 假如上述問題並非採用電腦運算的方法完成, 而以人工或類比的方式進行, 不僅耗費時間, 容易出錯, 而且一旦相關原則變更, 都將重新勞師動眾一番&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;技術回顧:&lt;/p&gt;
&lt;p&gt;針對上述問題, 若希望利用 Python3 進行解題, 需要運用下列相關函式、方法或模組:&lt;/p&gt;
&lt;p&gt;with open ... as&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openhome.cc/Gossip/Python/WithAs.html"&gt;http://openhome.cc/Gossip/Python/WithAs.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;readlines&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/tutorial/inputoutput.html"&gt;https://docs.python.org/3.4/tutorial/inputoutput.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;for ... in range&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/tutorial/controlflow.html?highlight=loop#for-statements"&gt;https://docs.python.org/3.4/tutorial/controlflow.html?highlight=loop#for-statements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;len&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functions.html?#len"&gt;https://docs.python.org/3.4/library/functions.html?#len&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;append&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/tutorial/datastructures.html"&gt;https://docs.python.org/3.4/tutorial/datastructures.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;split&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/stdtypes.html#str.split"&gt;https://docs.python.org/3.4/library/stdtypes.html#str.split&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;list&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functions.html#func-list"&gt;https://docs.python.org/3.4/library/functions.html#func-list&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;sorted&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functions.html#sorted"&gt;https://docs.python.org/3.4/library/functions.html#sorted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;filter&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functions.html#filter"&gt;https://docs.python.org/3.4/library/functions.html#filter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;None, True, not&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/c-api/none.html"&gt;https://docs.python.org/3.4/c-api/none.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/constants.html#True"&gt;https://docs.python.org/3.4/library/constants.html#True&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/reference/expressions.html#not"&gt;https://docs.python.org/3.4/reference/expressions.html#not&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;str&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functions.html#func-str"&gt;https://docs.python.org/3.4/library/functions.html#func-str&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;print&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functions.html#print"&gt;https://docs.python.org/3.4/library/functions.html#print&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;g.es&lt;/p&gt;
&lt;p&gt;&lt;a href="http://leoeditor.com/tutorial-scripting.html"&gt;http://leoeditor.com/tutorial-scripting.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;zip_longest&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/itertools.html#itertools.zip_longest"&gt;https://docs.python.org/3.4/library/itertools.html#itertools.zip_longest&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="協同產品設計實習"></category></entry><entry><title>computational thinking and digitally literate</title><link href="./computational-thinking-and-digitally-literate.html" rel="alternate"></link><updated>2016-02-21T21:47:57+08:00</updated><author><name>kmol</name></author><id>tag:,2016-02-21:./computational-thinking-and-digitally-literate.html</id><summary type="html">&lt;p&gt;運算思維與數位化教育下的未來&lt;/p&gt;


&lt;p&gt;&lt;a href="https://www.gov.uk/government/publications/national-curriculum-in-england-computing-programmes-of-study/national-curriculum-in-england-computing-programmes-of-study"&gt;https://www.gov.uk/government/publications/national-curriculum-in-england-computing-programmes-of-study/national-curriculum-in-england-computing-programmes-of-study&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;computational thinking and digitally literate&lt;/p&gt;
&lt;p&gt;運算思維與數位化教育&lt;/p&gt;
&lt;p&gt;Computing has deep links with mathematics, science and design and technology, and provides insights into both natural and artificial systems.&lt;/p&gt;
&lt;p&gt;運算與數學、科學、設計及科技都有很緊密的關聯, 能讓我們充份了解自然或人造的系統.&lt;/p&gt;
&lt;p&gt;Computing also ensures that pupils become digitally literate – able to use, and express themselves and develop their ideas through, information and communication technology – at a level suitable for the future workplace and as active participants in a digital world.&lt;/p&gt;
&lt;p&gt;運算同時確保學習者俱備數位認知, 能夠運用、表達並透過資訊與通訊科技開展理念, 並在未來的數位世界職場中成為積極的參與者.&lt;/p&gt;
&lt;p&gt;Aims:&lt;/p&gt;
&lt;p&gt;運算教育的目標:&lt;/p&gt;
&lt;p&gt;can understand and apply the fundamental principles and concepts of computer science, including abstraction, logic, algorithms and data representation&lt;/p&gt;
&lt;p&gt;能夠了解並應用電腦科學的基本原理與概念, 包括抽象、邏輯, 演算法, 以及數據表達.&lt;/p&gt;
&lt;p&gt;can analyse problems in computational terms, and have repeated practical experience of writing computer programs in order to solve such problems&lt;/p&gt;
&lt;p&gt;能夠透過運算術語分析問題, 並且運用多重的程式編寫實務經驗, 來解決問題.&lt;/p&gt;
&lt;p&gt;can evaluate and apply information technology, including new or unfamiliar technologies, analytically to solve problems&lt;/p&gt;
&lt;p&gt;能夠應用資訊科技, 對全新或原本並不熟悉的科技進行評量, 能夠採解析方法解決各種問題.&lt;/p&gt;
&lt;p&gt;are responsible, competent, confident and creative users of information and communication technology&lt;/p&gt;
&lt;p&gt;成為肯負責、能勝任、具備信心與創意的資訊及通信科技使用者.&lt;/p&gt;</summary><category term="運算思維"></category><category term="數位化教育"></category></entry><entry><title>2016 Spring Web based Content Management</title><link href="./2016-spring-web-based-content-management.html" rel="alternate"></link><updated>2016-02-21T20:36:55+08:00</updated><author><name>kmol</name></author><id>tag:,2016-02-21:./2016-spring-web-based-content-management.html</id><summary type="html">&lt;p&gt;2016 Spring 網際內容管理 W1&lt;/p&gt;


&lt;h2&gt;2016 Spring 網際內容管理:&lt;/h2&gt;
&lt;h3&gt;可攜套件倉儲:&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kmol2016 下載:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX"&gt;https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 倉儲: &lt;a href="https://github.com/2015fallhw/2016springwcm"&gt;https://github.com/2015fallhw/2016springwcm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github Pages 網站: &lt;a href="http://2015fallhw.github.io/2016springwcm/"&gt;http://2015fallhw.github.io/2016springwcm/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;網際繪圖程式庫 (與 CD 課程共用): &lt;a href="https://github.com/2015fallhw/arcidau"&gt;https://github.com/2015fallhw/arcidau&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github Pages 網站: &lt;a href="http://2015fallhw.github.io/arcidau/"&gt;http://2015fallhw.github.io/arcidau/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;結合 &lt;a href="http://reeborg.ca/"&gt;http://reeborg.ca/&lt;/a&gt; 與 &lt;a href="https://codemirror.net/"&gt;https://codemirror.net/&lt;/a&gt; 還有 &lt;a href="https://github.com/google/blockly"&gt;https://github.com/google/blockly&lt;/a&gt;,  我們能否自行打造類似 &lt;a href="https://studio.code.org/hoc/2"&gt;https://studio.code.org/hoc/2&lt;/a&gt; 的網站, 並且逐步建構泛用型網際 2D/3D 機械設計資源中心, 以探索、儲存與開發機械設計相關內容的網站邁進.&lt;/p&gt;
&lt;p&gt;參考:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/josephg/Chipmunk-js"&gt;https://github.com/josephg/Chipmunk-js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/viblo/pymunk"&gt;https://github.com/viblo/pymunk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/user/thang010146/videos"&gt;https://www.youtube.com/user/thang010146/videos&lt;/a&gt; (使用 AutoDesk Inventor 建置)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZO2f4ZQTLgWWIyTiuLdB3vkcuutS65plv7"&gt;機構介紹 1&lt;/a&gt; (pdf)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZI2f4ZdR1tblX7Tj0Wf6glOgW5fjSG6LYV"&gt;機構介紹 2&lt;/a&gt; (pdf)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZa2f4Z1faO9LKQUlQJhJkCSeQQzmHanqfy"&gt;機構介紹 3 &lt;/a&gt; (pdf)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZ32f4ZMrcoB5nWPC4coh9yQAaXSfbFuivk"&gt;機構介紹 4 &lt;/a&gt; (pdf)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.algodoo.com/"&gt;http://www.algodoo.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linkage &lt;a href="http://chiamingyen.github.io/linkage/"&gt;http://chiamingyen.github.io/linkage/&lt;/a&gt; 操作步驟:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按下 c 刪除畫面所有內容&lt;/li&gt;
&lt;li&gt;利用滑鼠左鍵, 在螢幕點出4個四連桿的4個關鍵點&lt;/li&gt;
&lt;li&gt;利用滑鼠左鍵, 點選第一個點 ,令其變為藍色&lt;/li&gt;
&lt;li&gt;再以滑鼠左鍵, 點選第1桿件的第二個點, 滑鼠按下後, 先不要放開, 等左手按下 Alt 後, 並讓 Alt 鍵與滑鼠左鍵同時放開, 就可以順利利用第1點與第2點建立一個連桿&lt;/li&gt;
&lt;li&gt;利用相同方法 ,建立第2與第3可動桿&lt;/li&gt;
&lt;li&gt;以滑鼠左鍵, 選擇第1點, 然後按下 f 鍵, 表示要固定這個點, 此時點的顏色轉為紅色, 並且釋出其對應的自由度&lt;/li&gt;
&lt;li&gt;再用相同方法 ,固定第四點&lt;/li&gt;
&lt;li&gt;選擇要追蹤的點, 然後按下 t (tracking)&lt;/li&gt;
&lt;li&gt;機構的作動則依靠, 選追蹤點, 左手按住 Shift 鍵, 然後移動滑鼠位置, 讓追蹤點隨滑鼠移動, 即可留下特定點的運動軌跡.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;歷年課程回顧&lt;/h2&gt;
&lt;h3&gt;2015 Spring 網際內容管理:&lt;/h3&gt;
&lt;p&gt;Wordpress: &lt;a href="http://wordpress-2015course.rhcloud.com/?cat=2"&gt;http://wordpress-2015course.rhcloud.com/?cat=2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cd-cadp.rhcloud.com/get_page?heading=%E7%B6%B2%E9%9A%9B%E5%85%A7%E5%AE%B9%E7%AE%A1%E7%90%86"&gt;CMSimply 網站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 倉儲: &lt;a href="https://github.com/coursemdetw/2015wcm"&gt;https://github.com/coursemdetw/2015wcm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitbook: &lt;a href="https://www.gitbook.com/book/coursemde/2015wcm"&gt;https://www.gitbook.com/book/coursemde/2015wcm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vimeo 教學影片: &lt;a href="https://vimeo.com/tag:2015wcm"&gt;https://vimeo.com/tag:2015wcm&lt;/a&gt;&lt;/p&gt;</summary><category term="2016 Spring"></category><category term="網際內容管理"></category></entry><entry><title>2015 Fall CP part 2</title><link href="./2015-fall-cp-part-2.html" rel="alternate"></link><updated>2016-02-13T09:45:39+08:00</updated><author><name>yen</name></author><id>tag:,2016-02-13:./2015-fall-cp-part-2.html</id><summary type="html">&lt;p&gt;2015 Fall 計算機程式課程內容 part2&lt;/p&gt;
&lt;p&gt;2015 Fall 計算機程式課程倉儲分別為&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcpa"&gt;https://github.com/2015fallhw/2015fallcpa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;與&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcpb"&gt;https://github.com/2015fallhw/2015fallcpb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2015 Fall CP 課程 part2 影片摘要:&lt;/p&gt;
&lt;h2&gt;CP W12&lt;/h2&gt;
&lt;h3&gt;介紹從 fix.bat 的搭建到猜顏色遊戲程式的編寫&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/147818514" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/147818514"&gt;2015fallcp_b_w12_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;


&lt;h2&gt;CP W15&lt;/h2&gt;
&lt;h3&gt;介紹近端系統的建立與啟動, Python3 指令整理, 猜數字與猜顏色遊戲的流程圖, Brython 網頁繪圖&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/150000693" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/150000693"&gt;2015cp_w15_b1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CP W17&lt;/h2&gt;
&lt;h3&gt;說明如何使用 Python 函式, 以及如何進行 Brython 網頁動態繪圖&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/151096089" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/151096089"&gt;2015fallcpa_w17&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/151109576" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/151109576"&gt;2015fallcp_w17b&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="2015 Fall cp"></category><category term="2015 Fall"></category></entry><entry><title>2015 Fall CP part 1</title><link href="./2015-fall-cp-part-1.html" rel="alternate"></link><updated>2016-02-13T09:45:39+08:00</updated><author><name>yen</name></author><id>tag:,2016-02-13:./2015-fall-cp-part-1.html</id><summary type="html">&lt;p&gt;2015 Fall 計算機程式課程內容 part1&lt;/p&gt;
&lt;p&gt;2015 Fall 計算機程式課程倉儲分別為&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcpa"&gt;https://github.com/2015fallhw/2015fallcpa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;與&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcpb"&gt;https://github.com/2015fallhw/2015fallcpb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2015 Fall CP 課程 part1 影片摘要:&lt;/p&gt;
&lt;h2&gt;CP W2&lt;/h2&gt;
&lt;h3&gt;2015 Fall 計算機程式可攜環境介紹&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140380091" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140380091"&gt;2015cp_w2_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;


&lt;h3&gt;說明如何利用 python -m http.server 分享近端檔案&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140381241" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140381241"&gt;2015cp_w2_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;介紹如何利用 fix.bat 修補 C 槽既有的可攜程式系統, 說明 SciTE 如何執行 Python3 程式, 如何利用 gh-pages 分支網頁繳交作業&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140383708" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140383708"&gt;2015cp_w2_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;介紹如何從可攜系統的修補與啟動, 到如何利用 Github Pages 的網頁來繳交各週作業&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140394246" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140394246"&gt;2015cp_b_w4&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;2015 Fall 課程工作與環境介紹&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140874547" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140874547"&gt;2015Fall 使用環境與工具介紹&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;英文打字的指法練習介紹, 說明 Github 倉儲的建立使用與刪除.&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140876400" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140876400"&gt;Github 倉儲建立, 使用與刪除&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;介紹 Github 倉儲分支的建立與使用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140878456" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140878456"&gt;Github 倉儲分支建立與使用&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CP W3&lt;/h2&gt;
&lt;h3&gt;隨身程式系統的應用再提醒 (fix.zip), Leo Editor, Pelican, Markdown 模組的安裝設定與啟動, notebook.py 中編碼的設定&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141129640" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141129640"&gt;2015fall_cp_w3_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/141142727" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141142727"&gt;2015cp_w3_b1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/141145747" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141145747"&gt;2015cp_w3_b3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/141144113" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141144113"&gt;2015cp_w3_b2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明工程師的工作分類, 工程與科學的相輔相成, 解釋何以人文是工程師的養份, 了解科學在探究自然現況, 工程則需面對自然挑戰, 解決人文想像與需求&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141131417" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141131417"&gt;2015fall_cp_w3_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何利用 Github 建立倉儲, 起始倉儲, git clone 倉儲, 建立分支, 切換 gh-pages 分支, 提交 gh-pages 分支版本, 推送分支版本&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141132740" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141132740"&gt;2015fall_cp_w3_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明 Python 程式執行模式, 可以採互動式執行, SciTE 環境下執行, Jupyter 網頁 noteook 環境下執行, Brython 瀏覽器中執行等&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141134146" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141134146"&gt;2015fall_cp_w3_4&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CP W5&lt;/h2&gt;
&lt;h3&gt;說明計算機程式作為電腦輔助與協同產品設計系列課程的先導課程, 必須在學習 Python3 程式語法的同時, 架構一個可以永續改進使用的系統&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/142582837" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/142582837"&gt;2015cp_w5_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;fix.zip 內容的細步流程介紹, 從 markdown 透過 Pelican 指令的執行, 轉換為放上 Github Pages 網頁的 html 檔案資料, liquid_tags 延伸程式的應用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/142584067" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/142584067"&gt;2015cp_w5_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CP W6&lt;/h2&gt;
&lt;h3&gt;介紹英文教學影片的字幕所在位置, 說明如利用 VLC 在近端播放教學影片&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/143330980" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143330980"&gt;2015cp_w6_a_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何將各學員的作業整合到全班協同倉儲, 自行新增為全班倉儲的協同者&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/143337293" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143337293"&gt;2015cp_w6_a_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/143345717" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143345717"&gt;2015cp_w6_b_4&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;示範如何修正內含 git 衝突標示的 Leo Editor 檔案&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/143337483" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143337483"&gt;2015cp_w6_a_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CP W7&lt;/h2&gt;
&lt;h3&gt;介紹如何建立有效率的機械設計工程師可攜程式環境 (Anaconda Python based), 學習計算機程式的概念, 認識程式設計與機械設計工程師角色間的關係&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/144078159" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/144078159"&gt;2015_cp_w7_a_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明近端與 Jupyter 環境的 Python 程式執行, print 與 for 迴圈應用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/144080408" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/144080408"&gt;2015_cp_w7_a_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何將計算機程式的內容放到 gh-pages 網頁&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/144081268" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/144081268"&gt;2015_cp_w7_a_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何利用 git reset -- hard 版本編號, 回復舊版本資料&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/144089423" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/144089423"&gt;2015fall_cp_w7_b1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何修補被弄亂的全班倉儲&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/144089423" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/144089423"&gt;2015fall_cp_w7_b1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="2015 Fall cp"></category><category term="2015 Fall"></category></entry><entry><title>2015 Fall CADP part 2</title><link href="./2015-fall-cadp-part-2.html" rel="alternate"></link><updated>2016-02-13T09:45:39+08:00</updated><author><name>yen</name></author><id>tag:,2016-02-13:./2015-fall-cadp-part-2.html</id><summary type="html">&lt;p&gt;2015 Fall 電腦輔助設計實習課程內容 part2&lt;/p&gt;
&lt;p&gt;電腦輔助設計實習課程倉儲分別為:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcadpb"&gt;https://github.com/2015fallhw/2015fallcadpb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;與&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcadpa"&gt;https://github.com/2015fallhw/2015fallcadpa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2015 Fall CADP 課程 part2 影片摘要:&lt;/p&gt;
&lt;h2&gt;CADP W10&lt;/h2&gt;
&lt;h3&gt;利用電腦解決機械設計工程師所面臨的各種問題&lt;/h3&gt;
&lt;p&gt;電腦輔助設計主要探討工程師該如何利用電腦解決所面臨的各種問題, 這些問題存在於人的各種活動當中, 而人的活動可以從3個不同的軸向來加以探討, 也就是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人文的軸向, 其中包括與人類思想層面有關的各種活動, 也就是文學, 宗教, 音樂與藝術等活動.&lt;/li&gt;
&lt;li&gt;科學的軸向, 其中牽涉到人所處的自然環境, 科學家主要在利用系統方法與工具, 探究存在自然界的各種原理原則, 而工程師在解決問題時, 必須面對自然界的各項挑戰, 依據各種已知的科學方法, 從人文的角度出發, 創造各種產品與服務, 來改善人的生存環境, 提升人的生活價值.&lt;/li&gt;
&lt;li&gt;產品與服務的軸向, 此一軸向的活動, 即是工程師以人文想像層面的內容作為養份, 面對自然環境, 以科學認知及方法, 創造各種產品與服務的項目.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;電腦在工程解題所扮演的角色:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提升資訊的傳輸效能, 利用網路, Git (2005 之後), Github (2008 之後) 讓數位資訊的傳輸更有效能.&lt;/li&gt;
&lt;li&gt;強化文字、視覺與口語的溝通效率, 以隨選或即時媒體, 讓協同成員互通想法, 闡述設計, 激發創意.&lt;/li&gt;
&lt;li&gt;簡化數據與資料的收集與儲存, 搜索引擎與資料庫的搭配使用.&lt;/li&gt;
&lt;li&gt;支援各種設計與運算分析所需要的軟硬體配備, CAD, CAE, 虛擬實境, 擴增實境, 平行運算等技術的支援.&lt;/li&gt;
&lt;li&gt;支援各種層面的製造規劃與管理, CAM, Computer Aided Process Planning 等.&lt;/li&gt;
&lt;/ol&gt;
&lt;iframe src="https://player.vimeo.com/video/145820006" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/145820006"&gt;2015cadp_w10_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;


&lt;h3&gt;介紹可攜程式系統的搭建流程與細節&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先下載與操作系統對應的 Miniconda (使用 Python3)&lt;/li&gt;
&lt;li&gt;利用 conda install pip&lt;/li&gt;
&lt;li&gt;利用 pip install pelican Markdown 安裝 pelican 與 Markdown 模組&lt;/li&gt;
&lt;li&gt;可以利用 pip uninstall leo 移除先前所安裝的 Leo Editor 模組&lt;/li&gt;
&lt;li&gt;利用 conda install pyqt (由 conda 自行選擇可以與既有系統相容的 pyqt 版本)&lt;/li&gt;
&lt;/ol&gt;
&lt;iframe src="https://player.vimeo.com/video/145825547" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/145825547"&gt;2015cadp_w10_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W11&lt;/h2&gt;
&lt;h3&gt;fix.zip 修補流程再介紹, 說明電腦輔助機械設計的目標&lt;/h3&gt;
&lt;p&gt;將隨身碟中的資料, 複製到電腦硬碟, 然後再利用 start.bat 啟動硬碟上的可攜程式系統.&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/146592105" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/146592105"&gt;2015fallcadpw11_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;啟動存放在全班倉儲網頁中的分組報告&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/146593944" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/146593944"&gt;2015fallcadpw11_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W12&lt;/h2&gt;
&lt;h3&gt;fix.bat 的詳細介紹, Leo Editor 的近端 pip install 應用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/147276192" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/147276192"&gt;2015cadpb_w12_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;利用各自 user 目錄下的 Leo Editor 檔案, 發表位於全班 gh-pages 網頁的分組報告, 以電腦輔助方法管理 reveal.js 投影片中的學員學號註記, 介紹網頁式正齒輪齒面寬輔助設計, 說明正齒輪囓合繪製與組合的靜態繪圖與動態繪圖原理&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/147279887" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/147279887"&gt;2015cadpb_w12_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W13&lt;/h2&gt;
&lt;h3&gt;fix.bat 環境修補複習&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/148455580" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/148455580"&gt;cadpaw13_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何利用各學員 user/學號 目錄下的 .leo 檔案發表分組報告, 介紹如何利用 Github pages 展示零組件的 .stl 檔案&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/148458668" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/148458668"&gt;cadpaw13_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W14&lt;/h2&gt;
&lt;h3&gt;介紹Creo Parametric 零件轉檔方法, gh-pages 網頁上的零件展示, Binary 與 ASCII STL 檔案格式介紹&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/148825230" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/148825230"&gt;2015cadp_w14_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;Onshape 介紹, 開始利用 OnShape 繪製 Nutcracker 零組件&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/149359397" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/149359397"&gt;2015cadp_w14_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W15&lt;/h2&gt;
&lt;h3&gt;說明如何利用 Onshape, 以雲端協同方式繪製 Nutcracker 零件, 組立 Nutcracker 零件&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/149940498" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/149940498"&gt;2015cadp_w15_a1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W16&lt;/h2&gt;
&lt;h3&gt;介紹 Nutcracker 在 Onshape 環境中如何進行組立, 進行各種 Onshape 組立約束條件的細部特性討論&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/150140635" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/150140635"&gt;2015fall_cadp_b_w16&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;說明如何利用 Solvespace 分析 Nutcraker 機構的 Piston 滑動行程極限&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/150401255" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/150401255"&gt;2015fallcadp_a_w16_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W17&lt;/h2&gt;
&lt;h3&gt;Nutcracker 機構滑動 Piston 零件的滑動行程範圍分析, 說明如何以 Solvespace 圖解法, 以 Sympy 符號及數值分析推導機構邊界直線方程式, 或採基因演算法進行分析&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/150636968" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/150636968"&gt;2015fall_cadpb_w17&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/150985277" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/150985277"&gt;2015fallcadpa_w17&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="2015 Fall cadp"></category><category term="2015 Fall"></category></entry><entry><title>2015 Fall CADP part 1</title><link href="./2015-fall-cadp-part-1.html" rel="alternate"></link><updated>2016-02-13T09:45:39+08:00</updated><author><name>yen</name></author><id>tag:,2016-02-13:./2015-fall-cadp-part-1.html</id><summary type="html">&lt;p&gt;2015 Fall 電腦輔助設計實習課程內容 part1&lt;/p&gt;
&lt;p&gt;電腦輔助設計實習課程倉儲分別為:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcadpb"&gt;https://github.com/2015fallhw/2015fallcadpb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;與&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/2015fallcadpa"&gt;https://github.com/2015fallhw/2015fallcadpa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2015 Fall CADP 課程 part1 影片摘要:&lt;/p&gt;
&lt;h2&gt;CADP W2&lt;/h2&gt;
&lt;h3&gt;介紹可攜程式環境的下載與使用&lt;/h3&gt;
&lt;p&gt;此一系統包括 Python3 程式環境, Leo Editor, Jupyter, 而每週作業則利用 reveal.js 製作網頁式投影片, 利用 Pelican 產生靜態網頁, 並且讓各學員可以在個人倉儲 gh-pages 與全班倉儲 gh-pages 網頁上來呈現各階段所完成的作業內容.&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/139886319" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/139886319"&gt;2015fallcadp_w2_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;


&lt;h3&gt;利用電腦輔助方法, 善用 USB 客製化資料與 C 槽的既有隨身系統, 設法修改 C 槽啟動的 start.bat 批次檔案, 建立符合需求的可攜程式環境.&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/139890840" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/139890840"&gt;2015cadp_w2_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;介紹 reveal.js 網頁式投影片的使用方法, 介紹 Github pages 倉儲分支 gh-pages 的用法.&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/139892322" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/139892322"&gt;2015cadp_w2_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;複習倉儲分支之間的切換方法 (git checkout master 或 git checkout gh-pages)&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/139893872" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/139893872"&gt;2015cadp_w2_6&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;Github 倉儲中 Leo Editor 5.1 版 @clean 節點指令與 reveal.js 網頁式投影片的用法.&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/139913541" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/139913541"&gt;2015cadp_w2_reveal&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;甲班 CADP W2&lt;/p&gt;
&lt;h3&gt;可攜程式系統的建立與使用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140277094" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140277094"&gt;2015cadpa_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;avi 影片轉 flv 格式, 以可攜式 VLC 觀看 flv 影片, 利用 python -m http.server 執行近端檔案分享&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140381241" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140381241"&gt;2015cp_w2_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;git push origin gh-pages 系列指令的應用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/140281702" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/140281702"&gt;2015cadpa_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W3&lt;/h2&gt;
&lt;h3&gt;Pelican 靜態網頁系統建立與分組協同, Solvespace 零件繪圖&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141021392" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141021392"&gt;2015_cadpa_w3_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;git rm 的使用, 以及 git 提交, 訊息註記與推送設定&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141024439" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141024439"&gt;2015_cadpa_w3_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;Solvespace 零件電腦輔助繪圖&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141026116" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141026116"&gt;2015_cadpa_w3_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W4&lt;/h2&gt;
&lt;h3&gt;根據 What Engineers Do? 電子文件, 說明科學與工程, 自然與人文間的關係&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/141370058" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/141370058"&gt;2015fall_cadp_w4_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W5&lt;/h2&gt;
&lt;h3&gt;從 2008 年舊資料的回顧, 說明在地化與國際化的整合, 培養有專長, 能就業, 說明文化與教育對工程師的重要影響, 以及追求卓越的本意&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/142093273" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/142093273"&gt;2015cadp_w5_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;zoomit.exe 在錄製電腦輔助設計說明流程上的應用, Leo Editor 與 Pelican 的使用&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/142473037" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/142473037"&gt;2015cadp_w5_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;電腦輔助設計系列課程的標準執行流程, 可攜, 永續與體貼的電腦輔助設計方法&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/142093479" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/142093479"&gt;2015cadp_w5_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;Creo2 primer 電子書的網頁化處理&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/142098889" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/142098889"&gt;2015cadp_w5_3&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W6&lt;/h2&gt;
&lt;h3&gt;啟動可攜系統, Waht Engineers Do? 與 Creo 2 Parametric Primer 資料摘要, Creo Parametric 零件繪製與組立, 開始建立全班協同 gh-pages 網頁, 自行新增為倉儲協同者, 從 git clone 開始參與全班資料協同&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/143225578" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143225578"&gt;2015cadp_a_w6_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;CADP W7&lt;/h2&gt;
&lt;h2&gt;學員自行新增為全班協同倉儲的協同者, 示範如何參與網頁協同資料管理&lt;/h2&gt;
&lt;iframe src="https://player.vimeo.com/video/143572506" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143572506"&gt;2015fall_cadp_w7_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;start.bat 內容的修改, 設法透過 Jupyter 執行網頁式設計分析或協同網頁資料編輯&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/143574887" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143574887"&gt;2015fall_cadp_w7_2&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;期中報告內容說明, Creo 2 Parametric Primer 電子書閱讀與零件繪製與零件組操作練習&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/143963816" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/143963816"&gt;2015cadp_w7_a1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="2015 Fall cadp"></category><category term="2015 Fall"></category></entry><entry><title>2016 WCM course</title><link href="./2016-wcm-course.html" rel="alternate"></link><updated>2016-02-13T09:45:39+08:00</updated><author><name>yen</name></author><id>tag:,2016-02-13:./2016-wcm-course.html</id><summary type="html">&lt;p&gt;2016 Spring 網際內容管理課程規劃&lt;/p&gt;
&lt;h2&gt;github pages 上的靜態網頁系統&lt;/h2&gt;
&lt;p&gt;Github pages, Leo Editor 與 Pelican site builder&lt;/p&gt;
&lt;h2&gt;html 與 Javascript (Brython based)&lt;/h2&gt;
&lt;h2&gt;Python3 的動態網頁 (Flask 與 SQLite based)&lt;/h2&gt;
&lt;p&gt;OpenShift Web Console: &lt;a href="https://www.openshift.com"&gt;https://www.openshift.com&lt;/a&gt; 與近端 Flask: &lt;a href="http://flask.pocoo.org"&gt;http://flask.pocoo.org&lt;/a&gt; based 網站程式開發&lt;/p&gt;


&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/embik/bloks"&gt;https://github.com/embik/bloks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/peterhudec/authomatic"&gt;https://github.com/peterhudec/authomatic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sigmavirus24/github3.py"&gt;https://github.com/sigmavirus24/github3.py&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="網際內容管理"></category><category term="2016 Spring"></category></entry><entry><title>2015 Fall Final Schedule</title><link href="./2015-fall-final-schedule.html" rel="alternate"></link><updated>2016-01-11T15:48:04+08:00</updated><author><name>yen</name></author><id>tag:,2016-01-11:./2015-fall-final-schedule.html</id><summary type="html">&lt;p&gt;2015 Fall 學期成績評分時程規劃&lt;/p&gt;
&lt;p&gt;最後資料改版期限: 2016.01.20 (星期三) 24:00&lt;/p&gt;
&lt;p&gt;評分流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從各班個人連結頁面中 (&lt;a href="https://github.com/2015fallhw/2015fallcadpa/wiki"&gt;2a&lt;/a&gt;, &lt;a href="https://github.com/2015fallhw/2015fallcadpb/wiki"&gt;2b&lt;/a&gt;, &lt;a href="https://github.com/2015fallhw/2015fallcpa/wiki"&gt;1a&lt;/a&gt;, &lt;a href="https://github.com/2015fallhw/2015fallcpa/wiki"&gt;1b&lt;/a&gt;), 進入各學員在各班倉儲中對應的&lt;strong&gt;個人 gh-pages 網頁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;從上述頁面右下方的 Blogroll 中&lt;strong&gt;最下方&lt;/strong&gt;連結 (名稱為"學號 個人網頁"), 進入學員個人單獨的 gh-pages 網頁&lt;/li&gt;
&lt;li&gt;根據上述兩個頁面中的資料, 配合各課程的講授內容, 依據 &lt;strong&gt;投影片&lt;/strong&gt;, &lt;strong&gt;操作影片&lt;/strong&gt;以及頁面上的其他&lt;strong&gt;相關檔案資料&lt;/strong&gt;評分.&lt;/li&gt;
&lt;li&gt;從各班的協同網頁中, 各組所公佈的分組報告中的 &lt;strong&gt;投影片&lt;/strong&gt;, &lt;strong&gt;操作影片&lt;/strong&gt;以及頁面上的其他&lt;strong&gt;相關檔案資料&lt;/strong&gt;評分.&lt;/li&gt;
&lt;li&gt;cadp 課程另外將參酌學員所完成的 &lt;strong&gt;Solvespace 零件檔案&lt;/strong&gt;, &lt;strong&gt;Creo Parametric 零組件檔案&lt;/strong&gt;, Onshape 零組件檔案評分.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;2015 Fall 電腦輔助設計實習課程甲班:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cadpa 倉儲: &lt;a href="https://github.com/2015fallhw/2015fallcadpa"&gt;https://github.com/2015fallhw/2015fallcadpa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cadpa 網頁: &lt;a href="http://2015fallhw.github.io/2015fallcadpa"&gt;http://2015fallhw.github.io/2015fallcadpa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;個人連結: &lt;a href="https://github.com/2015fallhw/2015fallcadpa/wiki"&gt;https://github.com/2015fallhw/2015fallcadpa/wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2015 Fall 電腦輔助設計實習課程乙班:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cadpb 倉儲: &lt;a href="https://github.com/2015fallhw/2015fallcadpb"&gt;https://github.com/2015fallhw/2015fallcadpb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cadpb 網頁: &lt;a href="http://2015fallhw.github.io/2015fallcadpb"&gt;http://2015fallhw.github.io/2015fallcadpb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;個人連結: &lt;a href="https://github.com/2015fallhw/2015fallcadpb/wiki"&gt;https://github.com/2015fallhw/2015fallcadpb/wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2015 Fall 計算機程式課程甲班:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpa 倉儲: &lt;a href="https://github.com/2015fallhw/2015fallcpa"&gt;https://github.com/2015fallhw/2015fallcpa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cpa 網頁: &lt;a href="http://2015fallhw.github.io/2015fallcpa"&gt;http://2015fallhw.github.io/2015fallcpa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;個人連結: &lt;a href="https://github.com/2015fallhw/2015fallcpa/wiki"&gt;https://github.com/2015fallhw/2015fallcpa/wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2015 Fall 計算機程式課程乙班:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpb 倉儲: &lt;a href="https://github.com/2015fallhw/2015fallcpb"&gt;https://github.com/2015fallhw/2015fallcpb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cpb 網頁: &lt;a href="http://2015fallhw.github.io/2015fallcpb"&gt;http://2015fallhw.github.io/2015fallcpb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;個人連結: &lt;a href="https://github.com/2015fallhw/2015fallcpb/wiki"&gt;https://github.com/2015fallhw/2015fallcpb/wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="2015 Fall"></category></entry></feed>